{"pages":[{"title":"关于我","text":"Tusi，专注大前端技术分享与架构，关注用户体验","link":"/about/index.html"}],"posts":[{"title":"记一次Navicat for MySQL 10060错误的解决过程","text":"最近加班挺多，所以也好久没远程访问自己云服务器上的MySQL数据库了。今天本地启动Node服务时连不上MySQL，照常用Navicat For MySQL连接远程数据库进行检查，结果发现突然报错了。 12003-Can’t connect to MySQL server on ‘XXX.XX.XX.XX’（10060） 检查网络第一反应还是检查网络是不是正常，所以就马上ping测试一下，然而发现并不是网络问题，可以正常ping通。 12345ping XXX.XX.XX.XX正在 Ping XXX.XX.XX.XX 具有 32 字节的数据:来自 XXX.XX.XX.XX 的回复: 字节=32 时间=64ms TTL=47来自 XXX.XX.XX.XX 的回复: 字节=32 时间=86ms TTL=47 检查安全组然后就想着看看云服务器的安全组设置是否有问题，但是之前都没出过这个问题，讲道理安全组出现问题的可能性不大，但还是先检查下为妙。 登录腾讯云后，发现实例对应的安全组设置妥妥的，没有什么问题。 检查下用户权限由于是我自己的服务器，所以用的都是root用户。需要在xshell中登录MySQL查询下user表。 12345678910111213mysql -uroot -p输入密码mysql&gt; use mysqlmysql&gt; select host,user from user;+-----------+------------------+| host | user |+-----------+------------------+| % | root || localhost | mysql.infoschema || localhost | mysql.session || localhost | mysql.sys |+-----------+------------------+4 rows in set (0.00 sec) 可以发现，root对应的host是%，任意的意思，也就意味着root用户在连接MySQL时不受ip约束。 所以说也不是这里的问题啦！ 检查CentOS防火墙这是很容易忽略的一步，可能很多人都会认为安全组已经设置好了，不必再检查CentOS的防火墙。其实是很有必要检查防火墙的，我们应该把3306放通，再重启防火墙。 1234[root@VM_0_14_centos ~]# firewall-cmd --permanent --zone=public --add-port=3306/tcpsuccess[root@VM_0_14_centos ~]# firewall-cmd --reloadsuccess 然后一看，很愉快，Navicat for MySQL连接远程数据库成功！","link":"/10060错误的解决过程.html"},{"title":"Angular4中使用jquery和bootstrap","text":"在angular开发中某些场景可能需要jquery和bootstrap，那么如何使用它们呢？ Angular中引用jquery安装第一步，我们使用npm安装jquery 1npm install --save jquery 使用我们在ts文件中引入jquery。 123import * as $ from &apos;jquery&apos;;// 可以在ngOninit方法中打印进行测试console.log($(&apos;body&apos;)); 引入jquery类型在使用过程中，好像是没有什么问题的，但是好像通过点号调用jquery方法时，没有任何代码提示（我使用的是VSCode）。原因是编辑器不识别jquery的类型，所以不知道jquery中可以调用哪些方法。因此我们需要引入类型。 1npm install --save @types/jquery 这个时候，我们再通过点号调用jquery方法时，就会有代码提示了。如： 1$('body').hide(); Angular中引用bootstrap如何在angular中使用bootstrap呢？方法是差不多的。首先我们安装bootstrap。 1npm install --save bootstrap 我们主要用到的是bootstrap.min.css和bootstrap.min.js。需要在.angular-cli.json中进行配置。 1234567\"styles\": [ \"styles.css\", \"../node_modules/bootstrap/dist/css/bootstrap.min.css\"],\"scripts\": [ \"../node_modules/bootstrap/dist/js/bootstrap.min.js\"] 我配置之后还是不生效，可能是由于我ng eject后配置出了些问题，后续改下webpack配置应该可以实现。这里我先放在index.html中引用了。 12345&lt;!-- 引入js --&gt;&lt;script src=\"./node_modules/jquery/dist/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"./node_modules/bootstrap/dist/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;!-- 引入css --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./node_modules/bootstrap/dist/css/bootstrap.min.css\"&gt; 配置完成后，localhost可以正常使用bootstrap了。但是打包时出现问题了。因为index.html引用的是node_modules里面的资源，而我的webpack资源配置没有加上它们，导致404问题。于是我把这三个文件放在了assets里面，改成如下引用方式： 123&lt;script src=\"assets/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"assets/js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"assets/css/bootstrap.min.css\"&gt; 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/Angular4中使用jquery和bootstrap.html"},{"title":"CentOS7系统下修改mysql8.0版本密码","text":"忘记mysql登录密码是很常见的操作，今天讲一下linux centos7下mysql8.0版本修改密码的方法。 踩坑网上很多文章说的是mysql5.x版本的修改密码方法，按照这些方法做就会遇到坑了。 忘记密码了，首先尝试修改mysql的配置文件/etc/my.cnf，有的人安装目录可能不太一样，配置文件会是/etc/mysql/my.cnf或者其他的目录下。 在[mysqld]下面添加一行，可以跳过密码登录 1skip-grant-tables 重启mysqld服务 1service mysqld restart 输入mysql回车进入mysql命令行，尝试执行 1update user set password=password(&quot;123456&quot;) where user=&quot;root&quot;; 直接就报语句错误了，看来可能是password函数有问题。 ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘(“123456”) where user=”root”‘ at line 1 接着尝试另一个方法。 1mysql&gt; ALTER USER &apos;root&apos;@&apos;*&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos; 也报错，–skip-grant-tables模式下，不能运行这条语句。 ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement 于是我先查查user表的数据。 1select user, password from user 发现user表中根本没有password这个字段，上网查了后发现只有authentication_string，在mysql5.7.9后就废弃了password字段和password()函数。 需要先将authentication_string设置为空 1update user set authentication_string = ‘’ where user = ‘root’; 然后退出mysql，删除/etc/my.cnf的skip-grant-tables，重启mysqld服务。 接着尝试登录mysql 1mysql -uroot -p 直接回车登录mysql，再使用alter修改用户密码 1alter user ‘root’@’%’ indentified by ‘123456’; 提示成功！！！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/CentOS7系统下修改mysql8-0版本密码.html"},{"title":"CentOS7系统下安装mysql8.0.13版本","text":"1.进入到https://www.mysql.com/downloads/msyql下载页，选择社区版 2.查看linux版本，选择对应的版本下载 3.将下载的文件mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz拷贝到linux服务器上的某目录下，然后解压，再复制到usr/local目录，并改名为mysql 1234[root@VM_0_14_centos mysql]# tar -xvf mysql-8.0.13-linux-glibc2.12-x86_64.tar.xz[root@VM_0_14_centos mysql]# cp -rv mysql-8.0.13-linux-glibc2.12-x86_64 /usr/local[root@VM_0_14_centos mysql]# cd /usr/local [root@VM_0_14_centos local]# mv mysql-8.0.13-linux-glibc2.12-x86_64 mysql 4.添加mysql用户 1useradd -s /sbin/nologin -M mysql 5.msyql初始化 1/usr/local/mysql/bin/mysqld --initialize --user=mysql 此时会生成临时密码 1234[root@VM_0_14_centos mysql]# /usr/local/mysql/bin/mysqld --initialize --user=mysql2019-01-20T10:56:07.718326Z 0 [System] [MY-013169] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) initializing of server in progress as process 58262019-01-20T10:56:16.915217Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: twi=Tlsi&lt;0O!2019-01-20T10:56:20.410563Z 0 [System] [MY-013170] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) initializing of server has completed 6.复制启动、关闭脚本 1cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld 7.修改配置文件，wq保存退出 12345678910vim /etc/my.cnf[mysqld] basedir = /usr/local/mysql datadir = /var/lib/mysql socket = /var/lib/mysql/mysql.sock character-set-server=utf8 [client] socket = /var/lib/mysql/mysql.sock default-character-set=utf8 8.启动数据库服务 1service mysqld start 报错 mysqld_safe Directory ‘/var/lib/mysql’ for UNIX socket file don’t exists. 一是因为没有/var/lib/mysql这个目录，二是没有写的权限，mysql.sock文件无法生成。 12[root@VM_0_14_centos lib]# mkdir mysql[root@VM_0_14_centos lib]# chmod 777 /var/lib/mysql 再次运行service mysqld start报另一个错 1Starting MySQL. ERROR! The server quit without updating PID file (/var/lib/mysql/VM_0_14_centos.pid). 打印出具体报错信息 1234567891011121314[root@VM_0_14_centos mysql]# cat VM_0_14_centos.err2019-01-20T11:11:45.906800Z 0 [System] [MY-010116] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) starting as process 77882019-01-20T11:11:45.910813Z 0 [Warning] [MY-013242] [Server] --character-set-server: &apos;utf8&apos; is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.2019-01-20T11:11:45.925456Z 1 [ERROR] [MY-011011] [Server] Failed to find valid data directory.2019-01-20T11:11:45.925586Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.2019-01-20T11:11:45.925600Z 0 [ERROR] [MY-010119] [Server] Aborting2019-01-20T11:11:45.926342Z 0 [System] [MY-010910] [Server] /usr/local/mysql/bin/mysqld: Shutdown complete (mysqld 8.0.13) MySQL Community Server - GPL.2019-01-20T11:12:00.049920Z 0 [System] [MY-010116] [Server] /usr/local/mysql/bin/mysqld (mysqld 8.0.13) starting as process 79752019-01-20T11:12:00.052469Z 0 [Warning] [MY-013242] [Server] --character-set-server: &apos;utf8&apos; is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.2019-01-20T11:12:00.060600Z 1 [ERROR] [MY-011011] [Server] Failed to find valid data directory.2019-01-20T11:12:00.060745Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed.2019-01-20T11:12:00.060759Z 0 [ERROR] [MY-010119] [Server] Aborting2019-01-20T11:12:00.061610Z 0 [System] [MY-010910] [Server] /usr/local/mysql/bin/mysqld: Shutdown complete (mysqld 8.0.13) MySQL Community Server - GPL. 看不出来具体是哪里的问题，于是运行service –status-all，有报错信息 ERROR! MySQL is not running, but lock file (/var/lock/subsys/mysql) exists 有网友说删了该文件就可以，结果我删了也没用。 那就接着排查刚才的err文件，关键的错误应该是这两行 122019-01-20T11:11:45.925456Z 1 [ERROR] [MY-011011] [Server] Failed to find valid data directory.2019-01-20T11:11:45.925586Z 0 [ERROR] [MY-010020] [Server] Data Dictionary initialization failed. 于是查找my.cnf，与data目录有关的就是datadir=/var/lib/mysql这一条配置了，我尝试性地删了这一行，结果成功了，service mysqld start成功！ 9.mysql -u root -p登录mysql报错解决方法如下： 12cd /usr/local/bin ln -fs /usr/local/mysql/bin/mysql mysql 10.show databases报错 1you must reset your password using ALTER USER statement before executing this statement. 解决方法： 1alter user user() identified by &apos;123456&apos;; 11.用ip无法远程登录mysql，只能用localhost在linux服务器登录修改权限配置 1grant all privileges on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;123456&apos;; 但是报错 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘identified by ‘123456’ at line 1 解决方法： 123use mysql;update user set host = &apos;%&apos; where user = &apos;root&apos;;flush privileges; 接着用navicat连接时报错 Client does not support authentication protocol requested by server; consider upgrading MySQL client 解决方法： 1ALTER USER &apos;root&apos;@&apos;*&apos; IDENTIFIED WITH mysql_native_password BY &apos;123456&apos;; 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/CentOS7系统下安装mysql8-0-13版本.html"},{"title":"Chrome远程调试手机端UC浏览器","text":"今天在手机UC上发现我的一个网页打不开，而在PC上是正常的，因此需要通过Chrome远程调试手机端UC浏览器查下问题，折腾了老久才弄好。 获取 Google USB 驱动程序 首先将手机通过USB接口与PC连接 接着要确认手机USB驱动程序是不是正常，可以在设备管理器中查看，如果设备左侧没有黄色感叹号，则说明正常。 如果不正常就需要手动安装了，给个链接：获取 Google USB 驱动程序 开发者选项 打开手机的开发者选项 进入手机中 我的设备 -&gt; 全部参数，连续7次点击版本号，以Redmi K20 Pro为例，是点击MIUI版本七次。 接着就可以进入 更多设置 -&gt; 开发者选项 中开启开发者选项了。 允许USB调试 接着滚动到下方 调试 处，允许 USB调试。 开始调试 打开chrome://inspect/，开启Discover USB devices 使用UC开发版访问需要调试的网页 点击chrome上对应网页的inspect打开调试界面。 也可以断点调试，基本上与chrome PC端调试无异。 建议其实最重要的应该是fanqiang吧，如果遇到无法调试，报HTTP 404这类的问题，基本上是要fanqiang了。^_^ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/Chrome远程调试手机端UC浏览器.html"},{"title":"ES5，ES6的简要说明及浏览器支持性总结","text":"前端开发离不开javascript语言，而与之密切联系的就是ECMAScript。 ##1.什么是ECMAScript？ 摘自百度百科：ECMAScript是一种由Ecma国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。下文中就以ES和JS来简称。简单说，ES是JS的一种语言标准。ES正在不断发展，目前我们接触比较多的就是ES5和ES6（ES6也叫ES2015）了。 ##2.ES5的简单介绍 ###2.1 首先说一下兼容性问题 从caniuse上面可以查询到，ES的兼容性概览。下面就主要浏览器进行说明：IE：可以看到IE6，IE7是完全不支持的。而IE8是只支持一些内容，参考引用4，IE9是大部分支持，支持度参考引用2。Chrome：Chrome 23版本之后就是完全支持的了。1922版本有不兼容的地方，参考引用1。Firefox：Firefox 21版本之后就是完全支持的了。420版本有不兼容的地方，参考引用1。其他浏览器参考caniuse：【1】Does not support parseInt() ignoring leading zeros.【2】Does not support Strict mode.【3】Does not support zero-width chars in identifiers &amp; Immutable undefined.【4】IE8 has virtually no ES5 support, but does support Object.defineProperty, Object.getOwnPropertyDescriptor, JSON parsing &amp; Property access on strings. ###2.2 ES5有哪些新特性呢？ ####2.2.1 严格模式 严格模式是ECMAScript 5的新特性，它允许你把整个程序，或者某个函数，放置在“严格”的操作语境中。使用方法是在作用域开头加上这样一条语句。 1&quot;use strict&quot;; ####2.2.2 Object新增方法 （1）Object.create() 创建一个具有指定原型且可选择性地包含指定属性的对象 1Object.create(__proto__, [ propertiesObject ]) （2）Object.getPrototypeOf() 返回该对象的原型 1Object.getPrototypeOf(object) （3）Object.getOwnPropertyNames() 返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组 1Object.getOwnPropertyNames(object) （4）Object.keys() 返回一个由给定对象的自身可枚举属性组成的数组。而使用for-in 循环时，还会枚举其原型链上的属性。 1Object.keys(object) （5）Object.defineProperty() 在一个对象上定义一个新属性，或者修改一个已经存在的属性， 并返回这个对象 1Object.defineProperty(object, property, descriptor) （6）Object.defineProperties() 在一个对象上添加或修改一个或者多个自有属性，并返回该对象 1Object.defineProperties(object, properties) （7）Object.getOwnPropertyDescriptor() 返回对象上一个自有属性对应的属性描述符（不需要从原型链上进行查找的属性）。如果指定的属性存在于对象上，则返回其属性描述符（property descriptor），否则返回 undefined 1Object.getOwnPropertyDescriptor(object, property) （8）Object.seal() 密封一个对象，并返回被密封后的对象。密封对象不能添加新的属性，不能删除已有属性，以及不能修改已有属性的enumerable、configurable、writable，但可以修改已有属性的value 1Object.seal(object) （9）Object.isSealed() 判断一个对象是否是密封的 1Object.isSealed(object) （10）Object.freeze() 冻结一个对象，比seal更严格，连value都不能修改 1Object.freeze(object) （11）Object.isFrozen() 判断一个对象是否冻结 1Object.isFrozen(object) （12）Object.preventExtensions() 让一个对象变成不可扩展的，也就是永远不能再添加新的属性 1Object.preventExtensions(object) （13）Object.isExtrensible() 判断一个对象是否是可扩展的 1Object.isExtrensible(object) （14）prototype.isPrototypeOf(object) 确定一个对象是否存在于另一个对象的原型链中 1234function Rectangle() {}var rec = new Rectangle();document.write(Rectangle.prototype.isPrototypeOf(rec)); （15）object.propertyIsEnumerable(propertyName) 确定指定的属性是否可枚举 1234var a = {};a.b = 3;console.log(a.propertyIsEnumerable(&apos;b&apos;));// 输出是true ####2.2.3 Array新增方法 （1）Array.isArray() 用于确定传递的值是否是一个 Array 12Array.isArray([1, 2, 3]); // true （2）Array.prototype.every(callback[, thisArg]) 测试数组的所有元素是否都通过了指定函数的测试。callback：用来测试数组的每个元素的函数。调用时使用参数 (element, index, array)。返回true表示保留该元素（通过测试），false则不保留thisArg：可选。执行 callback 时的用于 this 的值。 1234567function isBigEnough(element, index, array) { return (element &gt;= 10);}var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true （3）Array.prototype.filter(callback[, thisArg]) 创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。即是过滤函数。 123456var a = [1, 2, 3];var b = a.filter(function(element) { return element &gt; 2;});console.log(b);//输出 [3] （4）Array.prototype.forEach(callback[, thisArg]) 对数组的每个元素执行一次提供的函数。 1234const arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];arr.forEach(function(element) { console.log(element);}); （5）Array.prototype.indexOf(searchElement, fromIndex) 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1 12let a = [2, 9, 7, 8, 9]; a.indexOf(2); // 0 （6）Array.prototype.lastIndexOf() 返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。 123var array = [2, 5, 9, 2];var index = array.lastIndexOf(2);// index is 3 （7）Array.prototype.map() 创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 123var numbers = [1, 4, 9];var roots = numbers.map(Math.sqrt);// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9] （8）Array.prototype.reduce() 从左到右为数组中的每一个元素依次执行callback函数，返回累计处理的结果。 1234var total = [0, 1, 2, 3].reduce(function(sum, value) { return sum + value;}, 0);// total is 6 （9）Array.prototype.reduceRight() 与Array.prototype.reduce() 的执行方向相反。（10）Array.prototype.some() 测试数组中的某些元素是否通过由提供的函数实现的测试。every()是全部元素满足条件，some()只要任意一个元素满足条件。 ####2.2.4 String新增方法 （1）String.prototype.trim() 会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 12var orig = &apos; foo &apos;;console.log(orig.trim()); // &apos;foo&apos; ####2.2.5 Date新增方法 （1）Date.now() 返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。 ####2.2.6 JSON对象 （1）JSON.parse() 用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。 1234let a = &apos;{&quot;b&quot;: 3}&apos;;let c = JSON.parse(a);console.log(c);// {b: 3} （2）JSON.stringify() 将一个JavaScript值(对象或者数组)转换为一个 JSON字符串。 1234let dd = {bb: 3};let cc = JSON.stringify(dd);console.log(cc);// &apos;{&quot;bb&quot;:3}&apos; 上述就是ES5的主要新特性概括，下面我们再看看ES6有哪些新特性。 ##3. ES6（ES2015）的简要说明 ES6各个特性的支持情况比较细，可根据具体特性查询caniuse ###3.1 ES6新特性 参考文档：http://es6.ruanyifeng.com/#docs/intro（ECMAScript 6 入门）下面简单说一些比较常见的ES6用法（1）let 用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。实际上为 JavaScript 新增了块级作用域。 123456{ let a = 10; var b = 1;}a; // ReferenceError: a is not defined.b; // 1 （2）const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. （3）数组的解构赋值 12let [a, b, c] = [1, 2, 3];// let a=1,b=2,c=3; （4）对象的解构赋值 123let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };foo // &quot;aaa&quot;bar // &quot;bbb&quot; （5）箭头函数 =&gt; 1var f = v =&gt; v; 等效于 123var f = function(v) { return v;}; （6）Promise对象是异步编程的一种解决方案。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。基本用法是，创建一个Promise实例， 123456789const promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); }}); Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function(value) { // success}, function(error) { // failure}); （7）Class语法：包括constructor，get，set等经典函数方法。（8）Module语法：包括import，export等经典模块引入和导出写法。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/ES5，ES6的简要说明及浏览器支持性总结.html"},{"title":"Gerrit常见命令及最佳实践","text":"本文记录了笔者在使用Gerrit（一种免费、开放源代码的代码审查软件）过程中的一些微小的经验，在这里做个简单的分享。 克隆工程1git clone ssh://tusi@xx.xx.cn:29428/project-name 如果使用了Git代理，请将xx.xx.cn:29428换成代理后的ip:port 1git clone ssh://tusi@ip:port/project-name 创建develop分支一般我们不会将代码直接提交到master分支，而是会选择在develop分支进行开发 1git checkout -b develop origin/develop 添加到暂存区修改代码后，将所修改的代码从工作区添加到暂存区 1234// 添加所有文件到暂存区git add .// 添加某目录或文件到暂存区git add src 提交暂存区改动将暂存区内容提交到版本库 1git commit -m '测试commit' 推送到远程分支1git push origin HEAD:refs/for/develop 常见报错missing Change-Id in commit message footer先执行这两条命令，命令中的信息改成自己的 12gitdir=$(git rev-parse --git-dir); scp -p -P 80 tusi@ip:hooks/commit-msg ${gitdir}/hooks/git commit --amend 再次push Gerrit merge conflict 在Gerrit上abandon这次push 软回滚 1git reset --soft origin/master pull代码 1git pull 再次commit, push 最佳实践git status检查仓库状态一个很好的习惯，add, commit, push等操作前后都可以用git status检查下，有助于理解Git的原理。 1git status hotfix合入master12git merge origin/hotfix/20190909git push origin HEAD:refs/for/master 强制与远程分支同步慎重操作！！！会覆盖掉本地代码！ 1git reset --hard origin/develop git add 后想撤销不小心添加了文件到暂存区？使用以下命令： 1git checkout -- src/main.js git commit 后想回退1234// 不小心commit了1次git reset --soft HEAD^// 不小心commit了2次git reset --soft HEAD~2 紧急bug来了，临时保存feature代码 先保存代码 1git stash 检查确认下 1git stash list 切换分支去修复bug 修复完毕，切回feature分支，释出stash代码接着干 1git stash pop 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/Gerrit常见命令及最佳实践.html"},{"title":"Git多个远程仓库不同步时的补救办法","text":"git本地仓库是可以与多个远程仓库关联的，如果想知道怎么配置，请参考Git如何使用多个托管平台管理代码 。 当git remote关联了多个远程仓库时，总会遇到一些问题。今天就遇到了两个远程仓库不一致导致无法push的情况。 远程仓库间出现差异大概情况是这样的，我是一个本地仓库关联了github和gitee两个远程仓库。 12git remote add all git@github.com:cumt-robin/BlogFrontEnd.gitgit remote set-url --add all git@gitee.com:tusi/BlogFrontEnd.git 由于不小心在远程仓库gitee上手动修改了README.md文件，导致两个远程仓库出现了差异。所以当我在本地完成了一部分功能，准备提交到远程仓库时，出现了报错。 12345678910$ git push all --allEverything up-to-dateTo gitee.com:tusi/BlogFrontEnd.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 'git@gitee.com:tusi/BlogFrontEnd.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 解决方案由于是gitee的仓库多修改了一点东西，因此在本地再加一个remote，单独关联gitee。 1$ git remote add gitee git@gitee.com:tusi/BlogFrontEnd.git 将gitee的代码拉到本地master。 12345678910$ git pull gitee masterremote: Enumerating objects: 1, done.remote: Counting objects: 100% (1/1), done.remote: Total 1 (delta 0), reused 0 (delta 0)Unpacking objects: 100% (1/1), done.From gitee.com:tusi/BlogFrontEnd * branch master -&gt; FETCH_HEAD * [new branch] master -&gt; gitee/masterAlready up to date!Merge made by the 'recursive' strategy. 再将本地master推送到远程all。 123456789101112131415161718$ git push all --allEnumerating objects: 2, done.Counting objects: 100% (2/2), done.Delta compression using up to 6 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 499 bytes | 499.00 KiB/s, done.Total 2 (delta 0), reused 0 (delta 0)To github.com:cumt-robin/BlogFrontEnd.git 1557ece..8391333 master -&gt; masterEnumerating objects: 2, done.Counting objects: 100% (2/2), done.Delta compression using up to 6 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 917 bytes | 917.00 KiB/s, done.Total 2 (delta 0), reused 0 (delta 0)remote: Powered By Gitee.comTo gitee.com:tusi/BlogFrontEnd.git 8912ff5..8391333 master -&gt; master 问题得以解决！ 首发连接","link":"/Git多个远程仓库不同步时的补救办法.html"},{"title":"让Nodejs支持HTML5 History模式","text":"导读本文主要是对connect-history-api-fallback库进行一次源码分析。connect-history-api-fallback是一个用于支持SPA History路由模式的nodejs库。阅读本文前，应对HTML5 History模式有一定程度的了解！ 源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164/** * 前端需要开启history模式，而后端根据url并不知道前端在请求api还是在请求页面，如localhost:4200/home这种url，前端理所当然认为“我需要得到html，并跳转到首页”，然而后端并不能区分。 * 因此需要一种判断机制，来使得后端能分析出前端的请求目的。 * connect-history-api-fallback 这个中间件正好帮我们完成了上述分析操作，来看下它是怎么实现的吧！ * 第一次把自己的源码分析思路写出来，说得不对的地方，请指出！ */'use strict';var url = require('url');exports = module.exports = function historyApiFallback(options) { // 接收配置参数 options = options || {}; // 初始化日志管理器 var logger = getLogger(options); // 中间件是要返回一个函数的，函数形参有req, res, next return function(req, res, next) { var headers = req.headers; if (req.method !== 'GET') { // 如果请求方法不是GET类型，说明不需要返回html，那么就调用next()，把请求交给下一个中间件 logger( 'Not rewriting', req.method, req.url, 'because the method is not GET.' ); return next(); } else if (!headers || typeof headers.accept !== 'string') { // 如果没有请求头，或者请求头中的accept不是字符串，说明不是一个标准的http请求，也不予处理，把请求交给下一个中间件 logger( 'Not rewriting', req.method, req.url, 'because the client did not send an HTTP accept header.' ); return next(); } else if (headers.accept.indexOf('application/json') === 0) { // 如果客户端希望得到application/json类型的响应，说明也不是在请求html，也不予处理，把请求交给下一个中间件 logger( 'Not rewriting', req.method, req.url, 'because the client prefers JSON.' ); return next(); } else if (!acceptsHtml(headers.accept, options)) { // 如果请求头中不包含配置的Accept或者默认的['text/html', '*/*']，那么说明也不是在请求html，也不予处理，把请求交给下一个中间件 logger( 'Not rewriting', req.method, req.url, 'because the client does not accept HTML.' ); return next(); } // 走到这里说明是在请求html了，要开始秀操作了 // 首先利用url模块的parse方法解析下url，会得到一个对象，包括protocol，hash，path, pathname, query, search等字段，类似浏览器的location对象 var parsedUrl = url.parse(req.url); var rewriteTarget; // 然后得到配置中的rewrites，也就是重定向配置； // 重定向配置是一个数组，每一项都包含from和to两个属性； // from是用来正则匹配pathname是否需要重定向的; // to则是重定向的url，to可以是一个字符串，也可以是一个回调方法来返回一个字符串，回调函数接收一个上下文参数context，context包含三个属性（parsedUrl，match，request） options.rewrites = options.rewrites || []; // 遍历一波重定向配置 for (var i = 0; i &lt; options.rewrites.length; i++) { var rewrite = options.rewrites[i]; // 利用字符串的match方法去匹配 var match = parsedUrl.pathname.match(rewrite.from); if (match !== null) { // 如果match不是null，说明pathname和重定向配置匹配上了 rewriteTarget = evaluateRewriteRule(parsedUrl, match, rewrite.to, req); if(rewriteTarget.charAt(0) !== '/') { // 推荐使用/开头的绝对路径作为重定向url logger( 'We recommend using an absolute path for the rewrite target.', 'Received a non-absolute rewrite target', rewriteTarget, 'for URL', req.url ); } logger('Rewriting', req.method, req.url, 'to', rewriteTarget); // 进行重定向url操作 req.url = rewriteTarget; return next(); } } var pathname = parsedUrl.pathname; // 首先说明一下：校验逻辑默认是会去检查url中最后的.号的，有.号的说明在请求文件，那就跟history模式就没什么鸟关系了 // 我暂且将上述规则成为“点号校验规则” // disableDotRule为true，代表禁用点号校验规则 if (pathname.lastIndexOf('.') &gt; pathname.lastIndexOf('/') &amp;&amp; options.disableDotRule !== true) { // 如果pathname的最后一个/之后还有.，说明请求的是/a/b/c/d.*的文件（*代表任意文件类型）; // 如果此时配置disableDotRule为false，说明开启点号校验规则，那么不予处理，交给其他中间件 logger( 'Not rewriting', req.method, req.url, 'because the path includes a dot (.) character.' ); return next(); } // 如果pathname最后一个/之后没有.，或者disableDotRule为true，都会走到最后一步：重写url // 重写url有默认值/index.html，也可以通过配置中的index自定义 rewriteTarget = options.index || '/index.html'; logger('Rewriting', req.method, req.url, 'to', rewriteTarget); // 重写url req.url = rewriteTarget; // 此时再将执行权交给下一个中间件（url都换成index.html了，后面的路由等中间件也不会再处理了，然后前端接收到html就开始解析路由了，目的达到！） next(); };};// 判断重定向配置中的tofunction evaluateRewriteRule(parsedUrl, match, rule, req) { if (typeof rule === 'string') { // 如果是字符串，直接返回 return rule; } else if (typeof rule !== 'function') { // 如果不是函数，抛出错误 throw new Error('Rewrite rule can only be of type string or function.'); } // 执行自定义的回调函数，得到一个重定向的url return rule({ parsedUrl: parsedUrl, match: match, request: req });}// 判断请求头的accept是不是包含在配置数组或默认数组的范围内function acceptsHtml(header, options) { options.htmlAcceptHeaders = options.htmlAcceptHeaders || ['text/html', '*/*']; for (var i = 0; i &lt; options.htmlAcceptHeaders.length; i++) { if (header.indexOf(options.htmlAcceptHeaders[i]) !== -1) { return true; } } return false;}// 处理日志function getLogger(options) { if (options &amp;&amp; options.logger) { // 如果有指定的日志方法，则使用指定的日志方法 return options.logger; } else if (options &amp;&amp; options.verbose) { // 否则，如果配置了verbose，默认使用console.log作为日志方法 return console.log.bind(console); } // 否则就没有日志方法，就不记录日志咯 return function(){};} 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/History模式（connect-history-api-fallback源码分析）.html"},{"title":"Nodejs开发微信公众号--测试号配置篇","text":"微信公众号感觉入门是真的难啊，受权限的约束，个人开发者真的挺难走的，特别像博主这种主攻前端的人。由于迟迟没把域名备案办下来。先从测试号入手。 申请页面信息打开测试号申请页面，可以看到需要填写的内容。 首先要做的就是接口配置信息这部分内容了。 内网穿透一般我们会在本地进行开发，因此必须使用工具进行内网穿透，将一个公网域名穿透到本地内网。用NATAPP可以做到。使用方法很简单，这里不再赘述。 NodeJS服务器搭建我这边使用express生成器搭建服务。 12345678910// 全局安装生成器npm install express-generator -g// 生成项目，并指定模板引擎express --view=ejs wechat_expresscd wechat_express// 安装node依赖npm install// 启动set DEBUG=myapp:* &amp; npm start 新建一个配置文件config/index.js 12345const CONFIG = { port: &apos;4300&apos;, token: &apos;你的token&apos;}exports.CONFIG = CONFIG; 在app.js中指定端口 1app.set(&apos;port&apos;, config.port); 写路由，进行微信公众号的token验证 12345678910111213141516171819202122232425262728293031var express = require(&apos;express&apos;);var crypto = require(&apos;crypto&apos;);var config = require(&apos;../config/index&apos;).CONFIG;var router = express.Router();router.get(&apos;/&apos;,function(req,res){ console.log(req) //1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr var signature = req.query.signature,//微信加密签名 timestamp = req.query.timestamp,//时间戳 nonce = req.query.nonce,//随机数 echostr = req.query.echostr;//随机字符串 //2.将token、timestamp、nonce三个参数进行字典序排序 var array = [config.token,timestamp,nonce]; array.sort(); //3.将三个参数字符串拼接成一个字符串进行sha1加密 var tempStr = array.join(&apos;&apos;); const hashCode = crypto.createHash(&apos;sha1&apos;); //创建加密类型 var resultCode = hashCode.update(tempStr,&apos;utf8&apos;).digest(&apos;hex&apos;); //对传入的字符串进行加密 //4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 if(resultCode === signature){ res.send(echostr); }else{ res.send(&apos;mismatch&apos;); }});module.exports = router; 启动服务，并在测试号申请页面，填入URL和Token进行验证。验证成功后便可以继续下一步了。 JS接口安全域名暂时还未用到，填写URL所在域名即可。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/Nodejs开发微信公众号-测试号配置篇.html"},{"title":"Nodejs开发微信公众号--获取access_token","text":"为了梳理代码，我单独给微信的接口进行了一些封装。 这是前面认证接口的内容。 封装接口用到了request 1npm install --save request 封装的 js 结构大致是这样的 12345678910111213141516171819202122232425262728293031323334var request = require(&apos;request&apos;);var crypto = require(&apos;crypto&apos;);function WeChat(config) { this.config = config this.accessToken = null this.getAccessTokenTimer = null}WeChat.prototype.Authenticate = function(req, res) { //1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr var signature = req.query.signature,//微信加密签名 timestamp = req.query.timestamp,//时间戳 nonce = req.query.nonce,//随机数 echostr = req.query.echostr;//随机字符串 //2.将token、timestamp、nonce三个参数进行字典序排序 var array = [this.config.token,timestamp,nonce]; array.sort(); //3.将三个参数字符串拼接成一个字符串进行sha1加密 var tempStr = array.join(&apos;&apos;); const hashCode = crypto.createHash(&apos;sha1&apos;); //创建加密类型 var resultCode = hashCode.update(tempStr,&apos;utf8&apos;).digest(&apos;hex&apos;); //对传入的字符串进行加密 //4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 if(resultCode === signature){ res.send(echostr); }else{ res.send(&apos;mismatch&apos;); }}module.exports.WeChat = WeChat; 扯多了，回到正题access_token access_token是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用access_token。开发者需要进行妥善保存。access_token的存储至少要保留512个字符空间。access_token的有效期目前为2个小时，需定时刷新，重复获取将导致上次获取的access_token失效。 因此，我继续封装了GetAccessToken方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344WeChat.prototype.GetAccessToken = function() { var self = this let option = { url: &apos;https://api.weixin.qq.com/cgi-bin/token&apos;, qs: { grant_type: &apos;client_credential&apos;, appid: this.config.App_Id, secret: this.config.App_Secret }, method: &apos;GET&apos;, headers: { &quot;content-type&quot;: &quot;application/json&quot; } } return new Promise((resolve, reject) =&gt; { request(option, function(error, response, body) { console.log(error, body) var data = JSON.parse(body) if (error) { reject(error) } else { switch(data.errcode) { case 45009: console.log(&apos;token调用上限&apos;) reject(data) break case 0: self.accessToken = { access_token: data.access_token, expires_in: data.expires_in } console.log(&apos;当前access_token&apos;, JSON.stringify(self.accessToken)) // 定时重新获取access_token clearTimeout(this.getAccessTokenTimer) this.getAccessTokenTimer = setTimeout(() =&gt; { self.GetAccessToken() }, (data.expires_in - 60) * 1000 || 60000) resolve(data) break } } }) })} 并在express服务启动的时候调用GetAccessToken，调用成功后会依据 expires_in 起定时器重新获取。 123456var wechat = new WeChat(config)wechat.GetAccessToken().then(success =&gt; { console.log(&apos;初始化获取accessToken成功&apos;)}, failure =&gt; { console.log(&apos;初始化获取accessToken失败&apos;)}) 2018.10.17考虑到每次重启服务器都会调用GetAccessToken，会导致频繁调用。因此想到一个修改方法，将accessToken作为属性存在wechat对象中的同时，还将其写入到本地文件token.json中。这样服务器重启时，就可以先读取token.json文件中的access_token及expires_in，先判断是否过期，如果过期了，则直接进行access_token更新操作，否则计算出过期时间，用定时器控制在过期时间时进行access_token更新操作。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/Nodejs开发微信公众号-获取access-token.html"},{"title":"PC截图时，怎么截住右键菜单？","text":"我昨天在写博客时，想要将右键菜单的图给截下来保存。于是乎，截图快捷键走起来。 1Ctrl + Alt + A 但是却发现利用QQ的截图快捷键竟然做不到，一按快捷键右键菜单就收起来了。多次尝试不果，所以就百度一下解决方案，当然很快就找到了答案。于是也写下来做下记录，希望能给还不知道的同学一点点帮助^_^。 方法就是： 右键呼出菜单，然后鼠标移动到某选项上，按住鼠标左键不动，然后再按截图的快捷键，这样就可以截图到右键菜单了。 快试一下吧！！！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/PC截图时，怎么截住右键菜单？.html"},{"title":"TortoiseGIT安装教程","text":"不知道各位有没有这种感觉，就我一个小白来讲，不管是写一个demo也好，亦或是准备搞一个自己的小项目来说，代码管理真的是太重要了。每当自己写得代码有问题想要回退时，或者某刻想要找到之前的代码记录时，我发觉自己真的需要一个代码管理工具了。 明确自己的需求现在的代码管理工具，主流无非是SVN（集中式）或者GIT（分布式）。从形式上来看，要么是命令行工具，要么是GUI工具。很多人在这里可能就迷茫了，选哪个？就我而言，我需要一个简单的，不需要特别深入学习原理，可视化的东西。所以我选择了TortoiseGIT。 下载安装https://tortoisegit.org/download/这个是下载的链接，根据自己的电脑情况来选择。我的电脑是64位，所以直接点64位下载了。 下载完成就接着安装了，前两步直接选next就行了。 接下来这个选择第一项就好，从字面意思看，它是针对windows做了优化了，所以没什么问题。 然后就是选择安装的位置了，这个看个人喜好，我习惯选D盘。 然后就下一步，安装。接着会打开配置向导，选择生成putty秘钥。生成过程需要移动鼠标。 把生成的私钥存储在计算机上，然后把公钥保存在GitHub的SSH keys中 生成了公钥和私钥后，还有一件事，就是加载private key 的key文件。在安装目录中找到pageant.ext，打开然后添加私钥。 然后通过setting是可以配置很多东西的，包括右键菜单，语言，等等。 如果遇到右键没有菜单的问题，那么请重启一下，应该就解决了吧！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/TortoiseGIT安装教程.html"},{"title":"VMware安装CentOS7时遇到的黑屏问题解决方法","text":"问题背景上大学时一度以为自己不会跟linux搭上关系，然而走到部署服务器这一步还是离不开linux。默默开始学习linux吧。装好虚拟机准备开始安装CentOS7时，发现自己刚入坑就被难住了。点击安装直接黑屏。。。 解决方案在网上查阅后发现，有人遇到了和我一样的问题。原因是BIOS的Virtualization Technology设置被禁止了，需要进入BIOS将其设置为Enabled。（不同电脑进入BIOS的方法不尽相同，请网上查阅对应电脑型号的进入BIOS的方法，我的是Fn+F1） 设置成功后重启，再打开VMware安装CentOS7就可以顺利安装了。 看到这个界面后，感觉整个人都舒服了！^_^ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/VMware安装CentOS7时遇到的黑屏问题解决方法.html"},{"title":"VSCode缩进方式转换","text":"首先要明确的是，一般我们推荐的是采用空格进行缩进，因为tab不是一个标准的东西，如果使用tab缩进，可能在不同的系统中表现有差异。我个人还是喜欢4空格缩进，所以对于某些2空格缩进的代码，我还是有必要去做下转换的。下面以2空格缩进转4空格缩进为例进行说明。 2空格缩进转4空格缩进方法第一步，查看并确认下我们当前的缩进方式。 可以看到，是以2空格作为缩进。 接着，我们把缩进转换为tab。 然后，我们再设置以tab为缩进方式，并指定数值为4（代表1个tab表现为4个空格，但它毕竟还是tab，不是标准的空格）。 最后我们把缩进转为空格，这样2空格就变为4空格了。 同理，4空格变为2空格也是类似的。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/VSCode缩进方式转换.html"},{"title":"WebSocket实现实时通讯（socket.io实现简版聊天室）","text":"最近一段时间了接触了一些websocket编程。这里记录一个简单的入门demo。该demo利用socket.io实现了一个简单的聊天应用。各位看官老爷，且接着看具体的实现方式。 准备工作本人主要是前端开发，会一点点nodejs。因此这个demo是基于socket.io.js实现的。 B/S服务端首先，我们在服务端安装socket.io 1npm install --save socket.io B/S客户端接着，在vue项目中安装socket.io-client 1npm install --save socket.io-client 思路聊天室最基本的功能应该有系统通知，聊天内容等。系统通知针对所有socket连接，即是全局广播；聊天内容则是除当前socket用户的非全局广播。还可能存在系统与某个用户的单独消息互动，这则是单播。本文先不涉及room的概念，高手莫怪。 实现方式socket服务端主要代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var http = require(&apos;http&apos;);var express = require(&apos;express&apos;);var app = express();var server = http.createServer(app)var io = require(&apos;socket.io&apos;)(server);server.listen(app.get(&apos;port&apos;), function() { console.log(&apos;Express server listening on port &apos; + app.get(&apos;port&apos;));});// 监听socket连接io.on(&apos;connection&apos;, function (socket) { // 当某用户连上聊天室socket服务时，给他打个招呼 sendToSingle(socket, { event: &apos;greet_from_server&apos;, data: `你好${socket.id}` }) // 对其他用户给出通知：某某某加入了聊天室 broadcastExceptSelf(socket, { event: &apos;new_user_join&apos;, data: { user: socket.id } }) // 监听用户发的聊天内容 socket.on(&apos;chat&apos;, function (data) { // 然后广播给其他用户：某某某说了什么 broadcastExceptSelf(socket, { event: &apos;new_chat_content&apos;, data: { user: socket.id, content: data } }) }); // 监听socket连接断开 socket.on(&apos;disconnect&apos;, (reason) =&gt; { // 广播给其他用户：某某某退出了聊天室 broadcastExceptSelf(socket, { event: &apos;someone_exit&apos;, data: { user: socket.id } }) });});// 给当前socket连接单独发消息function sendToSingle(socket, param) { socket.emit(&apos;singleMsg&apos;, param);}// 对所有socket连接发消息function broadcastAll(param) { io.emit(&apos;broadcastAll&apos;, param)}// 对除当前socket连接的其他所有socket连接发消息function broadcastExceptSelf(socket, param) { socket.broadcast.emit(&apos;broadcast&apos;, param);} socket客户端实现方式也比较简单 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import io from &apos;socket.io-client&apos;;// 创建和管理socketcreateSocket() { let self = this this.socket = io(this.$store.state.config.API_ROOT); this.socket.on(&apos;connect&apos;, function(){ console.log(&apos;连上了&apos;) }); // 这里接收服务端发来的单独消息 this.socket.on(&apos;singleMsg&apos;, function(msg){ console.log(msg) switch (msg.event) { // 如来自服务端的问候，虽然这里没写什么，但是可以据此做一些页面上的效果 case &apos;greet_from_server&apos;: break default: break } }) // 目前还没用到，可拓展 this.socket.on(&apos;broadcastAll&apos;, function(msg){ console.log(msg) }) // 监听广播 this.socket.on(&apos;broadcast&apos;, function(msg){ console.log(msg) switch (msg.event) { // 新用户加入聊天室 case &apos;new_user_join&apos;: self.msgList.push({ time: new Date().toLocaleString(), user: &apos;系统通知&apos;, content: `用户 ${msg.data.user} 加入了聊天室......` }) break // 用户退出聊天室 case &apos;someone_exit&apos;: self.msgList.push({ time: new Date().toLocaleString(), user: &apos;系统通知&apos;, content: `用户 ${msg.data.user} 退出了聊天室......` }) break // 接收某用户的聊天内容 case &apos;new_chat_content&apos;: self.msgList.push({ time: new Date().toLocaleString(), user: msg.data.user, content: msg.data.content }) break default: break } }) this.socket.on(&apos;disconnect&apos;, function(){ console.log(&apos;连接断开了&apos;) });},// 监听输入框回车事件onInpuKeyDown(e) { console.log(e) if (e.keyCode == 13) { // 将输入的聊天内容推送给服务端 this.socket.emit(&apos;chat&apos;, e.target.value) this.msgList.push({ time: new Date().toLocaleString(), user: &apos;我说&apos;, content: e.target.value }) this.newMsg = &apos;&apos; }} 我们用打开多个窗口的方式模拟多个用户的加入，我这里开了三个窗口，最后的效果大概是这样的。 用户1看到用户2和用户3谈到了很晚的事情 切到了当前用户2的界面 切到了当前用户3的界面 用户3退出了聊天室，在用户2的界面上可以看到推送的系统通知，然后用户2说了一句话也退出了 用户1看到用户2和用户3的退出情况 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/WebSocket实现实时通讯（socket-io实现简版聊天室）.html"},{"title":"cordova开发环境搭建","text":"最近我在尝试了解跨平台技术的发展，首先则是想到了cordova。本文简单记录下cordova环境搭建的过程。 安装cordova首先是要npm全局安装cordova 1npm install -g cordova 创建应用安装的cordova类似于create-react-app这种脚手架，可以通过命令行直接创建应用 1cordova create myapp 添加平台支持cordova可以支持ios, android, web三端。 123cordova platform add ioscordova platform add androidcordova platform add browser 进入android目录下，可以看到很多.java文件，而ios目录下是很多的object-c文件，browser目录下则是熟悉的web工程。 并且可以看到，每个平台下都有一个cordova目录，我初步猜想，这应该是负责和不同平台通讯交互的cordova核心。 运行AppWebweb端是最直观最简单的，直接运行如下命令即可。 1cordova run browser Android对于Android和IOS，我们则需要先检查相关环境是否安装正常。 12345678910111213141516171819202122$ cordova requirementsRequirements check results for android:Java JDK: installed 1.8.0Android SDK: not installedFailed to find 'ANDROID_HOME' environment variable. Try setting it manually.Detected 'adb' command at C:\\Windows\\system32 but no 'platform-tools' directory found near.Try reinstall Android SDK or update your PATH to include valid path to SDK\\platform-tools directory.Android target: not installedandroid: Command failed with exit code ENOENT Error output:'android' �����ڲ����ⲿ���Ҳ���ǿ����еĳ������������ļ���Gradle: not installedCould not find gradle wrapper within Android SDK. Could not find Android SDK directory.Might need to install Android SDK or set up 'ANDROID_HOME' env variable.Requirements check results for browser:Requirements check results for ios:Apple macOS: not installedCordova tooling for iOS requires Apple macOSSome of requirements check failed 可以看到，我的电脑环境并不满足android和ios平台的要求。 首先我们来满足下android平台的环境要求。 JDK首先是JDK，可以通过java和javac命令来检查下。 1234C:\\&gt;java -versionjava version \"1.8.0_201\"Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) 如果没安装，可以参考jdk下载与安装简明教程。 Gradle Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。 具体安装过程可以参考gradle环境搭建。 Android SDK首先我们安装Android Studio。根据安装指引，我们会安装好Android SDK。 在此安装过程中，遇到了一个报错： 1Android SDK Tools, SDK Patch Applier v4 and 5 more SDK components were not installed 感谢这位大佬提供的解决方案，迅速解决了问题，这里顺便记下SDK的安装目录。 1C:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk 接着我们需要在环境变量-系统变量-Path中新增两项： 12C:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk\\platform-toolsC:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk\\tools 并且新增一项系统变量ANDROID_HOME，变量值为： 1C:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk 试运行命令cordova run android，出现了如下警告 12345$ cordova run androidChecking Java JDK and Android SDK versionsANDROID_SDK_ROOT=undefined (recommended setting)ANDROID_HOME=C:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk (DEPRECATED)Starting a Gradle Daemon (subsequent builds will be faster) 于是我又新增了一项系统变量ANDROID_SDK_ROOT，变量值与ANDROID_HOME一样。 重新跑cordova run android命令，首先看到警告如下： 123&gt; Configure project :appChecking the license for package Android SDK Platform 28 in C:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk\\licensesWarning: License for package Android SDK Platform 28 not accepted. 上网一查，原来是没有同意相关协议。我们来到C:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk\\tools\\bin目录下运行命令行，输入sdkmanager --licenses，然后就会弹出一堆协议，没办法，无脑输入y同意吧。 再次运行cordova run android，发现了新的报错信息： 12345No target specified and no devices found, deploying to emulatorNo emulator images (avds) found.1. Download desired System Image by running: &quot;C:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk\\tools\\android.bat&quot; sdk2. Create an AVD by running: &quot;C:\\Users\\Jiang.Wenbin\\AppData\\Local\\Android\\Sdk\\tools\\android.bat&quot; avdHINT: For a faster emulator, use an Intel System Image and install the HAXM device driver 可以看到，是没有找到设备的原因。需要将手机连接到PC，并且打开开发者选项，允许USB调试。再次尝试，已经可以看到界面了。 Plugins我们来试试调用一些原生API，比如调用原生Dialog， 调用相机等。我们先试下Dialog。 Dialog首先需要插件： 1cordova plugin add cordova-plugin-dialogs 接着我们在deviceready事件之后调用Dialog 1234567891011121314document.addEventListener('deviceready', onDeviceReady, false);function onDeviceReady() { navigator.notification.alert( '欢迎欢迎!', // message alertDismissed, // callback '试下Dialog', // title '好的' // buttonName );}function alertDismissed() { // 点击按钮后的回调} 调试后发现弹出的中文乱码了，需要在index.html加个meta 1&lt;meta charset=\"UTF-8\"&gt; Camera接着我们试下调用相机，首先也是安装插件： 1cordova plugin add cordova-plugin-camera 尝试调用相机拍照，并将得到的照片通过img元素显示出来： 12345678910111213141516171819202122232425262728293031323334// Application Constructorinitialize: function() { const _this = this; document.addEventListener('deviceready', this.onDeviceReady.bind(this), false); // 点击按钮打开相机 document.querySelector('#btnOpenCamera').addEventListener('click', function() { _this.openCamera() })},openCamera: function() { const cameraOptions = { // 默认输出格式为base64 destinationType: Camera.DestinationType.DATA_URL, // 输出png格式 encodingType: Camera.EncodingType.PNG }; navigator.camera.getPicture(cameraSuccess, cameraError, cameraOptions); // 相机拍照成功 function cameraSuccess(base64Str) { console.log(base64Str) // 给图片元素赋值src document.querySelector('#captureImg').src = prefixBase64PNG(base64Str) } function cameraError(err) { console.error(err) } function prefixBase64PNG(base64Str) { return 'data:image/png;base64,' + base64Str; }} 效果如下： IOS还没钱买IOS设备，尴尬。。。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/cordova开发环境搭建.html"},{"title":"express搭建简单的后台服务器（入门篇）","text":"之前一段时间，工作之余我还比较闲。我就用Angular做了一个前端小demo，后台服务器就简单用express搭了一下。代码都是在公司写的，不能带回来。很久没关注，很多东西都忘记了。今天想重新温习一下，把一些重要的细节记下来。先从后台搭起。 安装express创建一个文件夹，在文件夹下运行命令行工具，先生成package.json。 1npm init 创建完毕后，安装express。 1npm install express --save 安装完，发现还是有点懵，这要从0开始写有点慢啊。还是找个脚手架吧。 安装Express 应用生成器运行这个命令装一下Express 应用生成器。 1npm install express-generator -g 然后创建一个应用，并安装依赖。 123express myappcd myappnpm install 启动express服务器运行启动命令，就可以打开localhost:3000查看效果了。 1npm start 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/express搭建简单的后台服务器（入门篇）.html"},{"title":"express搭建简单的后台服务器（基础篇）","text":"本文简单对express的一些重要基础知识做一下记录，以加深自己对express基础的了解。 不得不说的路由作为一个后台服务器，你必须要处理来自客户端的各种请求。这个时候，就要先定义各种请求的处理器，也就是路由。引用express官方的解释。 路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback…], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。 路由方法路由method有很多种，我们常见的有POST，GET两种。基本的写法如下。这里的路由地址可以是字符串，也可以是字符串模式或者正则表达式，req是请求对象，res是响应对象，next()负责将控制权交给下一个中间件。中间件的概念后面会提到。 1234567891011// GET method routeapp.get(&apos;/&apos;, function (req, res, next) { res.send(&apos;GET request to the homepage&apos;); next();});// POST method routeapp.post(&apos;/&apos;, function (req, res, next) { res.send(&apos;POST request to the homepage&apos;); next();}); 还有一种不区分请求方式的写法，不管使用 GET、POST、PUT、DELETE 或其他任何 http 模块支持的 HTTP 请求，句柄都会得到执行。 1234app.all(&apos;/secret&apos;, function (req, res, next) { console.log(&apos;Accessing the secret section ...&apos;); next(); // pass control to the next handler}); app.route()通过这个方法创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。书写格式如下： 12345678910app.route(&apos;/book&apos;) .get(function(req, res) { res.send(&apos;Get a random book&apos;); }) .post(function(req, res) { res.send(&apos;Add a book&apos;); }) .put(function(req, res) { res.send(&apos;Update the book&apos;); }); express.Router可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统。这样我们就可以在一个文件中专门做路由处理，而在app.js中use这个中间件。例如我们在一个routes.js文件中这样使用。 123456789// routes.js文件var express = require(&apos;express&apos;);var router = express.Router();// 定义网站主页的路由router.get(&apos;/&apos;, function(req, res) { res.send(&apos;home page&apos;);});// 这里把中间件导出，供app.js使用module.exports = router; app.js中这样使用： 1234567var router = require(&apos;./router&apos;);// 其他处理逻辑代码.........// 最后use路由中间件app.use(&apos;/&apos;, router); 静态文件使用静态文件服务express的静态文件可以放在public文件夹中。通过Express内置的express.static可以方便地托管静态文件，例如图片、CSS、JavaScript 文件等。 1app.use(express.static(&apos;public&apos;)); 然后就可以访问public中的静态资源了。 1http://localhost:3000/images/avatar.jpg 多个静态资源文件夹如果静态资源存放在多个目录下面，我们可以多次调用 express.static 中间件。例如： 12app.use(express.static(&apos;public&apos;));app.use(express.static(&apos;assets&apos;)); 挂在虚拟目录下1app.use(&apos;/resourse&apos;, express.static(&apos;public&apos;)); 那么访问的方式就是 1http://localhost:3000/resourse/images/avatar.jpg 中间件定义什么叫中间件，引用官方的解释就是： 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。 中间件可以做的事情（1）执行任何代码。（2）修改请求和响应对象。（3）终结请求-响应循环。（4）调用堆栈中的下一个中间件。 中间件分类应用级中间件应用级中间件绑定到app对象，使用 app.use() 和 app.METHOD()。其中METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。 1234567891011121314// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) { console.log(&apos;Time:&apos;, Date.now()); next();});// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use(&apos;/user/:id&apos;, function (req, res, next) { console.log(&apos;Request Type:&apos;, req.method); next();});// app.get// app.post// ... 路由级中间件就是上文中说到的 express.Router()，是由app.use来调用。 错误处理中间件 错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 1234app.use(function(err, req, res, next) { console.error(err.stack); res.status(500).send(&apos;Something broke!&apos;);}); 内置中间件express.static 是 Express 唯一内置的中间件。它负责在 Express 应用中托管静态资源。一般用法如下： 1app.use(express.static(path.join(__dirname, &apos;public&apos;), option)); express.static可以传option参数，option具体内容如下： 第三方中间件第三方提供的中间件，如 cookie-parser等。也是由app.use加载。 123var cookieParser = require(&apos;cookie-parser&apos;);// 加载用于解析 cookie 的中间件app.use(cookieParser()); 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/express搭建简单的后台服务器（基础篇）.html"},{"title":"gradle环境搭建","text":"最近我在尝试了解跨平台技术的发展，首先则是想到了cordova。环境配置过程中有依赖gradle，下面简单记录了在windos10系统下搭建gradle环境的过程。 什么是gradle Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。 检查java环境首先要检查是否正常安装了java环境。 1234C:\\&gt;java -versionjava version &quot;1.8.0_201&quot;Java(TM) SE Runtime Environment (build 1.8.0_201-b09)Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode) 如果没安装，可以参考jdk下载与安装简明教程。 下载gradle二进制安装包v5.6.3版本下载链接 安装和环境变量配置首先在C盘新建一个Gradle目录，然后将安装包解压到该目录下，最终得到的目录是这样的。 1C:\\Gradle\\gradle-5.6.3 然后我们需要给环境变量-系统变量-Path新增一项 1C:\\Gradle\\gradle-5.6.3\\bin 完成后，即可命令行检查下gradle是否安装配置正常。 1234567891011121314C:\\&gt;gradle -v------------------------------------------------------------Gradle 5.6.3------------------------------------------------------------Build time: 2019-10-18 00:28:36 UTCRevision: bd168bbf5d152c479186a897f2cea494b7875d13Kotlin: 1.3.41Groovy: 2.5.4Ant: Apache Ant(TM) version 1.9.14 compiled on March 12 2019JVM: 1.8.0_201 (Oracle Corporation 25.201-b09)OS: Windows 10 10.0 amd64 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/gradle环境搭建.html"},{"title":"gulp入门基础","text":"gulp是前端开发过程中经常要用到的工具，非常值得花时间去掌握。利用gulp，我们可以使产品流程脚本化，节约大量的时间，有条不紊地进行业务开发。本文简单讲一下入门gulp需要掌握的东西。 安装gulp首先，我们需要在全局安装gulp。 1npm install -g gulp 然后，我们切到项目根目录，在项目中也进行gulp的安装，表明项目对gulp的依赖。 1npm install --save-dev gulp 接着，我们在项目根目录里新建一个gulpfile.js文件，这个是gulp的配置文件。 使用gulp学习gulp的使用，我们需要先学习好常用的语法。 gulp.src(globs[, options])输出符合所匹配模式（glob）的文件。将返回一个stream，可以被piped传递到其他gulp插件中继续操作。 gulp.task(name[, deps], fn)定义一个gulp任务，name是任务名称。[, deps]是任务依赖。fn是任务回调函数。（1）任务依赖的形式可以是： 12345678gulp.task(&apos;two&apos;, [&apos;one&apos;], function() { // &apos;one&apos; 完成后});gulp.task(&apos;one&apos;, function(cb) { // cb(); // return stream; // return promise;}); 其中one应该使用一个callback，或者返回一个promise 或stream，表明依赖的任务完成了。（2）回调函数体会是这种形式： 1gulp.src().pipe(someplugin()) gulp.dest(path[, options])将pipe进来的stream输出文件到指定的路径下,如： 123gulp.src(&apos;./client/templates/*.jade&apos;) .pipe(jade()) .pipe(gulp.dest(&apos;./build/templates&apos;)) gulp.watchgulp.watch(glob [, opts], tasks)监视文件，并且在文件发生改动时候执行一个或者多个task。监听change事件实现。 1234var watcher = gulp.watch(&apos;js/**/*.js&apos;, [&apos;uglify&apos;,&apos;reload&apos;]);watcher.on(&apos;change&apos;, function(event) { console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);}); gulp.watch(glob [, opts, cb])监视文件，并且在文件发生改动时候执行回调函数cb。 123gulp.watch(&apos;js/**/*.js&apos;, function(event) { console.log(&apos;File &apos; + event.path + &apos; was &apos; + event.type + &apos;, running tasks...&apos;);}); gulp.rungulp模块的run方法，表示要执行的任务。可能会使用单个参数的形式传递多个任务。任务是尽可能多的并行执行，并且可能不会按照指定的顺序执行。当不需要指定执行顺序时，可以适当使用。 1gulp.run(&apos;task1&apos;,&apos;task2&apos;,&apos;task3&apos;); gulp使用技巧替代任务依赖写法我们需要让任务有秩序地执行，那么可以使用第三方插件gulp-sequence。 12// 如果使用gulp-sequence，就不需要附加任务依赖了。数组内的任务平行执行，数组外的按顺序执行。所以这里是svgstore、uglify-js并行执行，然后执行public任务。gulp.task(&apos;sequence1&apos;, gulpSequence([&apos;svgstore&apos;, &apos;uglify-js&apos;], &apos;public&apos;)); 修复gulp.watch方法只执行一次的问题利用gulp-watch，gulp-batch两个工具，用法如下： 123456// 当监听到svgs目录下任意svg文件变动时，执行svgstore任务gulp.task(&apos;watch&apos;, function() { watch(&apos;./assets/svgs/*.svg&apos;, batch(function(events, done) { gulp.start(&apos;svgstore&apos;, done); }));}); 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/gulp入门基础.html"},{"title":"hexo+github打造个人博客系列之Coding Pages去广告","text":"尴尬的广告大家应该可以看到，在第一次以自定义域名访问Coding Pages时，会有一个跳转广告。是不是很尴尬？经查阅官方说明，得知原因。 银牌会员的 Coding Pages 在访问时默认会先加载 Pages 跳转页，您可选择在网站首页任意位置放置「Hosted by Coding Pages」的文字版或图片版，然后勾选下方的「已放置 Hosted by Coding Pages」选项，通过审核后您的 Pages 将不会显示跳转页。请务必将「Hosted by Coding Pages」持续保留在网站首页，撤掉后跳转页会再次出现。 本来以为这个广告是去不掉了，看到这里我觉得Coding还算人性化。最多就是在首页底部声明一下「Hosted by Coding Pages」，总比每个人第一次一打开你的博客就是广告要舒服。 解决方案官方已经提供了文字或者图片两种策略。我个人偏向于加文字声明。 1&lt;p&gt;Hosted by &lt;a href=&quot;https://pages.coding.me&quot; style=&quot;font-weight: bold&quot;&gt;Coding Pages&lt;/a&gt;&lt;/p&gt; 找到footer.swig文件，将这段代码加在自己觉得合适的位置就好，保存一下，看下效果。如果正常渲染了，就部署一下，然后在Coding Pages服务中提交审核申请。 Hosted by Coding Pages 已提交审核，我们会在两个工作日内为您处理。 然后就等待审核结束就OK。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/hexo+github打造个人博客系列之Coding Pages去广告.html"},{"title":"hexo+github打造个人博客系列之Coding托管（实现github+coding双线部署）","text":"从网上搜索的结果来看，很多人都认为github博客在国内的seo情况不太好，不被百度爬虫所青睐。一个比较好的方案是，同时将hexo博客部署到github和Coding上。所以我也想试一下，顺便了解一下Coding这个代码托管平台。 注册Coding点击Coding官网，完成注册。 注册完成后，按照提示绑定一下手机和邮箱，就成为所谓的银牌会员了，会提升空间大小，方便后续使用。 创建一个项目按照下图指示，创建一个公开项目，类似于github的仓库。 设置ssh秘钥查询公钥与github是一样的，使用服务需要验证ssh秘钥。首先在计算机对应的文件夹中找到公钥。一般是这样一个目录。以前没有生成过ssh秘钥的，需要查阅一下如何生成ssh秘钥。 设置公钥将公钥的内容存储到Coding的账户中。 验证SSH服务配置完成后，验证一下是否可以ssh连接coding.net，在git bash中敲命令 1ssh -T git@git.coding.net 如果界面显示这样的信息，那么证明ssh连接是OK的。 Hexo配置然后配置hexo，在deploy字段下新增一个git仓库，repo是coding项目对应的ssh url 配置完后，运行deploy部署命令，就可以在coding仓库中看到代码了。 1hexo deploy 使用Coding Pages服务Coding也提供了类似github的Pages服务，按照流程填写一下，就可以开启Pages服务了。 启用Pages服务后，就可以通过Coding提供的二级域名访问博客页面了。但是刚启动，好像看到了很多403，404错误。扎心了老铁，还得慢慢排错啊。。。 排错查阅了各个资源文件的获取情况，发现是子目录不对造成的。 可以看到，部署在Coding该项目下的资源都是在hexo-blog子目录下的，而这里http访问的url是没有hexo-blog的。所以造成了访问403，404各种错误。那么如何解决这个问题呢？那就是将Coding pages的地址作为一个CNAME解析到我的域名下。 添加CNAME解析来到阿里云的控制台，找到域名解析。添加CNAME解析。将原来的指向github主机的A记录切换到海外线路。添加pages.coding.me的CNAME记录。 Coding Pages添加自定义域名完成上一步后，就可以在Coding Pages添加自定义域名了。 这个时候再点击自己的域名，已经是正常访问了，也没有页面错乱，报错的现象了，大功告成！ 至此，我们也完成了github+coding双线部署！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/hexo+github打造个人博客系列之Coding托管（实现github+coding双线部署）.html"},{"title":"hexo+github打造个人博客系列之主题和部署","text":"这篇文章主要记录基于hexo实现博客中一些复杂功能点的相关操作细节，为自己做一个笔记，也为后来者提供一些思路。 hexo应用主题我也不知道哪种是最好的，看大家用得比较多的就是Next，yilia，casper等。我自己选择了Next主题。Next坚持将复杂的细节隐藏，提供尽量少并且简便的设置，保持最大限度的易用性，界面上简洁大方，给我眼前一亮的感觉。 安装next主题点击Next主题中文网，克隆最新版本或者下载最新稳定版本。我选择下载了稳定版本。 在hexo中使用next主题在站点配置_config.yml中配置主题 1theme: next 保存一下，再打开localhost:4000就可以看到效果了。终于脱坑了，不再是与亿万人相同的初始化界面了。 利用hexo将博客部署到github空间上文中提到过，github为每个注册用户都提供了免费的二级域名与空间。所以我们可以轻松让博客上线。步骤也比较简单。 安装 hexo-deployer-git1npm install hexo-deployer-git --save 修改deploy配置然后在站点配置中修改deploy配置 这是我的配置，repo是对应仓库的地址，branch我是放在master分支上的。 完成部署保存后运行 123hexo cleanhexo generatehexo deploy 部署完成后，稍等片刻，然后打开对应域名，就可以访问到自己的博客了。 不知道域名的请打开仓库的设置页面，翻到下面就能看到。 好了，基本上就大功告成了。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/hexo+github打造个人博客系列之主题和部署.html"},{"title":"hexo+github打造个人博客系列之小技巧","text":"这篇博客记录一下hexo+github打造个人博客过程想到的一些小技巧，分享给大家。 去除valine的Powered Byvaline评论系统自带Powered By，如下图所示。 我喜欢简洁一点，所以想去掉这个提示。查看Elements可以看到这个div，那么我只要移除这个div下的所有子节点，就可以去掉这个Powered By了。修改对应的文件valine.swig，直接上代码： 1234567891011new Valine({...pageSize:&apos;{{ theme.valine.pageSize }}&apos; || 10,});//新增以下代码即可，可以移除.info下所有子节点。var infoEle = document.querySelector(&apos;#comments .info&apos;);if (infoEle &amp;&amp; infoEle.childNodes &amp;&amp; infoEle.childNodes.length &gt; 0){ infoEle.childNodes.forEach(function(item) { item.parentNode.removeChild(item); });} 修改后效果： 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/hexo+github打造个人博客系列之小技巧.html"},{"title":"hexo+github打造个人博客系列之数据统计与分析","text":"看到各种第三方服务，我就想折腾一下。本文简单说一下如何给自己的博客加上站点统计功能。 百度统计登录百度统计打开百度统计，输入百度账号密码即可。 添加网站来到个人中心的“管理”模块，点击“新增网站”按钮，填写博客网站的信息。 获取统计ID点击左侧菜单的“代码获取”，然后找到?后的ID（截图中被马赛克覆盖的部分），复制到粘贴板，供hexo中配置使用。每个网站对应的统计ID都不同，不要复制别人的，否则就没什么意义了。 修改主题配置将刚才复制的ID赋值给Next主题配置中的baidu_analytics字段 部署和查看数据保存修改后，再次部署博客。 1hexo deploy 然后百度统计就可以统计到你的站点信息了。 CNZZ统计注册友盟账号打开友盟注册页面。注册完毕后点击“网站统计”进入站点管理页面。 添加站点点击右侧的“添加站点”按钮，填写博客站点信息，完成添加。 获取CNZZ统计ID点击“统计代码”，可以查看到你的站点对应的统计ID。 复制这个ID，以便后面配置Hexo使用。 修改Hexo中主题配置修改next主题配置里面的cnzz_siteid字段，值为刚才复制的ID。修改完毕后，重新部署应用即可在cnzz我的站点中查看统计报表了。这里就能发现，CNZZ与百度统计是同一个套路，其他的第三方统计也是类似，不再赘述。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/hexo+github打造个人博客系列之数据统计与分析.html"},{"title":"hexo+github打造个人博客系列之评论系统","text":"一个博客怎么能没有评论互动，那也太枯燥无味了吧，简直反人类。最近也是刚学会一点皮毛，把hexo博客搭了起来。于是就想折腾一下评论系统。网上查了下现在第三方评论系统的现状：多说已经关了，网易云跟帖8月1号关闭，畅言要备案，Disqus被墙。呵呵哒，那么还剩下什么？费了一番功夫搜索了很多，选出了几款我比较满意的评论系统：来必力（LiveRe），Valine，gitment。下面详细说一下。 来必力这个怎么玩呢？首先还是注册账号。我发现hexo玩起来注册了好多账号啊！登录进去后点击右上角头像，进入个人管理页面。然后就是添加应用信息，下面是已经添加成功的页面了。 来必力还有个评论提醒的功能，人性化啊。 最关键的一步，点击“代码管理”找到uid，复制下来。 最后来到Next主题配置，修改_config.yml中的livere_uid，将复制的uid粘贴即可。然后部署一下，OK。 页面效果如下，支持多种第三方账号登录，看起来很感人。 经过测试，来必力好像不是很友好，发起评论直接报了个504错误（504错误是（网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。）。蛋疼么？我在想是不是我配置问题，于是我去到别人的hexo博客上评论，也报了同样错误，最后又试了手机，都没法评论，这还怎么玩，发到朋友圈，都没法评论，还怎么装逼？（手动滑稽）。 默默把livere_uid配置为空了。 Valine开始折腾Valine。Valine 是一款基于Leancloud的快速、简洁且高效的无后端评论系统。 注册Leancloud打开Leancloud，注册登录后，进入个人页面，创建应用，选择开发版就OK。 创建完成后，点击应用右上方的设置按钮，进入设置页面。在应用Key可以查看App ID，App Key，用于在页面上new Valine时使用。 在安全中心，填写Web安全域名，如https://cumtrobin.github.io/，防止别人盗用你的服务器资源。 在存储-数据中创建Class ‘Comment’，用作评论的数据库表。 回到Next主题配置，修改valine相关配置 部署后就可以看到效果了，评论功能终于都可以正常使用了。 gitment最后再折腾一下gitment。引用一下作者的话。 Gitment 是作者实现的一款基于 GitHub Issues 的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown / GFM 和代码高亮支持。尤为适合各种基于 GitHub Pages 的静态博客或项目页面。 注册 OAuth Application打开注册页面完成注册 配置注册成功后会得到Client ID和Client Secret，然后开始配置Next 部署部署一下就可以看到效果了。 如果想要展示多个评论系统，需要改布局，需要了解的可以留言讨论。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/hexo+github打造个人博客系列之评论系统.html"},{"title":"hexo助小白打造个人博客之入门篇","text":"我一直想拥有一个个人的技术博客，苦恼不知如何开始。作为一个小白，还是从最简单的入手为好，在多方查找资料后，决定基于github+hexo打造一个简单的个人博客。下面我简单记录下过程。 为什么选择github+hexo?github为每个注册用户都提供了免费的二级域名与空间，给博客小白提供了初期建立博客的实验环境，非常人性化。而hexo作为当前一个非常流行的博客框架，快速、简洁且高效。hexo 基于nodejs，非常适合前端开发者，很快可以入手。而且支持时下流行的 markdown（或其他渲染引擎）解析文章生成静态网页，文章编写会非常简单快速。 如何建立github blog的雏形？在github上建立一个blog仓库，仓库信息简单填写即可。 进入仓库设置页面，填写一些必要的信息。 这里把仓库名称先填一下 接下来翻到下面，选择master分支，选择一个主题来发布博客页面。然后就可以通过提供的网址来访问到自己的博客了。 如何修改我的博客页面呢？初始生成的页面是基于README.md内容的。所以你可以修改这个文件的内容来观察页面改动的效果。 想要做更复杂的页面就可以用到博客框架hexo或者官方推荐的jekyll。这里我自己选用的是hexo。 利用hexo打造更生动的博客程序下载安装hexo cli工具1npm install -g hexo-cli 安装 Hexo 完成后，执行下列命令，Hexo 会在指定文件夹中新建所需要的文件。123hexo init myblogcd myblognpm install Hexo 3.0 把服务器独立成了个别模块，必须先安装 hexo-server 才能使用。1npm install hexo-server --save 安装好服务器模块后，运行这个命令来生成静态文件。12hexo generate//或者 hexo g 运行启动服务器的命令，浏览器打开localhost:4000查看hexo博客页面效果1hexo server 好了，第一步算是大功告成了。想要做更深入的了解，请关注我的后续文章。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/hexo助小白打造个人博客之入门篇.html"},{"title":"共克时疫，https+小程序为“战疫”献上一份技术力量","text":"前言新型冠状病毒笼罩下的新年，让每个中国人都感到恐慌和揪心。我们每天为前线的白衣天使和平民英雄们的事迹感动而落泪，也为不法分子哄抬物价，无良个人以权谋私等自私自利的行为而感到痛心疾首。作为普通人，我们最大的贡献就是宅在家里，响应钟南山院士的号召，做好个人防护，不为疫情添负担，不为他人添麻烦。最近看到很多大佬都为“战疫”贡献了自己的技术力量，有的人提供了数据和接口支持，有的人做了app，有的人做了webapp。看到这些举动，我也跃跃欲试，静下心去做，总会做点东西出来，于是我做了一版微信小程序，主要是想方便自己和家人朋友们查询下最新的数据，毕竟大家都用微信。 微信小程序的版本审核实在太慢了，昨天提交版本审核的，现在还没通过，唉，心累。 数据获取和处理首先要感谢丁香园，数据源于丁香园-丁香医生。 重点要感谢掘金@普通程序员提供的数据接口能力，让我们菜鸡也有机会做一点微小的工作。 为了防止给大佬的服务器增加访问压力，我每15分钟抓取一次接口数据，存储于个人服务器上，供自己和他人访问和使用。 Q: 为什么别人有提供接口，你还要再多此一举？A：我要做小程序，没有https搞不了。 目前主要上线了以下接口： 在线接口基地址： https://wuhan.wbjiang.cn/api/ 接口名 请求方式 接口描述 timeline GET 获取发生的事件，支持分页参数pageNo和pageSize stats GET 整体统计数据 rumour GET 最新辟谣 protect_wiki GET 最新防护知识 wiki GET 最新知识百科 help_links GET 便民信息/诊疗信息 province_stats GET 全国省份级患者分布数据 city_stats/:areaName GET 根据省份查市县疫情数据，areaName传入省级行政区的简写，如“湖南” oversea_stats GET 全球海外其他地区患者分布数据 可以点击在线访问整体统计数据试试看呢！ 1https://wuhan.wbjiang.cn/api/stats 该服务的源码我也上传到了github，欢迎访问wuhan_best_wishes查看，如果能顺手给个star那是极好的，感谢感谢！ HTTPS支持由于微信小程序需要调用https协议的接口，所以我利用nginx的能力和阿里云提供的SSL证书，对上述接口提供了https支持。 服务整体框架接口服务：使用的是nodejs语言，技术框架是express。 应用管理：利用pm2来管理node应用。 代理服务器：利用Nginx监听80端口，转发到node服务所在的内部端口。 小程序概述取名挺烦的，拟的名字要么是被行业限制，要么已经有人用了。最后就随便取了个名wuhan速报。 技术方面，我暂时没有使用框架，用的是小程序原生的开发语言。为了快速出第一版效果，UI部分用到了我熟悉的vant-weapp。 相关代码已开源，请访问ncov-weapp查看源码。 先发个小程序码，方便大家直接访问小程序（暂时还没通过审核，微信小程序审核速度你懂的，如果想体验一下的话，欢迎加我微信laobaife使用体验版）。 小程序内容内容上，主要做了四个页面，分为疫情地图，辟谣与防护，事件播报，疾病知识等几块。 疫情统计数据 疫情地图与趋势 国内省市疫情分布 海外疫情分布 辟谣与防护 最新事件实时播报 疾病知识 为了快速出效果，做的时候有参考丁香园的设计，感谢丁香园技术和设计团队！ 结语由于时间有限，大概花了一天多的时间吧，所以做出来的效果是比较粗糙的。接下来我会在有余力的情况下，继续迭代更新，毕竟还是要远程办公的，大部分时间还是要聚焦于公司业务。 我是Tusi，一个创业公司前端小leader，每天依然为写不完的业务代码烦恼，在打磨产品道路上沉淀技术，探索成长路线。如果你与我一样，正在思考自己的技术成长与价值，欢迎加我微信交流探讨，微信号laobaife。我会在公众号前端司南和小程序Tusi博客同步博客内容，快来撩我！","link":"/https+小程序为战疫献上一份技术力量.html"},{"title":"ionic初体验","text":"搞了一波cordova后，算是对Hybrid有了一点点微小的认知。为了快速开发，ionic无疑是更好的选择，它底层的打包和通信机制基于cordova实现，在上层实现了自己的UI组件，可以结合Angular或React使用，并且宣称将在未来支持Vue。 环境准备如果已经安装了cordova，则单独安装ionic即可，否则需要一并安装。 1npm install -g ionic cordova 创建项目通过start命令来新建一个ionic项目。 1ionic start my-app 并且可以支持传入模板，以及项目类型，具体参考ionic start。 我们在这里创建一个基于angular的tabs导航的app。 1ionic start myapp tabs --type=ionic-angular 当然也可以直接从一个更完善的模板开始。 1ionic start myapp super --type=ionic-angular 这几种方式可以都试试看。 运行项目在浏览器运行web版在尝试npm start调用ionic-app-scripts serve启动项目时，发现报错找不到@ionic/app-scripts模块，尝试重新安装该模块，node-gyp模块又报了这个错： 1Error: Can&apos;t find Python executable &quot;python&quot;, you can set the PYTHON env variable. 查询node-gyp后，官方提供了两种解决方案 我采用了第一种方案： 1npm install --global --production windows-build-tools ps: 必须以系统管理员方式运行命令行。 接着重新安装一遍@ionic/app-scripts，然后重新运行项目，冇问题啦。 123npm uninstall @ionic/app-scriptsnpm install --save-dev @ionic/app-scriptsnpm start 支持android和ios12ionic cordova platform add iosionic cordova platform add android android调试首先检查下设备连接是否正常 123D:\\robin\\frontend\\hybrid\\ionic\\ionic-blog&gt; adb devicesList of devices attached5fdba1e7 device 使用ionic cli提供的命令运行app 12// -l是--livereload的简写ionic cordova run android -l 此时注意在手机上同意“继续安装”，否则是不会成功的。安装成功则可以看到成功的提示。 12345678910&gt; cordova.cmd build android --device[app-scripts] [16:05:33] lint finished in 3.95 s&gt; native-run.cmd android --app platforms\\android\\app\\build\\outputs\\apk\\debug\\app-debug.apk --device --forward 8100:8100 --forward 35729:35729 --forward 53703:53703[native-run] Selected hardware device 5fdba1e7[native-run] Forwarded device port 35729 to host port 35729[native-run] Forwarded device port 8100 to host port 8100[native-run] Forwarded device port 53703 to host port 53703[native-run] Installing platforms\\android\\app\\build\\outputs\\apk\\debug\\app-debug.apk...[native-run] Starting application activity io.ionic.starter/io.ionic.starter.MainActivity...[native-run] Run Successful 此时还可以在Chrome浏览器上输入chrome://inspect进行调试。 手机上的操作会同步到Chrome浏览器上。 并且还支持断点调试。 ios调试ios就先不试了，没设备。。。 首发链接 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/ionic初体验.html"},{"title":"jdk下载和安装简明教程","text":"最近搞了一下angular，打包了一个demo后，想要放在服务器上看看效果，于是我就想到了tomcat。而安装tomcat又需要依赖jre或者jdk，那么我就下载jdk安装一下吧。之前在学校也是学过java，工作后一直没怎么用，感觉忘得差不多了，这里可以简单捋一捋。 下载jdk文件首先打开jdk下载地址，选择你要下载的jdk版本，这里我选择了windows64位的jdk9版本（大家根据自己的需求来选择）。 开始安装jdk整个安装过程都是比较简单的，基本上就是下一步。 这里可以根据个人喜好选择一下安装的路径。 接下来会弹出一个jre的安装提示，直接安装即可。 配置环境变量右键点击‘计算机’，选择‘属性’，再点击‘高级系统设置’，打开‘环境变量’。 新建JAVA_HOME变量在‘系统变量’处点击‘新建’，变量名为JAVA_HOME，变量值为C:\\Program Files\\Java\\jdk-9.0.4注：这里的变量值是你安装jdk所在的目录路径。 修改Path变量修改‘Path’变量的值，观察当前值最后是否有分号；如果有，直接在后面追加%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin;如果没有，先追加一个分号; 再追加上面的值。 新建CLASSPATH变量在‘系统变量’处点击‘新建’，变量名为CLASSPATH，变量值为.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 至此，环境变量配置就完成了。下面可以进行测试，观察是否安装有效。 测试安装有效性测试java命令在任意一个目录下打开cmd命令行，输入java -version 测试javac命令在任意一个目录下打开cmd命令行，输入javac -version 能输出以上信息，基本上就表示安装成功了。那么我们就可以做后续的事情了。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/jdk下载和安装简明教程.html"},{"title":"js数据类型很简单，却也不简单","text":"最近脑子里有冒出“多看点书”的想法，但我个人不是很喜欢翻阅纸质书籍，另一方面也是因为我能抽出来看书的时间比较琐碎，所以就干脆用app看电子书了（如果有比较完整的阅读时间，还是建议看纸质书籍，排版看起来更舒服点）。考虑到平时工作遇到的大部分问题还是javascript强相关的，于是我选择从《Javascript权威指南第6版》开始。 数据类型有哪些？javascript的数据类型分为两大类，一类是原始类型(primitive type)，一类是对象类型(object type)。 原始类型原始类型又称为基本类型，分为Number, String, Boolean, Undefined, Null几类。比较特殊的是，undefined是Undefined类型中的唯一一个值；同样地，null是Null类型中的唯一一个值。 除此之外，ES6引入了一个比较特殊的原始类型Symbol，用于表示一个独一无二的值，具体使用方法可以看阮一峰老师的ECMAScript6入门，或者直接翻阅MDN，我平时看MDN比较多，感觉比较权威，API也很完善。 为什么说Symbol是原始类型，而不是对象类型呢？因为我们知道，大部分程序员都是没有对象的，那么要想找到女朋友，最快的办法就是new一个。 123456const options = { '性格': '好', '颜值': '高', '对我': '好'}const gf = new GirlFriend(options) // new一个女朋友 好了，不皮了，回到正题，意思就是，Symbol是没有构造函数constructor的，不能通过new Symbol()获得实例。 但是获取symbol类型的值是通过调用Symbol函数得到的。 1const symbol1 = Symbol('Tusi') Symbol值是唯一的，所以下面的等式是不成立的。 1Symbol(1) === Symbol(1) // false 对象类型对象类型也叫引用类型，简单地理解呢，对象就是键值对key:value的集合。常见的对象类型有Object, Array, Function, Date, RegExp等。 除了这些，Javascript还有蛮蛮多的全局对象，具体见JavaScript 标准内置对象。但是全局对象并不意味着它就是一种对象类型，就比如JSON是一个全局对象，但是它不是一种类型，这一点要搞清楚。 前面说了，对象可以new出来，所以对象类型都有构造函数，Object类型对应的构造函数是Object()，Array类型对应的构造函数是Array()，不再赘述。 123var obj = new Object() // 不过我们一般也不会这么写一个普通对象var arr1 = new Array(1) // 创建一个length是1的空数组var arr2 = new Array(1, 2) // 创建数组[1, 2] 栈内存和堆内存 栈内存的优势是，存取速度比堆内存要快，充分考虑这一点，其实是可以优化代码性能的。 栈内存原始类型是按值访问的，其值存储在栈内存中，所占内存大小是已知的或是有范围的； 对基本类型变量的重新赋值，其本质上是进行压栈操作，写入新的值，并让变量指向一块栈顶元素（大概意思是这样，但是v8等引擎有没有做这方面的优化，就要细致去看了） 12var a = 1; // 压栈，1成为栈顶元素，其值赋给变量aa = 2; // 压栈，2成为栈顶元素，并赋值给变量a(内存地址变了) 堆内存而对象类型是按引用访问的，通过指针访问对象。 指针是一个地址值，类似于基本类型，存储于栈内存中，是变量访问对象的中间媒介。 而对象本身存储在堆内存中，其占用内存大小是可变的，未知的。 举例如下： 1var b = { name: 'Tusi' } 运行这行代码，会在堆内存中开辟一段内存空间，存储对象{name: 'Tusi'}，同时声明一个指针，其值为上述对象的内存地址，指针赋值给引用变量b，意味着b引用了上述对象。 对象可以新增或删除属性，所以说对象类型占用的内存大小一般是未知的。 1b.age = 18; // 对象新增了age属性 那么，按引用访问是什么意思呢？ 我的理解是：对引用变量进行对象操作，其本质上改变的是引用变量所指向的堆内存地址中的对象本身。 这就意味着，如果有两个或两个以上的引用变量指向同一个对象，那么对其中一个引用变量的对象操作，会影响指向该对象的其他引用变量。 12345var b = { name: 'Tusi' }; // 创建对象，变量b指向该对象var c = b; // 声明变量c，指向与b一致b.age = 18; // 通过变量b修改对象// 产生副作用，c受到影响console.log(c); // {name: \"Tusi\", age: 18} 考虑到对象操作的副作用，我们会在业务代码中经常使用深拷贝来规避这个问题。 数据类型的判断判断数据类型是非常重要的基础设施之一，那么如何判断数据类型呢？请接着往下看。 typeofjavascript本身提供了typeof运算符，可以辅助我们判断数据类型。 typeof操作符返回一个字符串，表示未经计算的操作数的类型。 typeof的运算结果如下，引用自MDN typeof 数据类型 运算结果 Undefined “undefined” Null “object” Boolean “boolean” Number “number” String “string” Symbol “symbol” Function “function” 其他对象 “object” 宿主对象（由JS环境提供，如Nodejs有global，浏览器有window） 取决于具体实现 可以看到，typeof能帮我们判断出大部分的数据类型，但是要注意的是： typeof null的结果也是&quot;object&quot; 对象的种类很多，typeof得到的结果无法判断出数组，普通对象，其他特殊对象 那么如何准确地知道一个变量的数据类型呢？ 结合instanceof instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 利用instanceof，我们可以判断一个对象是不是某个构造函数的实例。那么结合typeof，我们可以封装一个基本的判断数据类型的函数。 基本思想是：首先看typeof是不是返回&quot;object&quot;，如果不是，说明是普通数据类型，那么直接返回typeof运算结果即可；如果是，则需要先把null这个坑货摘出来，然后依次判断其他对象类型。 1234567891011121314151617181920212223242526function getType(val) { const type = typeof val; if (type === 'object') { if (val === null) { // null不是对象，所以不能用instanceof判断 return 'null' } else if (val instanceof Array) { return 'array' } else if (val instanceof Date) { return 'date' } else if (// 其他对象的instanceof判断) { return 'xxx' } else if (val instanceof Object) { // 所有对象都是Object的实例，所以放最后 return 'object' } } else { return type }}// 测试下getType(Symbol(1)) // \"symbol\"getType(null) // \"null\"getType(new Date()) // \"date\"getType([1, 2, 3]) // \"array\"getType({}) // \"object\" 但是，要把常用的对象类型都列举出来也是有点麻烦的，所以也不算一个优雅的方法。 终极神器toString有没有终极解决方案？当然是有的。但是，不是标题中的toString，而是Object.prototype.toString。用上它，不仅上面的数据类型都能被判断出来，而且也可以判断ES6引入的一些新的对象类型，比如Map, Set等。 12345678// 利用了Object.prototype.toString和正则表达式的捕获组function getType(val) { return Object.prototype.toString.call(val).replace(/\\[object\\s(\\w+)\\]/, '$1').toLowerCase();}getType(new Map()) // \"map\"getType(new Set()) // \"set\"getType(new Promise((resolve, reject) =&gt; {})) // \"promise\" 为什么普通的调用toString不能判断数据类型，而Object.prototype.toString可以呢？ 因为Object是基类，而各个派生类，如Date， Array等在继承Object的时候，一般都重写(overwrite)了toString方法，用以表达自身业务，从而失去了判断类型的能力。 装箱和拆箱 首先解释一下什么是装箱和拆箱，把原始类型转换为对应的对象类型的操作称为装箱，反之是拆箱。 装箱我们知道，只有对象才可以拥有属性和方法，但是我们在使用一些基本类型数据的时候，却可以直接调用它们的一些属性或方法，这是怎么回事呢？ 123456var a = 1;a.toFixed(2); // \"1.00\"var b = 'I love study';b.length; // 12b.substring(2, 6); // \"love\" 其实在读取一些基本类型数据的属性或方法时，javascript会创建临时对象（也称为“包装对象”），通过这个临时对象来读取属性或方法。以上代码等价于： 123456789var a = 1;var aObj = new Number(a);aObj.toFixed(2); // \"1.00\"var b = 'I love study';var bObj1 = new String(b);bObj1.length; // 12var bObj2 = new String(b);bObj2.substring(2, 6); // \"love\" 临时对象是只读的，可以理解为它们在发生读操作后就销毁了，所以不能给它们定义新的属性，也不能修改它们现有的属性。 123456var c = &apos;123&apos;;c.name = &apos;jack&apos;; // 给临时对象加新属性是无效的c.name; // undefinedc.length; // 3c.length = 2; // 修改临时对象的属性值，是无效的c.length; // 3 我们也可以显示地进行装箱操作，即通过String(), Number(), Boolean()构造函数来显示地创建包装对象。 12var b = 'I love study';var bObj = new String(b); 拆箱对象的拆箱操作是通过valueOf和toString完成的，且看下文。 类型的转换javascript在某些场景会自动执行类型转换操作，而我们也会根据业务的需要进行数据类型的转换。类型的转换规则如下： 对象到原始值的转换toStringtoString()是默认的对象到字符串的转换方法。 12var a = {};a.toString(); // \"[object Object]\" 但是很多类都自定义了toString()方法，举例如下： Array：将数组元素用逗号拼接成字符串作为返回值。 12var a = [1, 2, 3];a.toString(); // 1,2,3 Function：返回一个字符串，字符串的内容是函数源代码。 Date：返回一个日期时间字符串。 12var a = new Date();a.toString(); // \"Sun May 10 2020 11:19:29 GMT+0800 (中国标准时间)\" RegExp：返回表示正则表达式直接量的字符串。 12var a = /\\d+/;a.toString(); // \"/\\d+/\" valueOfvalueOf()会默认地返回对象本身，包括Object, Array, Function, RegExp。 日期类Date重写了valueOf()方法，返回一个1970年1月1日以来的毫秒数。 12var a = new Date();a.toString(); // 1589095600419 对象 –&gt; 布尔值从上表可见，对象（包括数组和函数）转换为布尔值都是true。 对象 –&gt; 字符串对象转字符串的基本规则如下： 如果对象具有toString()方法，则调用这个方法。如果它返回字符串，则作为转换的结果；如果它返回其他原始值，则将原始值转为字符串，作为转换的结果。 如果对象没有toString()方法，或toString()不返回原始值（不返回原始值这种情况好像没见过，一般是自定义类的toString()方法吧），那么javascript会调用valueOf()方法。如果存在valueOf()方法并且valueOf()方法返回一个原始值，javascript将这个值转换为字符串（如果这个原始值本身不是字符串），作为转换的结果。 否则，javascript无法从toString()或valueOf()获得一个原始值，会抛出异常。 对象 –&gt; 数字与对象转字符串的规则类似，只不过是优先调用valueOf()。 如果对象具有valueOf()方法，且valueOf()返回一个原始值，则javascript将这个原始值转换为数字（如果原始值本身不是数字），作为转换结果。 否则，如果对象有toString()方法且返回一个原始值，javascript将这个原始值转换为数字，作为转换结果。 否则，javascript将抛出一个类型错误异常。 显示转换使用String(), Number(), Boolean()函数强制转换类型。 123var a = 1;var b = String(a); // \"1\"var c = Boolean(a); // true 隐式转换在不同的使用场景中，javascript会根据实际情况进行类型的隐式转换。举几个例子说明下。 加法运算符+我们比较熟悉的运算符有算术运算符+, -, *, /，其中比较特殊的是+。因为加法运算符+可以用于数字加法，也可以用于字符串连接，所以加法运算符的两个操作数可能是类型不一致的。 当两个操作数类型不一致时，加法运算符+会有如下的运算规则。 如果其中一个运算符是对象，则会遵循对象到原始值的转换规则，对于非日期对象来说，对象到原始值的转换基本上是对象到数字的转换，所以首先调用valueOf()，然而大部分对象的valueOf()返回的值都是对象本身，不是一个原始值，所以最后也是调用toString()去获得原始值。对于日期对象来说，会使用对象到字符串的转换，所以首先调用toString()。 121 + {}; // \"1[object Object]\"1 + new Date(); // \"1Sun May 10 2020 22:53:24 GMT+0800 (中国标准时间)\" 在进行了对象到原始值的转换后，如果加法运算符+的其中一个操作数是字符串的话，就将另一个操作数也转换为字符串，然后进行字符串连接。 123var a = {} + false; // \"[object Object]false\"var b = 1 + []; // \"1\" 否则，两个操作数都将转换为数字（或者NaN），然后进行加法操作。 12345var a = 1 + true; // 2var b = 1 + undefined; // NaNvar c = 1 + null; // 1 [] == ![]还有个很经典的例子，就是[] == ![]，其结果是true。一看，是不是觉得有点懵，一个值的求反竟然还等于这个值！其实仔细分析下过程，就能发现其中的奥秘了。 首先，我们要知道运算符的优先级是这样的，一元运算符!的优先级高于关系运算符==。 所以，右侧的![]首先会执行，而逻辑非运算符!会首先将其操作数转为布尔值，再进行求反。[]转为布尔值是true，所以![]的结果是false。此时的比较变成了[] == false。 根据比较规则，如果==的其中一个值是false，则将其转换为数字0，再与另一个操作数比较。此时的比较变成了[] == 0。 接着，再参考比较规则，如果一个值是对象，另一个值是数字或字符串，则将对象转为原始值，再进行比较。左侧的[]转为原始值是空字符串&quot;&quot;，所以此时的比较变成了&quot;&quot; == 0。 最后，如果一个值是数字，另一个是字符串，先将字符串转换为数字，再进行比较。空字符串会转为数字0，0与0自然是相等的。 搞懂了这个问题，也可以分析下为什么{} == !{}的结果是false了，这个就比较简单了。 看到这里，你还觉得数据类型是简答的知识点吗？有兴趣深究的朋友可以翻阅下ES5的权威解释。 最后数据类型是javascript中非常重要的一部分，搞清楚数据类型的基本知识点，对于学习javascript的后续知识点多有裨益。 另外，写笔记其实对思考问题很有帮助，就算只是总结很简单的基础知识，也是多有助益。 以上内容是个人笔记和总结，难免有错误或遗漏之处，欢迎留言交流。","link":"/js数据类型很简单，却也不简单.html"},{"title":"linux个人学习过程中常用命令及问题记录","text":"我是linux技术盲，这里记录一下自己在学习linux过程中敲的命令以及遇到的各种问题，脚踏实地一步一步学好linux。 yum install setuptool最小化的linux系统（centos\\redhat）默认都是没有安装setup图形小工具的，需要自行安装。 yum install ntsysv安装系统服务（设置系统的各种服务） yum install system-config-network-tui网络服务（敲了命令后提示No Package system-config-network-tui available，这里先记录一下，后面研究） yum install system-config-securitylevel-tuiyum install -y iptablesCentOS7默认的防火墙不是iptables，而是firewalle。这里安装iptables。 Xshell 5如何连接本地虚拟机参考教程 mv命令mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。source表示源文件或目录，target表示目标文件或目录。如果将一个文件移到一个已经存在的目标文件中，则目标文件的内容将被覆盖。http://man.linuxde.net/mv vi命令vi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。http://man.linuxde.net/vi 没有eth0解决方案https://www.cnblogs.com/feixiangtk/p/6819118.html根据这篇文章指导，解决了xshell无法连接centos7的问题，感谢！ pwd命令pwd命令以绝对路径的方式显示用户当前工作目录。 mkdir命令mkdir命令用来创建目录。 chmod命令chmod命令用来变更文件或目录的权限。 touch命令touch命令有两个功能：一是用于把已存在文件的时间标签更新为系统当前的时间（默认方式），它们的数据将原封不动地保留下来；二是用来创建新的空文件。 xshell秘钥登录教程https://www.linuxidc.com/Linux/2016-06/132268.htm 桥接 NAT Host-only三者的区别https://www.cnblogs.com/ggjucheng/archive/2012/08/19/2646007.html centos7无法安装npm和nodejs解决方案http://blog.csdn.net/tanga842428/article/details/73277739 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/linux个人学习过程中常用命令及问题记录.html"},{"title":"面试官真的会问：new的实现以及无new实例化","text":"面试官很忙，但我不单纯是蹭热点，今天聊的主题绝对是面试中命中率很高的知识点。我在复习javascript函数这块知识时，注意到一个有意思的点，就是构造函数显式return，并由此引发了一波头脑风暴…… 我们知道，如果不做特殊处理，new构造函数时会发生下面这几步。 首先创建一个新对象，这个新对象的__proto__属性指向构造函数的prototype属性 此时构造函数执行环境的this指向这个新对象 执行构造函数中的代码，一般是通过this给新对象添加新的成员属性或方法。 最后返回这个新对象。 下面我们来验证下： 123456789101112function Test() { console.log(JSON.stringify(this)); console.log(this.__proto__.constructor === Test); this.name = 'jack'; this.age = 18; console.log(JSON.stringify(this));}var a = new Test();// Chrome控制台会输出以下内容// {}// true// {\"name\":\"jack\",\"age\":18} 这完全符合我们的认知，没毛病。 实现一个new那么在认识到new实例化过程的几个关键步骤后，我们也能解答一道面试中常见的题目：如何实现一个new？ 实现一个new也就意味着不能用new关键字，那么要完成这么一系列步骤，当然是通过函数实现了。 123456789// func是构造函数，...args是需要传给构造函数的参数function myNew(func, ...args) { // 创建一个空对象，并且指定原型为func.prototype var obj = Object.create(func.prototype); // new构造函数时要执行函数，同时指定this func.call(obj, ...args); // 最后return这个对象 return obj;} 以这四个关键步骤作为指导思想，我们很快就写出了代码实现。从这一点我也能体会到思路的重要性，别当工具人，代码才是工具！ 从实现逻辑上来看没什么问题，我们来验证下。 12345678function Test(name, age) { this.name = name; this.age = age;}myNew(Test, '小明', 18);// Chrome控制台会输出以下内容// Test {name: \"小明\", age: 18} 构造函数显式return所谓显式return，就是在构造函数中主动return一个对象，这里说的对象不仅包括Object，也包含Array，Date等对象哦。 我们可以试一试： 12345678910function Test() { this.name = 'jack'; this.age = 18; return { content: '我有freestyle' }}new Test();// Chrome控制台会输出以下内容// {content: \"我有freestyle\"} 那么return一个普通类型数据有没有用呢？比如字符串，数字？试试便知。 12345678function Test() { this.name = 'jack'; this.age = 18; return '我有freestyle'}new Test();// Chrome控制台会输出以下内容// Test {name: \"jack\", age: 18} 可以看到，当我们return一个普通类型数据时，不会影响结果，依然会返回new出来的这个新对象。 我们也应该知道，new构造函数就是为了创建对象，你return一个字符串之类的普通类型数据是没有任何意义的，所以我们的关注点应该是return一个特殊的对象。请接着往下看。 无new实例化所谓“无new实例化”，就是指不通过new关键字实例化对象（当然，这里说的不通过new，只是调用层面的，底层还是用了new）。这一点我们使用jQuery的时候已经体验过了。 12// 实例化了一个jQuery对象，但是没有用到newvar ele = jQuery('&lt;div&gt;freestyle&lt;/div&gt;'); 那么这种黑科技是怎么实现的呢？ 前面已经提到了，我们可以在构造函数中通过显式return来返回一个自定义的对象，那么这里就有发挥的空间了。我们通过一个简单的例子来感受下： 12345678910111213function Shadow() { this.name = 'jack'; this.age = 18;}function jQuery() { return new Shadow();}var obj1 = jQuery();console.log(obj1)// Chrome控制台会输出以下内容// Shadow {name: \"jack\", age: 18} jQuery()用了移花接木的障眼法完成了对象实例化，一手隐藏的new Shadow()让我们误以为不用new直接调用函数也能创建实例。 我们再来试下new jQuery()，会发现，“卧槽，怎么跟jQuery()执行结果一模一样！” 1234var obj2 = new jQuery();console.log(obj2)// Chrome控制台会输出以下内容// Shadow {name: \"jack\", age: 18} 这是因为new构造函数显式return了new Shadow()，这样返回的结果也就是new Shadow()实例化出来的对象，而不使用new直接调用jQuery()，只是把jQuery()当成一个普通的函数执行，其结果不言而喻是new Shadow()实例化出来的对象。 所以，这里new jQuery()和jQuery()是等价的。 虽然jQuery已经用得越来越少，但是其设计思路非常值得我们学习。那么jQuery到底妙在哪里？可以说是很多，链式操作，插件体系这些特色都是我们耳熟能详的。不扯太多了，就让我们来简单分析下jQuery实例化的过程。 我这里拿到了jQuery v1.12.4版本的代码，大概1W行，很舒服。 翻啊翻啊，翻到了第71行，看到了这么一串代码： 123jQuery = function( selector, context ) { return new jQuery.fn.init( selector, context );} 这不就是我们熟悉的移花接木技术吗？jQuery.fn.init似乎就是上面例子中的Shadow。看着有点像了，但是还是要好好研究下。 为啥要搞个jQuery.fn?jQuery.fn是jQuery.prototype的别名，是为了代码简洁的考虑。这一点参考源码第91行就可以知道。 12jQuery.fn = jQuery.prototype = {// ...... 移花接木如何保证原型指向？我们知道，如果仅仅通过new jQuery.fn.init(selector, context)是存在一个问题的，问题就是得到的实例不是jQuery的实例，而是jQuery.fn.init的实例。那么如何处理这个问题呢？ 我们翻到源码2866行，可以看到： 123init = jQuery.fn.init = function( selector, context, root ) { // 创建实例的具体逻辑} 具体init方法怎么创建一个jQuery对象，做了哪些判断逻辑，这些都不是本文关注的重点。我们需要关注的是，jQuery是如何保证实例化的对象的原型指向是正确的？不然实例化的对象如何使用jQuery.prototype上面挂载的诸多方法呢，比如this.show()、this.hide()？ 紧接着翻到2982行，我有了答案： 1init.prototype = jQuery.fn; 妙啊，这一手修改原型指向的操作，完美解决了这个问题。这样一来，new init()得到的实例自然也是jQuery的实例。 1234jQuery.prototype.init.prototype === jQuery.prototype; // truevar a = $('&lt;div&gt;123&lt;/div&gt;')a instanceof jQuery // truea instanceof jQuery.fn.init // true 这样一来，我们可以得到一个基本的设计思路： 12345678910function myModule(params) { return new myModule.fn.init(params);}myModule.fn = myModule.prototype = { constructor: myModule}myModule.fn.init = function(params) { // 可以对实例对象进行各种操作}myModule.fn.init.prototype = myModule.prototype; 在这个基础上，我们可以扩展静态方法和原型方法，这个myModule模块就变得越来越丰富。 最后妙啊，一个构造函数，让我陷入了思考……扶我起来，我还能学！","link":"/new的实现以及无new实例化.html"},{"title":"ng-zorro使用过程中的一些笔记","text":"今天开始学习NG-ZORRO这个UI框架，过程中遇到了许多问题，这里把一些问题记录下来，方便后续查阅。NG-ZORRO由阿里大神们开源，给angular开发者提供了极大的便利。 改变icon图标的大小我试图通过改变width属性来改变图标的大小，通过background来改变颜色，最后才发现通过::before伪元素构造的图标其实是文字内容，因而其大小需要通过font-size来控制，而颜色则是由color来控制。知道真相的我眼泪掉下来。 12font-size: 24px;color: rgba(245, 245, 245, 0.6); 使用nz-button时，prod环境打包报错1&lt;button nz-button [nzType]=&quot;primary&quot;&gt; 在login组件中使用nz-button后，打包脚本执行到build:prod时报错，报错信息如下： 1ERROR in ng:///G:/projects/angular/my-app/src/app/login/login.component.html (9,3): Property &apos;primary&apos; does not exist on type &apos;LoginComponent&apos; 经过分析发现，可能是primary被当成这个组件的属性处理了，而我没有在组件中定义这个属性，所以报错，于是把它改成字符串试试。 1&lt;button nz-button [nzType]=&quot;&apos;primary&apos;&quot;&gt; 打包时间接近8分钟使用了nz-zorro后，打包竟然长达8分钟，而打包后的包的大小与之前一致。我相信这不是ng-zorro的问题，可能是我的webpack配置出现了问题。我之前使用的angular版本是4.2的，安装ng-zorro后报了个警告，于是我升级angular/core等版本到4.4，不知道是不是这些问题引起的，具体原因还没找到。这里先挖个坑。 12// 这一步等待时间超长，接近8分钟91% additional asset processing 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/ng-zorro使用过程中的一些笔记.html"},{"title":"sea.js的同步魔法","text":"前些时间也是想写点关于CMD模块规范的文字，以便帮助自己理解。今天看到一篇知乎回答，算是给了我一点启发。 同步写法却不阻塞？先上一个sea.js很经典的模块写法： 1234567// 定义一个模块define(function(require, exports, module) { // 加载jquery模块 var $ = require('jquery'); // 直接使用模块里的方法 $('#header').hide();}); 按道理加载模块，就是需要等jquery.js加载完毕才能使用，应该是一个异步的过程，为什么可以写成同步的形式呢？这是用了什么黑科技？ 原来作者玉伯大佬用了一个小魔法来“欺骗”我们。而卢勃大神在知乎给了一个很精彩的解释，这里直接分享下： 也就是说，require.js和sea.js都是在执行模块前预加载了依赖的模块，并没有比require.js显得更“懒加载”，只是所依赖模块的代码执行时机不同。require.js加载时执行，而sea.js是使用时执行。 其实从代码的写法也看得出来，require.js的依赖模块在加载后便有了执行结果，并作为回调函数的实参传入。 reuiqre.js写法： 1234// 加载完jquery.js后，得到的执行结果$作为参数传入了回调函数define(['jquery'], function($) { $('#header').hide();}); sea.js写法： 1234567// 预加载了jquery.jsdefine(function(require, exports, module) { // 执行jquery.js模块，并得到结果赋值给$ var $ = require('jquery'); // 调用jquery.js模块提供的方法 $('#header').hide();}); 从这一点上来看，两者在性能上并没有太多差异。因为最影响页面渲染速度的当然是资源的加载速度，既然都是预加载，那么加载模块资源的耗时是一样的（网络情况相同时）。 而模块代码的执行时机并没有那么影响性能（除非你的模块太大），现在的js引擎如V8引擎足够强，没什么压力。 懒加载是否存在？懒加载是存在的。我刚才说的sea.js并没有比require.js更显得“懒加载”是指模块加载的时机上两者是一致的，都是预先加载，而不是说不能懒加载。 比如说，有一个模块，页面渲染时，我不需要加载使用，但是在做了某种交互时（比如点了按钮），才需要加载使用，这个时候“懒加载”的作用就体现了。下面以require.js举个实例： 123456789101112131415161718192021require.config({ baseUrl: './assets/js/', paths: { modulea: 'module-a', moduleb: 'module-b' }})require([\"modulea\"], function(modulea) { var btnNode = document.querySelector('#btn-load'); var node1 = document.createElement('span'); node1.innerText = '模块A已经加载！' btnNode.insertAdjacentElement('beforebegin', node1) btnNode.addEventListener('click', function() { require([\"moduleb\"], function(moduleb) { var node2 = document.createElement('span'); node2.innerText = '模块B已经加载！' btnNode.insertAdjacentElement('afterend', node2) }); })}); 页面渲染时只加载模块A 点击按钮后加载模块B 总结虽然AMD和CMD两种思想有一些差异，但都不失为一种优秀的模块化方案，为大佬们打call！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/sea.js的同步魔法.html"},{"title":"then, catch, finally如何影响返回的Promise实例状态","text":"虽然Promise是开发过程中使用非常频繁的一个技术点，但是它的一些细节可能很多人都没有去关注过。我们都知道，.then, .catch, .finally都可以链式调用，其本质上是因为返回了一个新的Promise实例，而这些Promise实例现在的状态是什么或者将来会变成什么状态，很多人心里可能都没个底。我自己也意识到了这一点，于是我通过一些代码试验，发现了一些共性。如果您对这块内容还没有把握，不妨看看。 阅读本文前，您应该对Promise有一些基本认识，比如： Promise有pending, fulfilled, rejected三种状态，其决议函数resolve()能将Promise实例的状态由pending转为fulfilled，其决议函数reject()能将Promise实例的状态由pending转为rejected。 Promise实例的状态一旦转变，不可再逆转。 本文会从一些测验代码入手，看看Promise的几个原型方法在处理Promise状态时的一些细节，最后对它们进行总结归纳，加深理解！ 先考虑then的行为then的语法形式如下： 1p.then(onFulfilled[, onRejected]); onFulfilled可以接受一个value参数，作为Promise状态决议为fulfilled的结果，onRejected可以接受一个reason参数，作为Promise状态决议为rejected的原因。 如果onFulfilled或onRejected不返回值，那么.then返回的Promise实例的状态会变成fulfilled，但是伴随fulfilled的value会是undefined。 123456789101112new Promise((resolve, reject) =&gt; { resolve(1) // reject(2)}).then(value =&gt; { console.log('resolution occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection occurred, and the reason is: ', reason)}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection of the returned promise occurred, and the reason is: ', reason)}) 如果onFulfilled或onRejected返回一个值x，那么.then返回的Promise实例的状态会变成fulfilled，并且伴随fulfilled的value会是x。注意，一个非Promise的普通值在被返回时会被Promise.resolve(x)包装成为一个状态为fulfilled的Promise实例。 123456789101112new Promise((resolve, reject) =&gt; { reject(2)}).then(value =&gt; { console.log('resolution occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection occurred, and the reason is: ', reason) return 'a new value'}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection of the returned promise occurred, and the reason is: ', reason)}) 如果onFulfilled或onRejected中抛出一个异常，那么.then返回的Promise实例的状态会变成rejected，并且伴随rejected的reason是刚才抛出的异常的错误对象e。 123456789101112new Promise((resolve, reject) =&gt; { resolve(1)}).then(value =&gt; { console.log('resolution occurred, and the value is: ', value) throw new Error('some error occurred.')}, reason =&gt; { console.log('rejection occurred, and the reason is: ', reason)}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection of the returned promise occurred, and the reason is: ', reason)}) 如果onFulfilled或onRejected返回一个Promise实例p2，那么不管p2的状态是什么，.then返回的新Promise实例p1的状态会取决于p2。如果p2现在或将来是fulfilled，那么p1的状态也随之变成fulfilled，并且伴随fulfilled的value也与p2进行resolve(value)决议时传递的value相同； 12345678910111213141516new Promise((resolve, reject) =&gt; { resolve(1) // reject(2)}).then(value =&gt; { console.log('resolution occurred, and the value is: ', value) // return Promise.resolve('a fulfilled promise') return Promise.reject('a rejected promise')}, reason =&gt; { console.log('rejection occurred, and the reason is: ', reason) return Promise.resolve('a fulfilled promise') // return Promise.reject('a rejected promise')}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection of the returned promise occurred, and the reason is: ', reason)}) 这个逻辑同样适用于rejected的场景。也就是说，如果p2的状态现在或将来是rejected，那么p1的状态也随之变成rejected，而reason也来源于p1进行reject(reason)决议时传递的reason。 12345678910111213141516new Promise((resolve, reject) =&gt; { reject(1)}).then(value =&gt; { console.log('resolution occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection occurred, and the reason is: ', reason) return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject('a promise rejected after 3 seconds.') }, 3000) })}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection of the returned promise occurred, and the reason is: ', reason)}) 再考虑catch的行为catch的语法形式如下： 1p.catch(onRejected); .catch只会处理rejected的情况，并且也会返回一个新的Promise实例。 .catch(onRejected)与then(undefined, onRejected)在表现上是一致的。 事实上，catch(onRejected)从内部调用了then(undefined, onRejected)。 如果.catch(onRejected)的onRejected回调中返回了一个状态为rejected的Promise实例，那么.catch返回的Promise实例的状态也将变成rejected。 12345678910new Promise((resolve, reject) =&gt; { reject(1)}).catch(reason =&gt; { console.log('rejection occurred, and the reason is: ', reason) return Promise.reject('rejected')}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection of the returned promise occurred, and the reason is: ', reason)}) 如果.catch(onRejected)的onRejected回调中抛出了异常，那么.catch返回的Promise实例的状态也将变成rejected。 12345678910new Promise((resolve, reject) =&gt; { reject(1)}).catch(reason =&gt; { console.log('rejection occurred, and the reason is: ', reason) throw 2}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection of the returned promise occurred, and the reason is: ', reason)}) 其他情况下，.catch返回的Promise实例的状态将是fulfilled。 then, catch 小结综合以上来看，不管是.then(onFulfilled, onRejected)，还是.catch(onRejected)，它们返回的Promise实例的状态都取决于回调函数是否抛出异常，以及返回值是什么。 如果回调函数的返回值是一个状态为rejected的Promise实例，那么.then, .catch返回的Promise实例的状态就是rejected。 如果回调函数的返回值是一个还未决议的Promise实例p2，那么.then, .catch返回的Promise实例p1的状态取决于p2的决议结果。 如果回调函数中抛出了异常，那么.then, .catch返回的Promise实例的状态就是rejected，并且reason是所抛出异常的对象e。 其他情况下，.then, .catch返回的Promise实例的状态将是fulfilled。 最后看看finally不管一个Promise的状态是fulfilled还是rejected，传递到finally方法的回调函数onFinally都会被执行。我们可以把一些公共行为放在onFinally执行，比如把loading状态置为false。 注意，onFinally不会接受任何参数，因为它从设计上并不关心Promise实例的状态是什么。 123p.finally(function() { // settled (fulfilled or rejected)}); finally方法也会返回一个新的Promise实例，这个新的Promise实例的状态也取决于onFinally的返回值是什么，以及onFinally中是否抛出异常。 你可以通过修改以下代码中的注释部分来验证，不同的返回值对于finally返回的Promise实例的状态的影响。 1234567891011121314151617new Promise((resolve, reject) =&gt; { reject(1)}).then(value =&gt; { console.log('resolution occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection occurred, and the reason is: ', reason) return Promise.resolve(2); // return Promise.reject(3)}).finally(() =&gt; { // return Promise.resolve(4) // return Promise.reject(5) throw new Error('an error')}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value)}, reason =&gt; { console.log('rejection of the returned promise occurred, and the reason is: ', reason)}) 经过测试，可以发现，不管当前Promise的状态是fulfilled还是rejected，只要在onFinally中没有发生以下任何一条情况，finally方法返回的新的Promise实例的状态就会与当前Promise的状态保持一致！这也意味着即使在onFinally中返回一个状态为fulfilled的Promise也不能阻止新的Promise实例采纳当前Promise的状态或值！ 返回一个状态为或将为rejected的Promise 抛出错误 总的来说，在finally情况下，rejected优先！ 如何理解then中抛出异常后会触发随后的catch由于.then会返回一个新的Promise实例，而在.then回调中抛出了异常，导致这个新Promise的状态变成了rejected，而.catch正是用于处理这个新的Promise实例的rejected场景的。 12345678new Promise((resolve, reject) =&gt; { resolve(1)}).then(value =&gt; { console.log('resolution of the returned promise occurred, and the value is: ', value) var a = b; // 未定义b}).catch(reason =&gt; { console.log('caught the error occured in the callback of then method, and the reason is: ', reason)}) 最关键一点就是要理解：每次.then, .catch, .finally都产生一个新的Promise实例。 Promise和jQuery的链式调用区别在哪？上文也提到了，.then, .catch, .finally都产生一个新的Promise实例，所以这种链式调用的对象实例已经发生了变化。可以理解为： 12345678Promise.prototype.then = function() { // balabala return new Promise((resolve, reject) =&gt; { // if balabala // else if balabala // else balabala });} 而jQuery链式调用是基于同一个jQuery实例的，可以简单表述为： 1234jQuery.fn.css = function() { // balabala return this;} 感谢阅读本文主要是参考了MDN和《你不知道的JavaScript（下卷）》上关于Promise的知识点，简单分析了.then, .catch, .finally中回调函数的不同行为对于三者返回的Promise实例的影响，希望对大家有所帮助。 收藏吃灰不如现在就开始学习，奥利给！ 如果您觉得本文有所帮助，请留下您的点赞关注支持一波，谢谢！ 快关注公众号前端司南，与笔者一起交流学习吧！","link":"/then,catch,finally如何影响返回的Promise实例状态.html"},{"title":"ubuntu系统下sudo权限用户安装nodejs和nginx","text":"为了支撑公司某 ios app 上线，今天做了个隐私政策 h5 页面并上线，顺手体验了一把 ubuntu系统的 sudo 权限。本来想用 nodejs 的 express 框架搭个简单的静态资源托管服务，然后用 nginx 做下反向代理。但是在安装 express-generator 时遇到点问题，可能 sudo 权限玩得不够熟练，跟 root 用户还是有很大区别的。本文简单说下自己在 ubuntu 系统下 sudo 权限用户安装 nodejs 和 nginx 的过程。 安装nodejs下载安装包话不多说，直接上nodejs下载链接。 解压和软连接下载到的 nodejs 包是一个 .tar.xz 格式的包，解压命令如下： 1tar -xvf node-v10.15.3-linux-x64.tar.xz 为了让 node 和 npm 命令行全局可用，我采用了软连接的方式 12sudo ln -s /home/devadmin/frontend/download/node/bin/node /usr/local/bin/nodesudo ln -s /home/devadmin/frontend/download/node/bin/npm /usr/local/bin/npm 然后就可以舒服地使用 node 和 npm 命令行了。 设置npm代理为了提升 npm install 的速度和体验，我还用到了 npm 代理。 1npm config set registry https://registry.npm.taobao.org 这样 nodejs 就算安装完成了。 安装nginx安装 nginx 时采用的是 apt-get 的下载方式 1sudo apt-get install nginx nginx关注点安装后要知道的几点是： 配置文件所在目录 1/etc/nginx/ 静态资源所在目录 1/usr/share/nginx/ nginx主程序 1/usr/sbin/nginx nginx日志所在目录 1/var/log/nginx/ 配置文件的坑配置文件 nginx.conf 有个坑，需要把配置中的两行注释掉才有效。 12# include /etc/nginx/conf.d/*.conf;# include /etc/nginx/sites-enabled/*; 其他的坑遇到了 xftp 无法上传文件的情况，一般是文件夹权限不够，可以提高权限，然后再尝试。 1sudo chmod 777 dirname 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/ubuntu系统下sudo权限用户安装nodejs和nginx.html"},{"title":"vue作用域插槽，你真的懂了吗","text":"在网上搜了很多关于作用域插槽的解释，感觉没有写得很具体的吧，我认为应该对组件化有很深的理解才会触及到这个问题吧，这里也分享下我自己对于slot-scope的一点理解。 slot大家看看文档都懂了，无非就是在子组件中挖个坑，坑里面放什么东西由父组件决定。 123456789101112// 子组件&lt;template&gt; &lt;slot&gt;来啊，我这里挖了个坑&lt;/slot&gt;&lt;/template&gt;// 父组件&lt;template&gt; &lt;child&gt; &lt;!-- 传入子组件的自定义内容，会填入到子组件的slot插槽中 --&gt; &lt;span&gt;我在这放个span，乐意的话，放个组件都行&lt;/span&gt; &lt;/child&gt;&lt;/template&gt; 给slot传入普通文本 给slot传入了一个图像处理组件 具名插槽也很简单，比如有多个插槽，我作为父组件，肯定想区别子组件中的几个插槽，那就要用slot标签的name属性来标识了，而父组件要决定在什么插槽里面放什么内容，就要将name的值赋值给slot属性传递给对应的插槽。如果slot没有name属性，就是匿名插槽了，而父组件中不指定slot属性的内容，就会被丢到匿名插槽中。 12345678910111213141516171819// 子组件&lt;template&gt; &lt;section&gt; &lt;slot name=&quot;article-title&quot;&gt;这里放标题&lt;/slot&gt; &lt;slot&gt;这里放作者&lt;/slot&gt; &lt;slot name=&quot;article-content&quot;&gt;这里放文章内容&lt;/slot&gt; &lt;/section&gt;&lt;/template&gt;// 父组件&lt;template&gt; &lt;section&gt; &lt;slot-child&gt; &lt;h1 slot=&quot;article-title&quot;&gt;vue作用域插槽，你真的懂了吗？&lt;/h1&gt; &lt;p slot=&quot;article-content&quot;&gt;好像有点懂了&lt;/p&gt; &lt;div&gt;王五&lt;/div&gt; &lt;/slot-child&gt; &lt;/section&gt;&lt;/template&gt; 最难理解的是作用域插槽。看了文档说明的朋友可能还会有点晕，大概是说在作用域插槽内，父组件可以拿到子组件的数据。子组件可以在slot标签上绑定属性值，如： 1&lt;slot :nickName=&quot;&apos;Tusi&apos;&quot;&gt;&lt;/slot&gt; 而父组件通过slot-scope绑定的对象下拿到nickName的值。 123456789&lt;template&gt; &lt;section&gt; &lt;slot-child&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;div&gt;{{scope.nickName}}&lt;/div&gt; &lt;/template&gt; &lt;/slot-child&gt; &lt;/section&gt;&lt;/template&gt; 这里大家应该都有疑问。这有什么用？我在子组件用$emit向父组件传递数据不就行了？ 关于作用域插槽的一点理解我觉得要从组件之间的数据流向来思考作用域插槽的应用场景。 假设第一个场景，需要你写一个商品卡片组件，并通过循环去展示多个卡片，并且要求能响应每个卡片上的图片或者其他内容的点击事件而跳转到商品详情页，你会怎么写？ 我会使用如下的处理方式，首先将商品卡片写成一个组件Commodity.vue，而在CommodityList.vue中用一个v-for来处理商品卡片列表的展示。 1&lt;commodity v-for=&quot;(item,index) in commodities&quot; @clickCommodity=&quot;onCommodityClick&quot;&gt;&lt;/commodity&gt; Commodity组件通过$emit像父组件传递clickCommodity事件，并携带商品数据，父组件即可在onCommodityClick方法中得到数据，进行业务处理，这样便完成了一个基本的由子到父的数据传递。 如果再往上抽象一下呢？比如我有多个运营栏目，像淘宝首页有“有好货”，“爱逛街”这样两个栏目，每个栏目下都需要有一个商品卡片列表，那么商品卡片列表CommodityList.vue就要抽成组件了。而这个包含多个运营栏目的vue组件我假设它叫ColumnList.vue，在其中通过v-for调用了CommodityList组件。 注意：业务来了，我希望把点击商品卡片的业务放在ColumnList.vue中处理。你们想象一下要怎么做？一种土办法就是商品按钮点击时，Commodity组件$emit通知CommodityList.vue，而CommodityList接着把事件用$emit往上抛，那么ColumnList.vue就能处理这个点击事件了。这样做完全没有问题，但是显得子组件很不纯粹，跟业务都扯上关系了。 那么如何优雅地解决这个问题呢？这个时候，作用域插槽真正派上用场了。 通过作用域插槽将本应该由CommodityList处理的商品卡片点击业务onCommodityClick提升到ColumnList处理。 12345678910111213141516&lt;el-row :gutter=&quot;20&quot;&gt; &lt;el-col :span=&quot;12&quot; v-for=&quot;(column, index) in columnList&quot; :key=&quot;index&quot;&gt; &lt;el-card class=&quot;box-card card-column&quot;&gt; &lt;div slot=&quot;header&quot; class=&quot;clearfix&quot;&gt; &lt;span&gt;{{column.columnName}}&lt;/span&gt; &lt;/div&gt; &lt;commodity-list :commodities=&quot;column.commodityList&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;!-- 这里只需要给Commodity组件传入数据，响应Commodity组件的clickCommodity事件即可。 事件不必携带参数，完全符合父到子的数据流向，而不会发生子组件又给父组件反向发数据的情况 --&gt; &lt;commodity :modityData=&quot;scope.row&quot; @clickCommodity=&quot;onCommodityClick(scope.row)&quot;&gt;&lt;/commodity&gt; &lt;/template&gt; &lt;/commodity-list&gt; &lt;/el-card&gt; &lt;/el-col&gt;&lt;/el-row&gt; 而CommodityList组件内部应该是改造成这样，slot接收来自父组件的商品卡片组件，这里面不涉及关于商品组件的业务，只关注其他业务和布局即可。最终就实现了组件和业务的剥离，这也是组件化的精髓所在吧。不知道有没有帮到您呢？ 12345&lt;el-row :gutter=&quot;20&quot;&gt; &lt;el-col :span=&quot;8&quot; v-for=&quot;(item, index) in commodities&quot; :key=&quot;index&quot; style=&quot;margin-top:20px;&quot;&gt; &lt;slot :row=&quot;item&quot;&gt;&lt;/slot&gt; &lt;/el-col&gt;&lt;/el-row&gt; 这是我实现的效果，忽略样式吧，原理都懂了，做个漂亮的卡片有多难？ 总结一下，作用域插槽适合的场景是至少包含三级以上的组件层级，是一种优秀的组件化方案！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/vue作用域插槽，你真的懂了吗.html"},{"title":"vue全家桶版本升级排错","text":"如果你使用了element-ui的el-tabs组件，并且想要单独升级element-ui至2.10.0，你会发现，使用了el-tabs组件的页面只要打开就卡死。原因是element-ui~2.10.0采用了不兼容vue~2.5.10的写法。于是我尝试系统性升级vue全家桶，这也是为系统赋予更多能力做准备。结果遇到一些报错，这里记录一下。 升级过程当前版本vue: 2.5.10 vue-loader: 13.5.0 vue-router: 3.0.1 vuex: 3.0.1 axios: 0.17.1 element-ui: 2.2.2 目标版本vue: 2.6.10 vue-loader: 15.7.0 vue-router: 3.0.3 vuex: 3.1.1 axios: 0.18.1 element-ui: 2.10.0 报错1(包版本不匹配)修改package.json中的依赖包版本号之后，npm install一波后就报错了。 123456789101112131415Vue packages version mismatch:- vue@2.6.10- vue-template-compiler@2.5.10This may cause things to work incorrectly. Make sure to use the same version for both.If you are using vue-loader@&gt;=10.0, simply update vue-template-compiler.If you are using vue-loader@&lt;10.0 or vueify, re-installing vue-loader/vueify should bump vue-template-compiler to the latest. @ ./src/router/modules/test/index.js 22:23-67 @ ./src/router/common.js @ ./src/router/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:9532 webpack/hot/dev-server babel-polyfill ./src/main.js 分析：vue和vue-template-compiler两个包的版本不匹配，需要升级vue-template-compile。github搜索这个包搜不到，最后在npm包官网找到了。 解决方案：升级vue-template-compile: 2.6.10 报错2(vue-loader)1234567891011121314151617|| &lt;section&gt;| &lt;el-form class=\"cl-add-form\" :model=\"dataForm\" :rules=\"rules\" ref=\"dataForm\" label-width=\"125px\"&gt;| &lt;el-form-item label=\"法定节假日名称\" prop=\"name\"&gt; @ ./src/views/backend/enterprise/holiday/add-public-holiday.vue 1:0-97 30:4-35:6 30:81-35:5 @ ./src/views lazy ^\\.\\/.*$ @ ./src/authority/generate-routes.js @ ./src/store/modules/user.js @ ./src/store/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:9532 webpack/hot/dev-server babel-polyfill ./src/main.js error in ./src/views/backend/enterprise/holiday/add-special-holiday.vue?vue&amp;type=template&amp;id=09f84cb0&amp;Module parse failed: Unexpected token (2:0)You may need an appropriate loader to handle this file type. 分析：经观察，发现可能是不识别vue文件或其中某部分，于是从vue-loader入手，也在网上查阅了一些资料，需要在webpack的plugins中加入vue-loader/lib/plugin。 解决方案： 1234567const VueLoaderPlugin = require('vue-loader/lib/plugin')plugins: [ new VueLoaderPlugin(), // 其他插件 ...] 报错3(postcss-loader)12345678910111213141516171819(Emitted value instead of an instance of Error) ⚠️ PostCSS LoaderPrevious source map found, but options.sourceMap isn't set.In this case the loader will discard the source map entirely for performance reasons.See https://github.com/postcss/postcss-loader#sourcemap for more information. @ ./node_modules/vue-style-loader!./node_modules/css-loader?{\"sourceMap\":false}!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/lib?{\"sourceMap\":false}!./node_modules/vue-loader/lib?{\"loaders\":{\"css\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}}],\"postcss\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}}],\"less\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"less-loader\",\"options\":{\"sourceMap\":false}}],\"sass\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"sass-loader\",\"options\":{\"indentedSyntax\":true,\"sourceMap\":false}}],\"scss\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"sass-loader\",\"options\":{\"sourceMap\":false}}],\"stylus\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"stylus-loader\",\"options\":{\"sourceMap\":false}}],\"styl\":[\"vue-style-loader\",{\"loader\":\"css-loader\",\"options\":{\"sourceMap\":false}},{\"loader\":\"stylus-loader\",\"options\":{\"sourceMap\":false}}]},\"cssSourceMap\":false,\"cacheBusting\":true,\"transformToRequire\":{\"video\":[\"src\",\"poster\"],\"source\":\"src\",\"img\":\"src\",\"image\":\"xlink:href\"}}!./src/views/iot-supervise/truck/truck-carousel.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp; 4:14-1577 14:3-18:5 15:22-1585 @ ./src/views/iot-supervise/truck/truck-carousel.vue?vue&amp;type=style&amp;index=0&amp;lang=css&amp; @ ./src/views/iot-supervise/truck/truck-carousel.vue @ ./src/views lazy ^\\.\\/.*$ @ ./src/authority/generate-routes.js @ ./src/store/modules/user.js @ ./src/store/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:9532 webpack/hot/dev-server babel-polyfill ./src/main.js 分析：这里面的错误是关于postcss-loader的，只要将config/index.js中dev.cssSourceMap设置为true即可。 警告1(svg-sprite-loader)升级过程中还遇到了一个警告，虽然不影响功能，但是看着还是很难受的。 12345678in ./src/icons/svg/workList.svgsvg-sprite-loader exception. 28 rules applies to D:\\coollu\\projects\\coollu-v3\\source-code\\v1.0.1\\update-elementui-test\\src\\icons\\svg\\workList.svg @ ./src/icons/svg \\.svg$ @ ./src/icons/index.js @ ./src/main.js @ multi (webpack)-dev-server/client?http://localhost:9532 webpack/hot/dev-server babel-polyfill ./src/main.js 搜索关键词后，发现网上并没有此类答案。因此我考虑是版本问题，于是升级svg-sprite-loader至最新版本4.1.6，解决了这个警告问题。 总结至此升级过程就完成了！顺便一提，系统性升级必须要经过全面测试，否则你难以保证完全向下兼容哦！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/vue全家桶版本升级排错.html"},{"title":"vue-router基础内容","text":"vue-router是vue官方指定的路由库，让我们来撸一遍vue-router的基本概念吧！ 安装我是以直接下载的方式来引入vue-router的。 1&lt;script src=\"./lib/vue-router.js\"&gt;&lt;/script&gt; 使用vue-router定义路由12345678const routes = [ // 这里定义一个最基础的路由 { path: '/b', component: ComponentB } // 动态路由 { path: '/user/:id', component: User } // 命名路由 { path: '/user/:id', name: user, component: User }]; 创建 router 实例123const router = new VueRouter({ routes // （缩写）相当于 routes: routes}) vue实例注入路由通过 router 配置参数注入路由。 12345var app = new Vue({ el: '#app', router: router, ......}) 通过注入路由器，我们可以在任何组件内通过 this.$router 访问路由器，也可以通过 this.$route 访问当前路由。 使用路由出口123&lt;!-- 路由出口，与angular的router-outlet类似 --&gt;&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 路由跳转router-link通过router-link组件，我们可以进行路由的跳转。to属性的写法很多，请参考router-link。 12&lt;router-link to=\"/b\"&gt;Component B&lt;/router-link&gt;&lt;router-link :to=\"{ path: '/c' }\"&gt;Component C&lt;/router-link&gt; 编程式路由router.push(location, onComplete?, onAbort?)该方法的参数location可以是一个字符串路径，或者一个描述地址的对象。用法如下： 1234router.push('b');router.push({path: 'b'})router.push({path: 'user/1'})router.push({name: 'user', params: {id: 1}}) router.replace(location, onComplete?, onAbort?)跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 1router.replace(...) ps：你也可以在router-link使用replace。 1&lt;router-link :to=\"...\" replace&gt; router.go(n)类似 window.history.go(n)。是history回退和前进的操作。 了解了上述几个点后，你基本上可以完成基本的路由功能了。 嵌套路由一个组件内部也可以有路由视图router-view。 1234&lt;div&gt; &lt;p&gt;FatherComponent Content&lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 于此同时需要在路由定义处添加children属性。也是类似嵌套的写法。 1234567{ path: '/father', component: FatherComponent, children: [ { path: 'child', component: ChildComponent } ]} 命名视图当我们的布局是由几部分组成时，并且我们希望每一部分都有自己的路由，那么此时就不是嵌套路由了，而是多路由视图，这个时候我们就需要用到命名视图了。 123&lt;router-view class=\"view one\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view two\" name=\"a\"&gt;&lt;/router-view&gt;&lt;router-view class=\"view three\" name=\"b\"&gt;&lt;/router-view&gt; 而在定义路由的时候也要对应好。 123456789101112const router = new VueRouter({ routes: [ { path: '/', components: { default: Foo, a: Bar, b: Baz } } ]}) 用watch监测路由很多时候我们可能需要监测路由变化，那么需要在watch中监测’$route’，方法大体是’$route’ (to, from) {your code} 12345678watch: { '$route': function (to, from) { this.fromRoute = from.path; this.toRoute = to.path; // 可以根据情况做一些后续的逻辑处理 ...... }} 路由重定向重定向的意思就是本来是要跳路由A的，但是定向到B。写法如下： 123456789101112routes: [ { path: '/b', component: ComponentB }, // redirect为path的形式 { path: '/a', redirect: '/b' }, // redirect为name的形式 { path: '/a', redirect: { name: 'compB'} }, // 甚至是一个方法，动态返回重定向目标，这样我感觉都可以做路由守卫了。 { path: '/a', redirect: to =&gt; { // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 }}] 路由别名123routes: [ { path: '/a', component: A, alias: '/b' }] alias的意思是别名，通俗讲，你大名是张三，别人叫你阿三，你也答应了，阿三就是你的别名。反映到路由上就是说，b是a的别名，那我输入路由b，地址栏会显示b，但也会映射到A组件；如果输入a，那地址栏就还是a，组件也是A，没什么变化。 向路由组件传递props在组件中使用 $route 会使之与其对应路由形成高度耦合，我们可以使用props的形式来重新定义。这样id就会作为一个prop属性，用来接收传递的数据。 123456789// 路由定义routes: [ { name:'employee', path: '/employee/:id', component: Employee, props: true}]// 组件定义const Employee = Vue.component('Employee', { props: ['id'], template: '&lt;p&gt;I am worker {{id}}&lt;/p&gt;'}); 路由守卫通过跳转或取消的方式守卫路由。 全局守卫使用router.beforeEach注册全局的路由守卫： 123456789router.beforeEach(function(to, from, next) { console.log('GLOBAL_beforeEach'); if (to.path === '/my') { next(false); alert('You are not registered...'); } else { next(); }}); next：一定要调用该方法来 resolve 这个钩子 next(): 进行管道中的下一个钩子。 next(false): 中断当前的导航。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。也可以传params的。 路由独享的守卫利用beforeEnter钩子实现。 1234567891011const routes = [ { name:'user', path: '/user/:id', component: User, beforeEnter: function (to, from, next) { console.log('ROUTE_beforeEnter'); next(false); } }] 组件内的守卫可以利用beforeRouteEnter，beforeRouteUpdate，beforeRouteLeave几个钩子来定义守卫。 beforeRouteEnter用于拦截进入组件的情形。 beforeRouteUpdate用于当前路由改变，但是该组件被复用的情况，如/user/1 和 /user/2 之间跳转的时候。 beforeRouteLeave用于拦截离开组件的情形。 路由transitionrouter-view是基本的动态组件，所以我们可以用 transition组件给它添加一些过渡效果。 123&lt;transition name=\"slide\"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 路由切换时记住滚动的位置创建 Router 实例时，指定scrollBehavior属性。 1234567891011const router = new VueRouter({ routes: [...], scrollBehavior (to, from, savedPosition) { // 第三个参数 savedPosition 当且仅当 popstate 导航 (通过浏览器的前进/后退 按钮触发) 时才可用。 if (savedPosition) { return savedPosition } else { return { x: 0, y: 0 } } }}) 更多功能实现请参考vue-router文档。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/vue-router基础内容.html"},{"title":"vue学习过程的个人笔记","text":"我学习和使用angular也有两年了。期间也接触过react，vue，简单地学习过。现在也想好好学一下vue，于是我在这里记录一下学习的大概过程。 安装vue-cli之前用嵌入script标签的方式撸过一遍vue的一些特性，包括vue-router。这里我使用vue-cli的方式来安装一下。 1npm install --global vue-cli 生成vue项目1vue init webpack vuecms 命令中的webpack是指生成一个基于webpack的项目。vue-cli生成项目过程的最后一个会提示你选择是否自动执行npm install，我选择了yes，或者cd到项目目录下运行npm install安装依赖也可以。安装依赖的时间有点长，请耐心等待！ 启动vue项目1npm start 该命令会执行npm run dev，默认端口是8080，我个人喜欢改端口，在dev脚本后加上–port=3200即可。 打包vue项目1npm run build 运行该命令后，会执行build.js。webpack的配置文件主要涉及build和config两个目录，后面修改这两个目录中的文件应该可以进行定制。 我们build项目之后，直接把index.html拖到浏览器中是不可以访问的。要么放在服务器上进行访问，要么就是使用http-server进行测试。 1npm install -g http-server 安装http-server后，我们cd到dist目录下，启动http-sever 12// 键入这个命令即可启动http-server服务http-server 然后我们就可以通过http://127.0.0.1:8080/index.html访问打包后的项目了。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/vue学习过程的个人笔记.html"},{"title":"vue项目中引入iconfont","text":"对于前端而言，图标的发展可谓日新月异。从img标签，到雪碧图，再到字体图标，svg，甚至svg也有了类似于雪碧图的方案svg-sprite-loader。雪碧图没有什么好讲的了，只是简单地利用了background-position来做图标定位。今天咱们先聊聊怎么使用字体图标和svg图标。其实字体图标也不陌生了，bootstrap，font-awesome，element-ui等UI库都基本标配了字体图标。 简单说下原理unicode预留了E000-F8FF范围作为私有保留区域，这个区间的unicode码非常适合做字体图标，前端根据unicode码就能显示对应的图标。 vue项目引入iconfont1. 在iconfont新建项目 注：这里修正一下，前缀应该是test-icon-。 2. 添加图标至项目 3. 使用iconfontUnicode方式（不推荐）在线使用 index.scss中引入在线字体 123456789@font-face { font-family: &apos;iconfont&apos;; /* project id 1254715 */ src: url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.eot&apos;); src: url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.eot?#iefix&apos;) format(&apos;embedded-opentype&apos;), url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.woff2&apos;) format(&apos;woff2&apos;), url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.woff&apos;) format(&apos;woff&apos;), url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.ttf&apos;) format(&apos;truetype&apos;), url(&apos;//at.alicdn.com/t/font_1254715_s1khj1whikd.svg#iconfont&apos;) format(&apos;svg&apos;);} 页面中使用 使用时很不友好，使用的是unicode码表示，使用图标还必须去iconfont项目去查询下unicode码。 12345678&lt;template&gt; &lt;div&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7ee;&lt;/i&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7ed;&lt;/i&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7ec;&lt;/i&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7eb;&lt;/i&gt; &lt;/div&gt;&lt;/template&gt; 效果图如下： 本地使用有时候网络不是那么给力的，或者是内网环境，那么就不要考虑用在线引用的方式了。 本地使用需要先将字体库下载并放到项目中。 在全局样式文件中定义如下代码 1234567891011121314151617@font-face { font-family: &quot;iconfont&quot;; src: url(&apos;../fonts/iconfont.eot&apos;); /* IE9*/ src: url(&apos;../fonts/iconfont.eot#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;../fonts/iconfont.woff&apos;) format(&apos;woff&apos;), /* chrome, firefox */ url(&apos;../fonts/iconfont.woff2&apos;) format(&apos;woff2&apos;), /* chrome, firefox */ url(&apos;../fonts/iconfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;../assets/fonts/iconfont.svg#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */}.iconfont { font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;} 使用方式 与在线引用方式是一样的，都是使用unicode码去展示图标。 123&lt;template&gt; &lt;i class=&quot;iconfont&quot;&gt;&amp;#xe7ee;&lt;/i&gt;&lt;/template&gt; 总结 兼容性最好，支持ie6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 Font class方式（较友好）一种更友好的封装，类似于font-awesome，我们只要使用class，就可以调用图标了。其原理就是利用before伪元素来显示图标。 在线使用超级简单，只要在线生成代码，引用在线的css文件即可使用。 在index.html中引用它。 1&lt;link rel=\"stylesheet\" href=\"//at.alicdn.com/t/font_1261797_48wm20jf8z.css\"&gt; 项目中就可以使用字体图标了。 1234&lt;template&gt; &lt;i class=\"iconfont cl-icon-fold\"&gt;&lt;/i&gt; &lt;i class=\"iconfont cl-icon-delete-solid\"&gt;&lt;/i&gt;&lt;/template&gt; 本地使用与unicode方式类似，下载代码到本地。因为我是用scss管理样式的，需要在下载的代码中提取出关键部分。除了引用字体库，还要将其中的iconfont.css中定义的before伪元素全部复制到自己的scss文件中。 12345678910111213141516171819202122232425262728293031323334@font-face { font-family: &quot;iconfont&quot;; src: url(&apos;../fonts/iconfont.eot&apos;); /* IE9*/ src: url(&apos;../fonts/iconfont.eot#iefix&apos;) format(&apos;embedded-opentype&apos;), /* IE6-IE8 */ url(&apos;../fonts/iconfont.woff&apos;) format(&apos;woff&apos;), /* chrome, firefox */ url(&apos;../fonts/iconfont.woff2&apos;) format(&apos;woff2&apos;), /* chrome, firefox */ url(&apos;../fonts/iconfont.ttf&apos;) format(&apos;truetype&apos;), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/ url(&apos;../assets/fonts/iconfont.svg#iconfont&apos;) format(&apos;svg&apos;); /* iOS 4.1- */}.iconfont { font-family: &quot;iconfont&quot; !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;}// 列了一部分举例.cl-icon-user:before { content: &quot;\\e64b&quot;;}.cl-icon-video:before { content: &quot;\\e66b&quot;;}.cl-icon-pause:before { content: &quot;\\e7bd&quot;;}.cl-icon-orgnazation:before { content: &quot;\\e61b&quot;;} 总结 兼容性良好，支持ie8+，及所有现代浏览器。 相比于unicode语意明确，书写更直观。可以很容易分辨这个icon是什么。 因为使用class来定义图标，所以当要替换图标时，只需要修改class里面的unicode引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 建议由于加了新的图标需要重新在iconfont.cn重新生成代码，所以这种方式也不算很方便，但是相对于unicode还是高级不少。根据我的经验，建议在调试时，不要每次图标更新，就下载到本地更换。应该先使用在线使用的方式，调试完毕确认无误后，再下载到本地使用，这样对于效率提升有很大帮助。 symbol方式（支持多色图标）svg的symbol提供了类似于雪碧图的功能，让svg的使用变得更简单，也可以满足做图标系统的需求。可以参考张大大博客了解更多关于svg symbol的知识。 在线使用首先在iconfont项目中选择symbol方式，并在线生成js代码 然后在index.html中引入这个js文件 1&lt;script src=\"//at.alicdn.com/t/font_1254715_oewlgci0ut.js\"&gt;&lt;/script&gt; 这个js的作用是在文档中生成svg symbol 最后就可以在页面中通过use标签使用svg图标了。xlink:href的值设置为对应的symbol的id即可。 123&lt;svg aria-hidden=\"true\"&gt; &lt;use xlink:href=\"#test-icon-word-ext\"&gt;&lt;/use&gt; &lt;/svg&gt; 效果如下： 多色图标还是酷！ 本地使用本地使用也是一样的道理，主要是依赖这个在线生成的js文件，将在线js文件的链接在浏览器空标签中打开，就可以得到其内容，然后复制内容，自己命名一个js文件，并把它放在本地项目静态资源目录下，引用即可。 1&lt;script src=\"./static/js/symbols.js\"&gt;&lt;/script&gt; 图标自动管理（必看）即使使用了symbol方式，当设计小姐姐新增图标时，我们还是无法避免重新生成图标代码。那么有没有更优雅的解决方案呢？答案是有的。svg-sprite-loader + require.context。 svg-sprite-loader网上已经有太多文章了。 关于require.context，我倒是有一点自己的理解。请查看一张图带你了解webpack的require.context。 总结 支持多色图标了，不再受单色限制。 支持丰富的css属性进行定制。 兼容性较差，支持 ie9+,及现代浏览器。 浏览器渲染svg的性能一般，还不如png。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/vue项目中引入iconfont.html"},{"title":"vue开发过程问题汇总记录","text":"这篇文章记录一下vue开发过程中遇到的一些问题及解决方案。 vue中static文件夹与assets文件夹区别简单的讲，static放别人家的，assets放自己写的。不知道这个解释是否OK，这里有一篇资料参考。 favicon显示不出来1&lt;link rel=\"icon\" href=\"assets/logo.png\" type=\"image/x-icon\"/&gt; index.html添加favicon后，显示不出来。调整href的路径，也是显示不不了。在网上找到两个方法：（1）使用static目录将favicon图片放在static目录下 12// 经测试，开发环境和生产环境都OK&lt;link rel=\"icon\" href=\"static/logo.png\" type=\"image/x-icon\"/&gt; （2）配置webpack不用在index.html中添加link标签，修改webpack的HtmlWebpackPlugin，添加配置项： 1favicon: 'logo.png' 我这里为了简单，直接复制的logo.png到src同级目录下。正式的应该是一个favicon.ico图标。 vue-devtools安装和使用（1）clone vue-devtools克隆的https链接为https://github.com/vuejs/vue-devtools（2）npm install在工具目录下安装依赖。（3）npm run build打包构建工具。（4）chrome添加扩展程序将shells&gt;chrome目录直接拖到扩展程序中。（5）在工具目录下运行npm run dev（6）在chrome调试vue项目时，打开开发者工具，有一项Vue的插件，即可用来调试Vue，非常方便。 vue中怎么使用scss语法首先，安装node-sass和sass-loader。 12npm install node-sass --save-devnpm install sass-loader --save-dev 然后，在vue文件中给style标签加上lang属性。 1&lt;style lang=\"scss\"&gt; vue-loader支持css预处理器，因此不需要额外写sass的loader了，所以我前面安装的sass-loader可能是多余的。 使用element-ui（1）安装：npm i element-ui -S（2）在 main.js 中引入： Updating…… 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/vue开发过程问题汇总记录.html"},{"title":"web网页加载圈之入门篇","text":"作为一名web开发者，或多或少都会接触到网页加载圈这个概念。一个网站的加载速度或快或慢，而慢的网页加载速度会给用户非常差的体验，这个时候如果不给用户一点提示信息，那简直糟糕透了。因此，常见的做法，是在页面加载完成之前，给一个过渡效果。那么怎么实现这种效果呢？ 如何知道网页加载完成DOM给我们提供了这样一个方法document.onreadystatechange。当一个文档的readyState属性发生更改时，readystatechange事件会被触发。document.readyState有两个值，interactive和complete。interactive状态表示文档已经完成加载，文档已被解析，但是诸如图像，样式表和框架之类的子资源仍在加载。complete状态则表示页面加载结束。那么我们可以在页面上写一个提示信息，当document.readyState变为complete状态就隐藏这个提示，这样就可以达到一个过渡的效果了。 文字提示效果我们从最简单的开始，可以给用户一个文字提示，比如“Loading…”。那么代码怎么写呢？ 绘制加载提示第一步，在body中绘制加载提示。 1&lt;div id=\"loading\"&gt;Loading...&lt;/div&gt; 第二步，给提示内容一个居中的样式效果。在style标签中写样式 1234567#loading { position: absolute; width: 50px; height: 50px; left: 50%; top: 50%;} 打开该html页面，我们可以看到初步的效果。 根据状态隐藏提示利用document.onreadystatechange方法监听页面加载状态，当document.readyState变为complete状态就隐藏加载提示。加入script标签，写入以下代码。 123456document.onreadystatechange = () =&gt; { if (document.readyState === 'complete') { var loadingElement = document.getElementById('loading'); loadingElement.parentNode.removeChild(loadingElement); }}; 刷新html页面，我们可以看到，当页面加载完成时，提示内容自动消失了。（由于资源缓存的关系，第二次的效果不会太明显，可以清空缓存观察效果。） 图片加载效果网上有很多加载圈的gif图片，将上述文字内容换成gif图片就可以做到。也可以使用静态图片，然后通过css3动画来做一些加载效果，如rotate旋转。 1234567891011121314#loading { position: absolute; width: 50px; height: 50px; left: 50%; top: 50%; background: url(loading.jpg) center center no-repeat; background-size: 100% 100%; animation: rotate 1.5s ease-out infinite;}@keyframes rotate { 0% { transform: rotate(0deg);} 100% { transform: rotate(360deg);}} css3自定义加载效果其实我们可以利用CSS3自定义加载效果，把我们想要的效果通过动画做出来即可。下面我们来实现一个圆弧加载效果。只要将背景图换成box-shadow效果即可。 123border-radius: 50%;box-shadow: 2px 0 black;animation: rotate 1.5s ease-out infinite; 这是我做的加载圈的效果页面，请点击查看。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/web网页加载圈之入门篇.html"},{"title":"webpack4平滑升级","text":"最近有感觉到，随着系统模块数量的增加，wepack编译打包的速度越来越慢，于是我想给项目做一下优化升级，也借此机会系统地学习一下webpack4。 升级过程当前版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566\"dependencies\": { \"@fullcalendar/core\": \"^4.2.0\", \"@fullcalendar/daygrid\": \"^4.2.0\", \"@fullcalendar/interaction\": \"^4.2.0\", \"@fullcalendar/vue\": \"^4.2.2\", \"axios\": \"0.18.1\", \"babel-polyfill\": \"6.26.0\", \"echarts\": \"4.0.4\", \"element-ui\": \"2.10.0\", \"jquery\": \"3.3.1\", \"js-cookie\": \"2.2.0\", \"js-md5\": \"0.7.3\", \"lodash\": \"4.17.5\", \"moment\": \"^2.24.0\", \"node-sass\": \"^4.11.0\", \"normalize.css\": \"7.0.0\", \"nprogress\": \"0.2.0\", \"qs\": \"6.5.1\", \"vue\": \"2.6.10\", \"vue-router\": \"3.0.3\", \"vuex\": \"3.1.1\"},\"devDependencies\": { \"autoprefixer\": \"7.2.3\", \"babel-core\": \"6.26.0\", \"babel-eslint\": \"8.0.3\", \"babel-helper-vue-jsx-merge-props\": \"2.0.3\", \"babel-loader\": \"7.1.2\", \"babel-plugin-syntax-jsx\": \"6.18.0\", \"babel-plugin-transform-runtime\": \"6.23.0\", \"babel-plugin-transform-vue-jsx\": \"3.7.0\", \"babel-preset-env\": \"1.6.1\", \"babel-preset-stage-2\": \"6.24.1\", \"chalk\": \"2.3.0\", \"copy-webpack-plugin\": \"4.2.3\", \"css-loader\": \"0.28.7\", \"eslint\": \"4.13.1\", \"eslint-friendly-formatter\": \"3.0.0\", \"eslint-loader\": \"1.9.0\", \"eslint-plugin-html\": \"4.0.1\", \"eventsource-polyfill\": \"0.9.6\", \"extract-text-webpack-plugin\": \"3.0.2\", \"file-loader\": \"1.1.5\", \"friendly-errors-webpack-plugin\": \"1.6.1\", \"html-webpack-plugin\": \"2.30.1\", \"node-notifier\": \"5.1.2\", \"optimize-css-assets-webpack-plugin\": \"3.2.0\", \"ora\": \"1.3.0\", \"portfinder\": \"1.0.13\", \"postcss-import\": \"11.0.0\", \"postcss-loader\": \"2.0.9\", \"rimraf\": \"2.6.2\", \"sass-loader\": \"6.0.6\", \"semver\": \"5.4.1\", \"shelljs\": \"0.7.8\", \"svg-sprite-loader\": \"4.1.6\", \"uglifyjs-webpack-plugin\": \"1.1.3\", \"url-loader\": \"0.6.2\", \"vue-loader\": \"15.7.0\", \"vue-style-loader\": \"4.1.2\", \"vue-template-compiler\": \"2.6.10\", \"webpack\": \"3.10.0\", \"webpack-bundle-analyzer\": \"2.9.1\", \"webpack-dev-server\": \"2.9.7\", \"webpack-merge\": \"4.1.1\"} 目标版本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768\"dependencies\": { \"@fullcalendar/core\": \"^4.2.0\", \"@fullcalendar/daygrid\": \"^4.2.0\", \"@fullcalendar/interaction\": \"^4.2.0\", \"@fullcalendar/vue\": \"^4.2.2\", \"axios\": \"0.18.1\", \"babel-polyfill\": \"6.26.0\", \"echarts\": \"4.0.4\", \"element-ui\": \"2.10.0\", \"jquery\": \"3.3.1\", \"js-cookie\": \"2.2.0\", \"js-md5\": \"0.7.3\", \"lodash\": \"4.17.5\", \"moment\": \"^2.24.0\", \"node-sass\": \"^4.11.0\", \"normalize.css\": \"7.0.0\", \"nprogress\": \"0.2.0\", \"qs\": \"6.5.1\", \"vue\": \"2.6.10\", \"vue-router\": \"3.0.3\", \"vuex\": \"3.1.1\"},\"devDependencies\": { \"autoprefixer\": \"9.6.1\", \"babel-core\": \"6.26.3\", \"babel-eslint\": \"10.0.3\", \"babel-helper-vue-jsx-merge-props\": \"2.0.3\", \"babel-loader\": \"^7.1.5\", \"babel-plugin-syntax-jsx\": \"6.18.0\", \"babel-plugin-transform-runtime\": \"6.23.0\", \"babel-plugin-transform-vue-jsx\": \"3.7.0\", \"babel-preset-env\": \"1.7.0\", \"babel-preset-stage-2\": \"6.24.1\", \"chalk\": \"2.4.2\", \"copy-webpack-plugin\": \"5.0.4\", \"css-loader\": \"3.2.0\", \"eslint\": \"6.3.0\", \"eslint-friendly-formatter\": \"3.0.0\", \"eslint-import-resolver-webpack\": \"^0.11.1\", \"eslint-loader\": \"3.0.0\", \"eslint-plugin-vue\": \"^5.2.3\", \"eventsource-polyfill\": \"0.9.6\", \"file-loader\": \"4.2.0\", \"friendly-errors-webpack-plugin\": \"1.7.0\", \"html-webpack-plugin\": \"3.2.0\", \"mini-css-extract-plugin\": \"^0.8.0\", \"node-notifier\": \"5.1.2\", \"optimize-css-assets-webpack-plugin\": \"3.2.0\", \"ora\": \"1.3.0\", \"portfinder\": \"1.0.13\", \"postcss-import\": \"12.0.1\", \"postcss-loader\": \"3.0.0\", \"rimraf\": \"2.6.2\", \"sass-loader\": \"8.0.0\", \"semver\": \"5.4.1\", \"shelljs\": \"0.7.8\", \"svg-sprite-loader\": \"4.1.6\", \"uglifyjs-webpack-plugin\": \"2.2.0\", \"url-loader\": \"2.1.0\", \"vue-loader\": \"15.7.1\", \"vue-style-loader\": \"4.1.2\", \"vue-template-compiler\": \"2.6.10\", \"webpack\": \"4.39.3\", \"webpack-bundle-analyzer\": \"3.4.1\", \"webpack-cli\": \"^3.3.8\", \"webpack-dev-server\": \"3.8.0\", \"webpack-merge\": \"4.2.2\"} 第一步升级webpack到4.39.3版本，npm run dev遇到了报错…… npm run dev报错webpack-dev-server版本过低1Error: Cannot find module 'webpack/bin/config-yargs' 应该是webpack与webpack-dev-server版本不符，于是升级webpack-dev-server到3.8.0版本。 webpack-cli缺失123456789The CLI moved into a separate package: webpack-cliPlease install 'webpack-cli' in addition to webpack itself to use the CLI-&gt; When using npm: npm i -D webpack-cli-&gt; When using yarn: yarn add -D webpack-cliinternal/modules/cjs/loader.js:584 throw err; ^Error: Cannot find module 'webpack-cli/bin/config-yargs' webpack4将webpack-cli单独分离出来了，因此提示我们安装webpack-cli，那就直接安装吧。 html-webpack-plugin版本问题123456710% building 2/2 modules 0 active(node:8596) DeprecationWarning: Tapable.plugin is deprecated. Use new API on `.hooks` instead(node:8596) DeprecationWarning: Tapable.apply is deprecated. Call apply on the plugin directly instead53% building 363/366 modules 3 active D:\\coollu\\projects\\coollu-v3\\source-code\\develop\\coollu-cloud-web\\node_modules\\core-js\\modules\\_array-reduce.jsD:\\coollu\\projects\\coollu-v3\\source-code\\develop\\coollu-cloud-web\\node_modules\\html-webpack-plugin\\lib\\compiler.js:81 var outputName = compilation.mainTemplate.applyPluginsWaterfall(&apos;asset-path&apos;, outputOptions.filename, { ^TypeError: compilation.mainTemplate.applyPluginsWaterfall is not a function 考虑是html-webpack-plugin版本问题，升级至3.2.0 extract-text-webpack-plugin?110% building 2/2 modules 0 active(node:19732) DeprecationWarning: Tapable.plugin is deprecated. Use new API on `.hooks` instead 查到是因为extract-text-webpack-plugin不再支持webpack4.3，需要改用mini-css-extract-plugin。 ps: extract-text-webpack-plugin是用来抽取依赖的.css文件的，防止样式全部打包在js bundle里太大。改用了mini-css-extract-plugin后，该报错并未消除，考虑要用compiler钩子重写一些东西，先在这埋个坑，后面弄明白了再来填坑。 eslint-loader升版本123Module build failed (from ./node_modules/eslint-loader/index.js):TypeError: Cannot read property &apos;eslint&apos; of undefined at Object.module.exports (D:\\coollu\\projects\\coollu-v3\\source-code\\develop\\coollu-cloud-web\\node_modules\\eslint-loader\\index.js:148:18) 升级eslint-loader file-loader升版本123Module build failed (from ./node_modules/file-loader/dist/cjs.js):TypeError: Cannot read property &apos;context&apos; of undefined at Object.loader (D:\\coollu\\projects\\coollu-v3\\source-code\\develop\\coollu-cloud-web\\node_modules\\file-loader\\dist\\index.js:34:49) 升级file-loader npm run build报错改用splitChunks1webpack.optimize.CommonsChunkPlugin has been removed, please use config.optimization.splitChunks instead. 使用webpack4的optimization.splitChunks替代CommonsChunkPlugin vue-loader升版本123456ERROR in ./src/App.vue?vue&amp;type=style&amp;index=0&amp;id=7c362b6c&amp;lang=scss&amp;scoped=tr (./node_modules/mini-css-extract-plugin/dist/loader.js??ref--10-0!./node_mods/vue-loader/lib??vue-loader-options!./src/App.vue?vue&amp;type=style&amp;index=0&amp;id=62b6c&amp;lang=scss&amp;scoped=true&amp;)Module build failed (from ./node_modules/mini-css-extract-plugin/dist/loader.:ModuleParseError: Module parse failed: Unexpected character &apos;#&apos; (14:0)File was processed with these loaders: * ./node_modules/vue-loader/lib/index.jsYou may need an additional loader to handle the result of these loaders. 考虑是vue-loader版本问题，先升级vue-loader@15.7.1 babel-loader降版本1234ERROR in ./src/main.jsModule build failed (from ./node_modules/babel-loader/lib/index.js):Error: Cannot find module &apos;@babel/core&apos; babel-loader@8 requires Babel 7.x (the package &apos;@babel/core&apos;). If you&apos;d like to use Babel 6.x (&apos;babel-core&apos;), you should install &apos;babel-loader@7&apos;. 把babel-loader@8降低了版本，调整为babel-loader@7 ps: 想了一下，觉得可能其他的loader版本也会过低，于是将其他的loader都进行了升级，具体见package.json。 优化打包速度happypack一个号称用多进程策略提升webpack打包速度的插件，真的挺管用的。 happypack允许您并行转换多个文件，从而加快了webpack的构建速度。 安装： 1npm install --save-dev happypack 简单配置如下： 12345678910111213141516171819202122232425const HappyPack = require('happypack')// webpack配置，只列出关于happypack的配置rules: [ // ...其他rule { test: /\\.js$/, // 注释掉原来的babel-loader，改用happypack/loader // loader: \"babel-loader\", use: ['happypack/loader'], include: [ resolve(\"src\") ] }],plugins: [ // ...其他plugin // 安装说明简单配置了一下 new HappyPack({ // 将我们刚才注释的loader放在这，告诉happypack loaders: ['babel-loader'], // 开启4个子进程，据说是最优解 threads: 4 })] 总结经过大量npm包版本的调整，以及webpack配置的修改（主要是optimization的调整；把extract-text-webpack-plugin换成了mini-css-extract-plugin；加入了happypack），报错基本上消除了，经测试，dev和prod环境都没有功能上的问题，热加载，编译，打包速度确实得到了显著提升。 热加载 速度得到了显著提升，之前改一行代码，热加载编译的时间差不多要花1min，让人难受；优化后，基本上控制在&lt;=5s webpack升级前打包： 123Hash: 35f207120dd3736758ddVersion: webpack 3.10.0Time: 95987ms 大概需要96s的打包时间。 webpack升级后打包： 123Hash: fb73468076752cad58f6Version: webpack 4.39.3Time: 61597ms 打包时间降低到61.6s，节约了34.4s，打包效率提升了35.8%以上。 使用happypack后： 12345Happy[1]: Version: 5.0.1. Threads: 4Happy[1]: All set; signaling webpack to proceed.Hash: a635e8b39b7064adf41cVersion: webpack 4.39.3Time: 41047ms 打包时间降低到41s，再次节约了20.6s！总共节约了55s，与升级前相比，打包效率提升了57%以上。 当然可优化的空间还很大，webpack4还有很多东西值得我们去折腾，优化之路还在继续！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/webpack4平滑升级.html"},{"title":"web网页加载圈之进阶篇","text":"做完简单的加载效果后，相信大家也想接着做一些更为复杂的效果。我也是这么想的。很多网页的加载动画都是由很多帧组成的，要做到这种效果也不难，说到底就是看你拆分动画的思路。下面讲一个简单的例子。 从左到右循序渐进的加载效果一个典型的动画加载效果就是，从左到右循序渐进的圆点加载。效果如下：那么怎么来实现这种效果呢？ 绘制n个圆点我这里绘制了6个圆点，相信画圆点应该难不倒各位。 12border-radius: 50%;background-color: gray; 如何做圆点的动画效果我这里采用的方案是背景色变化，每个圆点的颜色按照顺序依次由灰色变为红色。那么具体怎么做呢？ 定义关键帧这里先定义关键动画帧，描述背景色的变化过程。 1234@keyframes highlightBack { 0% { background-color: gray; } 100% { background-color: red; }} 应用动画使用animation属性来应用highlightBack，并给到0.2s的一个动画时间。 123.loading-animate { animation: highlightBack 0.2s ease forwards;} 设计动画过渡效果我需要圆点的颜色一个个变化，那么执行动画的时间点就必须不一样。因此我给了每一个圆点不一样的animation-delay值。 1234// 比如第二个圆点，我给它的动画时延是0.2s，相当于第一个圆点的动画执行完了，才执行第二个圆点的动画。.loading-point:nth-child(2) { animation-delay: 0.2s;} 一轮动画结束后怎么重新开始页面加载的时间或长或短，不可能动画只执行一轮就结束了。所以我们需要让一轮动画结束后，接着开始第二轮的动画。具体怎么做呢？我们可以监听最后一个圆点的动画结束事件animationend，然后在回调函数中移除动画类，经过短暂的延时后，重新添加动画类即可做到。 123456789101112// 关键代码document.getElementById('last').addEventListener('animationend', () =&gt; { var points = document.getElementsByClassName('loading-point'); for (var i = 0; i &lt; points.length; i++) { points[i].classList.remove('loading-animate'); } setTimeout(() =&gt; { for (var i = 0; i &lt; points.length; i++) { points[i].classList.add('loading-animate'); } }, 500);}); 根据状态隐藏圆点这个跟上文说的是一样的，当document.readyState的值为complete时，隐藏圆点。点击参考上文。到此就完成了整个效果，点击查看效果页面。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/web网页加载圈之进阶篇.html"},{"title":"windows系统下安装mysql8.0","text":"下载mysql进入到官网下载页面，下载免费的社区版就可以了。本人一开始下载了installer，安装卸载了两次，可能是使用不当吧，遇到了很多坑，最终选择了下载zip版本。 ) 如何安装使用将下载的zip压缩包解压到D:\\Program Files\\MySQL目录下，创建my.ini配置文件 123456789101112131415161718192021222324[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\\Program Files\\MySQL# 设置mysql数据库的数据的存放目录datadir=D:\\Program Files\\MySQL\\data# 允许最大连接数max_connections=200# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 然后在bin目录下依次运行以下命令 12mysqld --installmysqld --initialize 会得到一个初始的密码，如kh5sN)zd=fsw。 还要配置一下环境变量，在PATH后追加以下内容 1;D:\\Program Files\\MySQL\\bin 接着运行net start mysql，可以看到启动mysql服务已经成功。 测试root账号运行登录命令 1mysql -u root -p 输入密码后登录成功。 接着输入数据库查询语句，随便输什么都报一个错。比如show databases，use mysql等。 You must reset your password using ALTER USER statement before executing this statement. 上网查了一下后，说是密码过期了，需要修改，我就纳闷了，刚初始化得到的密码就过期了。。。 不说了，运行这个命令，修改一下root的密码。 1alter user user() identified by &quot;123456&quot;; 修改后，就可以正常访问使用mysql数据库了。 2018.8.7 今天在win10上按照以上步骤安装时，遇到了一个问题。运行net start mysql时报错 123发生系统错误 2。系统找不到指定的文件。 解决方案：打开注册表，找到 HKEY_LOCAL_MACHINE -&gt; SYSTEM -&gt; CurrentControlSet -? services -&gt; mysql -&gt; ImagePath 发现这个值是C盘下的某路径，跟我放在D盘的MySQL目录不符。 需要修改成 1&quot;D:\\Program Files\\MySQL\\bin\\mysqld&quot; MySQL 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/windows系统下安装mysql8-0.html"},{"title":"一张图带你了解webpack的require.context","text":"很多人应该像我一样，对于webpack的require.context都是一知半解吧。网上很多关于require.context的使用案例，但是我没找到可以帮助我理解这个知识点的，于是也决定自己来探索一下。下面以网上流行的svg图标方案为例说明。对了，本文的重点是require.context，并不会去解释svg symbol方案svg-sprite-loader。 关键代码 src/icons/index.js 123const context = require.context(\"./svg\", true, /\\.svg$/)context.keys().map(context) main.js 1import '@/icons' webpack.base.config.js 1234567891011121314151617{ test: /\\.svg$/, loader: \"svg-sprite-loader\", include: [resolve(\"src/icons\")], options: { symbolId: \"icon-[name]\" }},{ test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: \"url-loader\", exclude: [resolve(\"src/icons\")], options: { limit: 10000, name: utils.assetsPath(\"img/[name].[hash:7].[ext]\") }}, why? 很多人跟我一样，一开始只想说，为什么这样就可以，why??? 要知道是什么，就上打印大法。 12345const context = require.context(\"./svg\", true, /\\.svg$/)// 看看你是何方神圣console.log(context)context.keys().map(context) 下面就真的以一张图进行解释，有问题的欢迎留言交流呀！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/一张图带你了解webpack的require-context.html"},{"title":"「思维导图学前端 」6k字一文搞懂Javascript对象，原型，继承","text":"前言去年开始我给自己画了一张知识体系的思维导图，用于规划自己的学习范围和方向。但是我犯了一个大错，我的思维导图只是一个全局的蓝图，而在学习某个知识点的时候没有系统化，知识太过于零散，另一方面也很容易遗忘，回头复习时没有一个提纲，整体的学习效率不高。意识到这一点，我最近开始用思维导图去学习和总结具体的知识点，效果还不错。 试想一下，一张思维导图的某个端点是另一张思维导图，这样串起来的知识链条是多么“酸爽”！当然，YY一下就好了，我保证你没有足够的时间给所有知识点都画上思维导图，挑重点即可。 提纲思路当我们要研究一个问题或者知识点时，关注点无非是： 是什么？ 做什么？ 为什么？ 很明显，搞懂“是什么”是最最基础的，而这部分却很重要。万丈高楼平地起，如果连基础都不清楚，何谈应用实践（“做什么”），更加也不会理解问题的本质（“为什么”）。 而要整理一篇高质量的思维导图，必须充分利用“总-分”的思路，首先要形成一个基本的提纲，然后从各个方面去延伸拓展，最后得到一棵较为完整的知识树。分解知识点后，在细究的过程中，你可能还会惊喜地发现一个知识点的各个组成部分之间的关联，对知识点有一个更为饱满的认识。 梳理提纲需要对知识点有一个整体的认识。如果是学习比较陌生的领域知识，我的策略是从相关书籍或官方文档的目录中提炼出提纲。 下面以我复习javascript对象这块知识时的一些思路为例说明。 javascript对象在复习javascript对象这块知识时，我从过往的一些使用经验，书籍，文档资料中提炼出了这么几个方面作为提纲，分别是： 对象的分类 对象的三个重要概念：类，原型，实例 创建对象的方法 对象属性的访问和设置 原型和继承 静态方法和原型方法 由此展开得到了这样一个思维导图： 对象的分类对象主要分为这么三大类： 内置对象：ECMAScript规范中定义的类或对象，比如Object, Array, Date等。 宿主对象：由javascript解释器所嵌入的宿主环境提供。比如浏览器环境会提供window，HTMLElement等浏览器特有的宿主对象。Nodejs会提供global全局对象 自定义对象：由javascript开发者自行创建的对象，用以实现特定业务。就比如我们熟悉的Vue，它就是一个自定义对象。我们可以对Vue这个对象进行实例化，用于生成基于Vue的应用。 对象的三个重要概念类javascript在ES6之前没有class关键字，但这不影响javascript可以实现面向对象编程，javascript的类名对应构造函数名。 在ES6之前，如果我们要定义一个类，其实是借助函数来实现的。 123456789function Person(name) { this.name = name;}Person.prototype.sayHello = function() { console.log(this.name + ': hello!');}var person = new Person('Faker');person.sayHello(); ES6明确定义了class关键字。 123456789101112class Person { constructor(name) { this.name = name; } sayHello() { console.log(this.name + ': hello!'); }}var person = new Person('Faker');person.sayHello(); 原型原型是类的核心，用于定义类的属性和方法，这些属性和方法会被实例继承。 定义原型属性和方法需要用到构造函数的prototype属性，通过prototype属性可以获取到原型对象的引用，然后就可以扩展原型对象了。 1234567function Person(name) { this.name = name;}Person.prototype.sexList = ['man', 'woman'];Person.prototype.sayHello = function() { console.log(this.name + ': hello!');} 实例类是抽象的概念，相当于一个模板，而实例是类的具体表现。就比如Person是一个类，而根据Person类，我们可以实例化多个对象，可能有小明，小红，小王等等，类的实例都是一个个独立的个体，但是他们都有共同的原型。 12345var xiaoMing = new Person('小明');var xiaoHong = new Person('小红');// 拥有同一个原型Object.getPrototypeOf(xiaoMing) === Object.getPrototypeOf(xiaoHong); // true 如何创建对象对象直接量对象直接量也称为对象字面量。直接量就是不需要实例化，直接写键值对即可创建对象，堪称“简单粗暴”。 1var xiaoMing = { name: '小明' }; 每写一个对象直接量相当于创建了一个新的对象。即使两个对象直接量看起来一模一样，它们指向的堆内存地址也是不一样的，而对象是按引用访问的，所以这两个对象是不相等的。 123var xiaoMing1 = { name: '小明' };var xiaoMing2 = { name: '小明' };xiaoMing1 === xiaoMing2; // false new 构造函数可以通过关键词new调用javascript对象的构造函数来获得对象实例。比如： 创建内置对象实例 1var o = new Object(); 创建自定义对象实例 1234function Person(name) { this.name = name;};new Person('Faker'); Object.createObject.create用于创建一个对象，接受两个参数，使用语法如下； 1Object.create(proto[, propertiesObject]); 第一个参数proto用于指定新创建对象的原型； 第二个参数propertiesObject是新创建对象的属性名及属性描述符组成的对象。 proto可以指定为null，但是意味着新对象的原型是null，它不会继承Object的方法，比如toString()等。 propertiesObject参数与Object.defineProperties方法的第二个参数格式相同。 12345678910111213141516var o = Object.create(Object.prototype, { // foo会成为所创建对象的数据属性 foo: { writable:true, configurable:true, value: \"hello\" }, // bar会成为所创建对象的访问器属性 bar: { configurable: false, get: function() { return 10 }, set: function(value) { console.log(\"Setting o.bar to\", value); } }}); 属性查询和设置属性查询属性查询也可以称为属性访问。在javascript中，对象属性查询非常灵活，支持点号查询，也支持字符串索引查询（之所以说是“字符串索引”，是因为写法看起像数组，索引是字符串而不是数字）。 通过点号加属性名访问属性的行为很像一些静态类型语言，如java，C等。属性名是javascript标识符，必须直接写在属性访问表达式中，不能动态访问。 12var o = { name: '小明' };o.name; // \"小明\" 而根据字符串索引查询对象属性就比较灵活了，属性名就是字符串表达式的值，而一个表达式是可以接受变量的，这意味着可以动态访问属性，这赋予了javascript程序员很大的灵活性。下面是一个很简单的示例，而这种特性在业务实践中作用很大，比如深拷贝的实现，你往往不知道你要拷贝的对象中有哪些属性。 12345var o = { chineseName: '小明', englishName: 'XiaoMing' };['chinese', 'english'].forEach(lang =&gt; { var property = lang + 'Name'; console.log(o[property]); // 这里使用了字符串索引访问对象属性}) 对了，属性查询不仅可以查询自由属性，也可以查询继承属性。 123var protoObj = { age: 18 };var o = Object.create(protoObj);o.age; // 18，这里访问的是原型属性，也就是继承得到的属性 属性设置通过属性访问表达式，我们可以得到属性的引用，就可以据此设置属性了。这里主要注意一下只读属性和继承属性即可，细节不再展开。 原型和继承原型前面也提到了，原型是实现继承的基础。那么如何去理解原型呢？ 首先，要明确原型概念中的三角关系，三个主角分别是构造函数，原型，实例。我这里画了一张比较简单的图来帮助理解下。 原型这东西吧，我感觉“没人能帮你理解，只有你自己去试过才是懂了”。 不过这里说说我刚学习原型时的疑惑，疑惑的是为什么构造函数有属性prototype指向原型，而实例又可以通过__proto__指向原型，究竟prototype和__proto__谁是原型？其实这明显是没有理解对象是按引用访问这个特点了。原型对象永远只有一个，它存储于堆内存中，而构造函数的prototype属性只是获得了原型的引用，通过这个引用可以操作原型。 同样地，__proto__也只是原型的引用，但是要注意了，__proto__不是ECMAScript规范里的东西，所以千万不要用在生产环境中。 至于为什么不可以通过__proto__访问原型，原因也很简单。通过实例直接获得了原型的访问和修改权限，这本身是一件很危险的事情。 举个例子，这里有一个类LatinDancer，意思是拉丁舞者。经过实例化操作，得到了多个拉丁舞者。 12345678910111213function LatinDancer(name) { this.name = name;};LatinDancer.prototype.dance = function() { console.log(this.name + '跳拉丁舞...');}var dancer1 = new LatinDancer('小明');var dancer2 = new LatinDancer('小红');var dancer3 = new LatinDancer('小王');dancer1.dance(); // 小明跳拉丁舞...dancer2.dance(); // 小红跳拉丁舞...dancer3.dance(); // 小王跳拉丁舞... 大家欢快地跳着拉丁舞，突然小王这个家伙心血来潮，说：“我要做b-boy，我要跳Breaking”。于是，他私下改了原型方法dance()。 1234567dancer3.__proto__.dance = function() { console.log(this.name + &apos;跳breaking...&apos;);}dancer1.dance(); // 小明跳breaking...dancer2.dance(); // 小红跳breaking...dancer3.dance(); // 小王跳breaking... 这个时候就不对劲了，小明和小红正跳着拉丁，突然身体不受控制了，跳起了Breaking，心里暗骂：“沃尼玛，劳资不是跳拉丁的吗？” 这里只是举个例子哈，没有对任何舞种或者舞者不敬的意思，抱歉抱歉。 所以，大家应该也明白了为什么不能使用__proto__了吧。 原型链在javascript中，任何对象都有原型，除了Object.prototype，它没有原型，或者说它的原型是null。 那么什么是原型链呢？javascript程序在查找一个对象的属性或方法时，会首先在对象本身上进行查找，如果找不到则会去对象的原型上进行查找。按照这样一个递归关系，如果原型上找不到，就会到原型的原型上找，这样一直查找下去，就会形成一个链，它的终点是null。 还要注意的一点是，构造函数也是一个对象，也存在原型，它的原型可以通过Function.prototype获得，而Function.prototype的原型则可以通过Object.prototype获得。 继承说到继承，可能大家脑子里已经冒出来“原型链继承”，“借用构造函数继承”，“寄生式继承”，“原型式继承”，“寄生组合继承”这些概念了吧。说实话，一开始我也是这么记忆，但是发现好像不是那么容易理解啊。最后，我发现，只要从原型三角关系入手，就能理清实现继承的思路。 我们知道，对象实例能访问的属性和方法一共有三个来源，分别是：调用构造函数时挂载到实例上的属性，原型属性，对象实例化后自身新增的属性。 很明显，第三个来源不是用来做继承的，那么前两个来源用来做继承分别有什么优缺点呢？很明显，如果只基于其中一种来源做继承，都不可能全面地继承来自父类的属性或方法。 首先明确下继承中三个主体：父类，子类，子类实例。那么怎么才能让子类实例和父类搭上关系呢？ 原型链继承所谓继承，简单说就是能通过子类实例访问父类的属性和方法。而利用原型链可以达成这样的目的，所以只要父类原型、子类原型、子类实例形成原型链关系即可。 代码示例： 1234567891011function Father() { this.nationality = 'Han';};Father.prototype.propA = '我是父类原型上的属性';function Child() {};Child.prototype = new Father();Child.prototype.constructor = Child; // 修正原型上的constructor属性Child.prototype.propB = '我是子类原型上的属性';var child = new Child();console.log(child.propA, child.propB, child.nationality); // 都可以访问到child instanceof Father; // true 可以看到，在上述代码中，我们做了这样一个特殊处理Child.prototype.constructor = Child;。一方面是为了保证constructor的指向正确，毕竟实例由子类实例化得来，如果constructor指向父类构造函数也不太合适吧。另一方面是为了防止某些方法显示调用constructor时带来的麻烦。具体解释见Why is it necessary to set the prototype constructor? 关键点：让子类原型成为父类的实例，子类实例也是父类的实例。 缺点：实例化时无法向父类构造函数传参。 借用构造函数在调用子类构造函数时，通过call调用父类构造函数，同时指定this值。 12345678910function Father() { this.nationality = 'Han';};Father.prototype.propA = '我是父类原型上的属性';function Child() { Father.call(this);};Child.prototype.propB = '我是子类原型上的属性';var child = new Child();console.log(child.propA, child.propB, child.nationality); 这里的child.propA是undefined，因为子类实例不是父类的实例，无法继承父类原型属性。 1child instanceof Father; // false 关键点：构造函数的复用。 缺点：子类实例不是父类的实例，无法继承父类原型属性。 组合继承所谓组合继承，就是综合上述两种方法。实现代码如下： 123456789101112function Father() { this.nationality = 'Han';};Father.prototype.propA = '我是父类原型上的属性';function Child() { Father.call(this);};Child.prototype = new Father();Child.prototype.constructor = Child; // 修正原型上的constructor属性Child.prototype.propB = '我是子类原型上的属性';var child = new Child();console.log(child.propA, child.propB, child.nationality); // 都能访问到 一眼看上去没什么问题，但是Father()构造函数其实是被调用了两次的。第一次发生在Child.prototype = new Father();，此时子类原型成为了父类实例，执行父类构造函数Father()时，获得了实例属性nationality；第二次发生在var child = new Child();，此时执行子类构造函数Child()，而Child()中通过call()调用了父类构造函数，所以子类实例也获得了实例属性nationality。这样理解起来可能有点晦涩难懂，我们可以看看子类实例的对象结构： 可以看到，子类实例和子类原型上都挂载了执行父类构造函数时获得的属性nationality。然而我们做继承的目的是很单纯的，即“让子类继承父类属性和方法”，但并不应该给子类原型挂载不必要的属性而导致污染子类原型。 有人会说“这么一点副作用怕什么”。当然，对于这么简单的父类而言，这种副作用微乎其微。假设父类有几百个属性或方法呢，这种白白耗费性能和内存的行为是有必要的吗？答案显而易见。 关键点：实例属性和原型属性都得以继承。 缺点：父类构造函数被执行了两次，污染了子类原型。 原型式继承原型式继承是相对于原型链继承而言的，与原型链继承的不同点在于，子类原型在创建时，不会执行父类构造函数，是一个纯粹的空对象。 1234567891011function Father() { this.nationality = 'Han';};Father.prototype.propA = '我是父类原型上的属性';function Child() {};Child.prototype = Object.create(Father.prototype);Child.prototype.constructor = Child; // 修正原型上的constructor属性Child.prototype.propB = '我是子类原型上的属性';var child = new Child();console.log(child.propA, child.propB, child.nationality); // 都可以访问到child instanceof Father; // true 在ES5之前，可以这样模拟Object.create： 12345function create(proto) { function F() {} F.prototype = proto; return new F();} 关键点：利用一个空对象过渡，解除子类原型和父类构造函数的强关联关系。这也意味着继承可以是纯对象之间的继承，无需构造函数介入。 缺点：实例化时无法向父类构造函数传参，这一点和原型链继承并无差异。 寄生式继承寄生式继承有借鉴工厂函数的设计模式，将继承的过程封装到一个函数中并返回对象，并且可以在函数中扩展对象方法或属性。 1234567891011var obj = { nationality: 'Han'};function inherit(proto) { var o = Object.create(proto); o.extendFunc = function(a, b) { return a + b; } return o;}var inheritObj = inherit(obj); 这里inheritObj不仅继承了obj，而且也扩展了extendFunc方法。 关键点：工厂函数，封装过程函数化。 缺点：如果在工厂函数中扩展对象属性或方法，无法得到复用。 寄生组合继承用以解决组合继承过程中存在的“父类构造函数多次被调用”问题。 12345678910111213141516function inherit(childType, fatherType) { childType.prototype = Object.create(fatherType.prototype); childType.prototype.constructor = childType;}function Father() { this.nationality = 'Han';}Father.prototype.propA = '我是父类原型上的属性';function Child() { Father.call(this)}inherit(Child, Father); // 继承Child.prototype.propB = '我是子类原型上的属性';var child = new Child();console.log(child); 关键点：解决父类构造函数多次执行的问题，同时让子类原型变得更加纯粹。 静态方法何谓“静态方法”？静态方法为类所有，不归属于任何一个实例，需要通过类名直接调用。 12345function Child() {}Child.staticMethod = function() { console.log(\"我是一个静态方法\") }var child = new Child();Child.staticMethod(); // \"我是一个静态方法\"child.staticMethod(); // Uncaught TypeError: child.staticMethod is not a function Object类有很多的静态方法，我学习的时候习惯把它们分为这么几类（当然，这里没有全部列举开来，只挑了常见的方法）。 创建和复制对象 Object.create()：基于原型和属性描述符集合创建一个新对象。 Object.assign()：合并多个对象，会影响源对象。所以在合并对象时，为了避免这个问题，一般会这样做： 1var mergedObj = Object.assign({}, a, b); 属性相关 Object.defineProperty：通过属性描述符来定义或修改对象属性，主要涉及value, configurable, writable, enumerable四个特性。 Object.defineProperties：是defineProperty的升级版本，一次性定义或修改多个属性。 Object.getOwnPropertyDescriptor：获取属性描述符，是一个对象，包含value, configurable, writable, enumerable四个特性。 Object.getOwnPropertyNames：返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组。 Object.keys：会返回一个由一个给定对象的自身可枚举属性组成的数组，与getOwnPropertyNames最大的不同点在于：keys只返回enumerable为true的属性，并且会返回原型对象上的属性。 原型相关 Object.getPrototypeOf：返回指定对象的原型。 123function Child() {}var child = new Child();Object.getPrototypeOf(child) === Child.prototype; // true Object.setPrototypeOf：设置指定对象的原型。这是一个比较危险的动作，同时也是一个性能不佳的方法，不推荐使用。 行为控制以下列举的这三个方式是一个递进的关系，我们按序来看： Object.preventExtensions：让一个对象变的不可扩展，也就是永远不能再添加新的属性。 Object.seal：封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。也就是说Object.seal在Object.preventExtensions的基础上，给对象属性都设置了configurable为false。 这里有一个坑是：对于configurable为false的属性，虽然不能重新设置它的configurable和enumerable特性，但是可以把它的writable特性从true改为false（反之不行）。 Object.freeze：冻结一个对象，不能新增，修改，删除属性，也不能修改属性的原型。这里还有一个深冻结deepFreeze的概念，有点类似深拷贝的意思，递归冻结。 检测能力 Object.isExtensible：检测对象是否可扩展。 Object.isSealed：检测对象是否被封闭。 Object.isFrozen：检测对象是否被冻结。 兼容性差 Object.entries Object.values Object.fromEntries 原型方法原型方法是指挂载在原型对象上的方法，可以通过实例调用，本质上是借助原型对象调用。例如： 1234function Child() {}Child.prototype.protoMethod = function() { console.log(\"我是一个原型方法\") }var child = new Child();child.protoMethod(); // \"我是一个原型方法\" ECMAScript给Object定义了很多原型方法。 hasOwnProperty该方法会返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是，是否有指定的键），常配合for ... in语句一起使用，用来遍历对象自身可枚举属性。 isPrototypeOf该方法用于测试一个对象是否存在于另一个对象的原型链上。Object.prototype.isPrototypeOf与Object.getPrototypeOf不同点在于： Object.prototype.isPrototypeOf判断的是原型链关系，并且返回一个布尔值。 Object.getPrototypeOf是获取目标对象的直接原型，返回的是目标对象的原型对象 PropertyIsEnumerable该方法返回一个布尔值，表示指定的属性是否可枚举。它检测的是对象属性的enumerable特性。 valueOf &amp; toString对象转原始值会用到的方法，之前写过一篇笔记，具体见js数据类型很简单，却也不简单。 toLocaleStringtoLocaleString方法返回一个该对象的字符串表示。此方法被用于派生对象为了特定语言环境的目的（locale-specific purposes）而重载使用。常见于日期对象。 最后通过阅读本文，读者们可以对Javascript对象有一个基本的认识。对象是Javascript中非常复杂的部分，绝非一篇笔记或一张思维导图可囊括，诸多细节不便展开，可关注我留言交流，回复“思维导图”可获取我整理的思维导图。","link":"/一文搞懂对象原型继承.html"},{"title":"一种在地图中处理曲线的通用方法","text":"本文分享一种可以用于处理曲线的算法，是本人在百度地图开源库基础上改造的，可以用于其他地图场景中处理点数据，只要两个以上的点，就可以得到平滑的曲线。例如小程序，将处理后得到的点赋值给polyline的points即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192function getCurveByTwoPoints(obj1, obj2) { if (!obj1 || !obj2) { return null } var B1 = function (x) { return 1 - 2 * x + x * x }; var B2 = function (x) { return 2 * x - 2 * x * x }; var B3 = function (x) { return x * x }; curveCoordinates = []; var count = 30; var isFuture = false; var t, h, h2, lat3, lng3, j, t2; var LnArray = []; var i = 0; var inc = 0; if (typeof(obj2) == \"undefined\") { if (typeof(curveCoordinates) != \"undefined\") { curveCoordinates = [] } return } var lat1 = parseFloat(obj1.lat); var lat2 = parseFloat(obj2.lat); var lng1 = parseFloat(obj1.lng); var lng2 = parseFloat(obj2.lng); if (lng2 &gt; lng1) { if (parseFloat(lng2 - lng1) &gt; 180) { if (lng1 &lt; 0) { lng1 = parseFloat(180 + 180 + lng1) } } } if (lng1 &gt; lng2) { if (parseFloat(lng1 - lng2) &gt; 180) { if (lng2 &lt; 0) { lng2 = parseFloat(180 + 180 + lng2) } } } j = 0; t2 = 0; if (lat2 == lat1) { t = 0; h = lng1 - lng2 } else { if (lng2 == lng1) { t = Math.PI / 2; h = lat1 - lat2 } else { t = Math.atan((lat2 - lat1) / (lng2 - lng1)); h = (lat2 - lat1) / Math.sin(t) } } if (t2 == 0) { t2 = (t + (Math.PI / 5)) } h2 = h / 2; lng3 = h2 * Math.cos(t2) + lng1; lat3 = h2 * Math.sin(t2) + lat1; for (i = 0; i &lt; count + 1; i++) { curveCoordinates.push( { lng: (lng1 * B1(inc) + lng3 * B2(inc)) + lng2 * B3(inc), lat: (lat1 * B1(inc) + lat3 * B2(inc) + lat2 * B3(inc)) } ); inc = inc + (1 / count) } return curveCoordinates}function getCurvePoints(points) { var curvePoints = []; for (var i = 0; i &lt; points.length - 1; i++) { var p = getCurveByTwoPoints(points[i], points[i + 1]); if (p &amp;&amp; p.length &gt; 0) { curvePoints = curvePoints.concat(p) } } return curvePoints}let trackPoints = [{lng:113.281, lat:29.203}, {lng:113.567, lat:29.301}]let convertPoints = getCurvePoints(trackPoints)console.log(convertPoints) 最后再给一个微信小程序应用实例 map.wxml 12// 举个小程序应用的例子&lt;map id=\"map\" longitude=\"113.324520\" latitude=\"23.099994\" scale=\"14\" controls=\"{{controls}}\" bindcontroltap=\"controltap\" markers=\"{{markers}}\" bindmarkertap=\"markertap\" polyline=\"{{polyline}}\" bindregionchange=\"regionchange\" show-location style=\"width:100vw;height:100vh;\"&gt;&lt;/map&gt; map.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127Page({ data: { markers: [{ iconPath: \"/resources/marker.png\", id: 0, latitude: 23.099994, longitude: 113.324520, width: 50, height: 50 }], polyline: [], controls: [{ id: 1, iconPath: '/resources/location.png', position: { left: 0, top: 300 - 50, width: 50, height: 50 }, clickable: true }] }, onLoad() { this.setData({ polyline:[{ points: this.getCurvePoints([{ lng: 113.3245211, lat: 23.10229 }, { lng: 113.324520, lat: 23.21229 }]), color: \"#FF0000DD\", width: 2 }] }) }, regionchange(e) { console.log(e.type) }, markertap(e) { console.log(e.markerId) }, controltap(e) { console.log(e.controlId) }, getCurveByTwoPoints(obj1, obj2) { if (!obj1 || !obj2) { return null } var B1 = function (x) { return 1 - 2 * x + x * x }; var B2 = function (x) { return 2 * x - 2 * x * x }; var B3 = function (x) { return x * x }; var curveCoordinates = []; var count = 30; var isFuture = false; var t, h, h2, lat3, lng3, j, t2; var LnArray = []; var i = 0; var inc = 0; if (typeof (obj2) == \"undefined\") { if (typeof (curveCoordinates) != \"undefined\") { curveCoordinates = [] } return } var lat1 = parseFloat(obj1.lat); var lat2 = parseFloat(obj2.lat); var lng1 = parseFloat(obj1.lng); var lng2 = parseFloat(obj2.lng); if (lng2 &gt; lng1) { if (parseFloat(lng2 - lng1) &gt; 180) { if (lng1 &lt; 0) { lng1 = parseFloat(180 + 180 + lng1) } } } if (lng1 &gt; lng2) { if (parseFloat(lng1 - lng2) &gt; 180) { if (lng2 &lt; 0) { lng2 = parseFloat(180 + 180 + lng2) } } } j = 0; t2 = 0; if (lat2 == lat1) { t = 0; h = lng1 - lng2 } else { if (lng2 == lng1) { t = Math.PI / 2; h = lat1 - lat2 } else { t = Math.atan((lat2 - lat1) / (lng2 - lng1)); h = (lat2 - lat1) / Math.sin(t) } } if (t2 == 0) { t2 = (t + (Math.PI / 5)) } h2 = h / 2; lng3 = h2 * Math.cos(t2) + lng1; lat3 = h2 * Math.sin(t2) + lat1; for (i = 0; i &lt; count + 1; i++) { curveCoordinates.push( { longitude: (lng1 * B1(inc) + lng3 * B2(inc)) + lng2 * B3(inc), latitude: (lat1 * B1(inc) + lat3 * B2(inc) + lat2 * B3(inc)) } ); inc = inc + (1 / count) } return curveCoordinates }, getCurvePoints(points) { var curvePoints = []; for (var i = 0; i &lt; points.length - 1; i++) { var p = this.getCurveByTwoPoints(points[i], points[i + 1]); if (p &amp;&amp; p.length &gt; 0) { curvePoints = curvePoints.concat(p) } } return curvePoints }}) 献上效果图： 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/一种在地图中处理曲线的通用方法.html"},{"title":"二级域名解析配置方法","text":"昨天将基于express的后台服务器部署在了腾讯云主机上，使用IP可以正常访问到我的angular demo了。这里给大家提供一个测试账号（账号：test，密码：0）。接着我就想，是不是可以换成域名访问呢？答案当然是可以的。于是我准备把云主机解析到我的二级域名下。 解析二级域名很多网站都会有二级域名，形如blog.xxx.com，bbs.xxx.com等等，玩过域名解析的同学应该大概有个概念了。那么如何配置二级域名解析呢？ 打开阿里云控制台，来到域名管理处 点击“添加解析” 我们要将二级域名解析到云主机上，那么就是解析到ip，所以选择A记录 主机记录就是我们要定义的二级域名名称，自己合理随意即可 记录值则是云主机IP 点击确认则添加完成，二级域名解析的工作也宣告完成！这里就可以用二级域名访问试下了。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/二级域名解析配置方法.html"},{"title":"从一道面试题简单谈谈发布订阅和观察者模式","text":"今天的话题是javascript中常被提及的「发布订阅模式和观察者模式」，提到这，我不由得想起了一次面试。 记得在去年的一次求职面试过程中，面试官问我，“你在项目中是怎么处理非父子组件之间的通信的？”。我答道，“有用到vuex，有的场景也会用EventEmitter2”。面试官继续问，“那你能手写代码，实现一个简单的EventEmitter吗？” 手写EventEmitter我犹豫了一会儿，想到使用EventEmitter2时，主要是用emit发事件，用on监听事件，还有off销毁事件监听者，removeAllListeners销毁指定事件的所有监听者，还有once之类的方法。考虑到时间关系，我想着就先实现发事件，监听事件，移除监听者这几个功能。当时可能有点紧张，不过有惊无险，在面试官给了一点提示后，顺利地写出来了！现在把这部分代码也记下来。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class EventEmitter { constructor() { // 维护事件及监听者 this.listeners = {} } /** * 注册事件监听者 * @param {String} type 事件类型 * @param {Function} cb 回调函数 */ on(type, cb) { if (!this.listeners[type]) { this.listeners[type] = [] } this.listeners[type].push(cb) } /** * 发布事件 * @param {String} type 事件类型 * @param {...any} args 参数列表，把emit传递的参数赋给回调函数 */ emit(type, ...args) { if (this.listeners[type]) { this.listeners[type].forEach(cb =&gt; { cb(...args) }) } } /** * 移除某个事件的一个监听者 * @param {String} type 事件类型 * @param {Function} cb 回调函数 */ off(type, cb) { if (this.listeners[type]) { const targetIndex = this.listeners[type].findIndex(item =&gt; item === cb) if (targetIndex !== -1) { this.listeners[type].splice(targetIndex, 1) } if (this.listeners[type].length === 0) { delete this.listeners[type] } } } /** * 移除某个事件的所有监听者 * @param {String} type 事件类型 */ offAll(type) { if (this.listeners[type]) { delete this.listeners[type] } }}// 创建事件管理器实例const ee = new EventEmitter()// 注册一个chifan事件监听者ee.on('chifan', function() { console.log('吃饭了，我们走！') })// 发布事件chifanee.emit('chifan')// 也可以emit传递参数ee.on('chifan', function(address, food) { console.log(`吃饭了，我们去${address}吃${food}！`) })ee.emit('chifan', '三食堂', '铁板饭') // 此时会打印两条信息，因为前面注册了两个chifan事件的监听者// 测试移除事件监听const toBeRemovedListener = function() { console.log('我是一个可以被移除的监听者') }ee.on('testoff', toBeRemovedListener)ee.emit('testoff')ee.off('testoff', toBeRemovedListener)ee.emit('testoff') // 此时事件监听已经被移除，不会再有console.log打印出来了// 测试移除chifan的所有事件监听ee.offAll('chifan')console.log(ee) // 此时可以看到ee.listeners已经变成空对象了，再emit发送chifan事件也不会有反应了 有了这个自己写的简单版本的EventEmitter，我们就不用依赖第三方库啦。对了，vue也可以帮我们做这样的事情。 123const ee = new Vue();ee.$on('chifan', function(address, food) { console.log(`吃饭了，我们去${address}吃${food}！`) })ee.$emit('chifan', '三食堂', '铁板饭') 所以我们可以单独new一个Vue的实例，作为事件管理器导出给外部使用。想测试的朋友可以直接打开vue官网，在控制台试试，也可以在自己的vue项目中实践下哦。 发布订阅模式其实仔细看看，EventEmitter就是一个典型的发布订阅模式，实现了事件调度中心。发布订阅模式中，包含发布者，事件调度中心，订阅者三个角色。我们刚刚实现的EventEmitter的一个实例ee就是一个事件调度中心，发布者和订阅者是松散耦合的，互不关心对方是否存在，他们关注的是事件本身。发布者借用事件调度中心提供的emit方法发布事件，而订阅者则通过on进行订阅。 如果还不是很清楚的话，我们把代码换下单词，是不是变得容易理解一点呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class PubSub { constructor() { // 维护事件及订阅行为 this.events = {} } /** * 注册事件订阅行为 * @param {String} type 事件类型 * @param {Function} cb 回调函数 */ subscribe(type, cb) { if (!this.events[type]) { this.events[type] = [] } this.events[type].push(cb) } /** * 发布事件 * @param {String} type 事件类型 * @param {...any} args 参数列表 */ publish(type, ...args) { if (this.events[type]) { this.events[type].forEach(cb =&gt; { cb(...args) }) } } /** * 移除某个事件的一个订阅行为 * @param {String} type 事件类型 * @param {Function} cb 回调函数 */ unsubscribe(type, cb) { if (this.events[type]) { const targetIndex = this.events[type].findIndex(item =&gt; item === cb) if (targetIndex !== -1) { this.events[type].splice(targetIndex, 1) } if (this.events[type].length === 0) { delete this.events[type] } } } /** * 移除某个事件的所有订阅行为 * @param {String} type 事件类型 */ unsubscribeAll(type) { if (this.events[type]) { delete this.events[type] } }} 画图分析最后，我们画个图加深下理解： 特点 发布订阅模式中，对于发布者Publisher和订阅者Subscriber没有特殊的约束，他们好似是匿名活动，借助事件调度中心提供的接口发布和订阅事件，互不了解对方是谁。 松散耦合，灵活度高，常用作事件总线 易理解，可类比于DOM事件中的dispatchEvent和addEventListener。 缺点 当事件类型越来越多时，难以维护，需要考虑事件命名的规范，也要防范数据流混乱。 观察者模式观察者模式与发布订阅模式相比，耦合度更高，通常用来实现一些响应式的效果。在观察者模式中，只有两个主体，分别是目标对象Subject，观察者Observer。 观察者需Observer要实现update方法，供目标对象调用。update方法中可以执行自定义的业务代码。 目标对象Subject也通常被叫做被观察者或主题，它的职能很单一，可以理解为，它只管理一种事件。Subject需要维护自身的观察者数组observerList，当自身发生变化时，通过调用自身的notify方法，依次通知每一个观察者执行update方法。 按照这种定义，我们可以实现一个简单版本的观察者模式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 观察者class Observer { /** * 构造器 * @param {Function} cb 回调函数，收到目标对象通知时执行 */ constructor(cb){ if (typeof cb === 'function') { this.cb = cb } else { throw new Error('Observer构造器必须传入函数类型！') } } /** * 被目标对象通知时执行 */ update() { this.cb() }}// 目标对象class Subject { constructor() { // 维护观察者列表 this.observerList = [] } /** * 添加一个观察者 * @param {Observer} observer Observer实例 */ addObserver(observer) { this.observerList.push(observer) } /** * 通知所有的观察者 */ notify() { this.observerList.forEach(observer =&gt; { observer.update() }) }}const observerCallback = function() { console.log('我被通知了')}const observer = new Observer(observerCallback)const subject = new Subject();subject.addObserver(observer);subject.notify(); 画图分析最后也整张图理解下观察者模式： 特点 角色很明确，没有事件调度中心作为中间者，目标对象Subject和观察者Observer都要实现约定的成员方法。 双方联系更紧密，目标对象的主动性很强，自己收集和维护观察者，并在状态变化时主动通知观察者更新。 缺点我还没体会到，这里不做评价 结语关于这个话题，网上文章挺多的，观点上可能也有诸多分歧。重复造轮子，纯属帮助自己加深理解。 本人水平有限，以上仅是个人观点，如有错误之处，还请斧正！如果能帮到您理解发布订阅模式和观察者模式，非常荣幸！ 如果有兴趣看看我这糟糕的代码，请点击github，祝大家生活愉快！ 首发链接","link":"/从一道面试题简单谈谈发布订阅和观察者模式.html"},{"title":"从亲身经历谈谈如何用Git分支解决项目生产实践中的痛点","text":"原创不易，欢迎阅后点赞关注支持，本期内部分享PPT可自取，见文末！ 最近笔者所在公司发生了一起小风波，事情大概是这样的：市场部老大在给客户现场演示系统时，正讨论着一个主题，恰巧系统在切换到相关功能时出现了异常，导致功能不可用，现场有点尴尬。 显然，问题归咎于研发部。严肃的气氛下，我下意识在想自己是不是凉了，于是我迅速定位原因，发现是后端接口发生变更而未通知前端，责任人正好是刚来没多久的后端新人。虽然这次事故不是前端的责任，但让我发现了后端Team存在的问题，在版本控制上有较大的隐患，代码未经Review就入库发版了，这本质上是分支管理不合理导致的。 研发部门是一个整体，当着客户的面出了生产事故，这让大家面子上都不好看，所以我自告奋勇提出在研发部内部做一次Git分支管理的分享，看看能不能帮大家解决这个问题。我入职以来一直比较注意版本控制这块，但也是今年才比较系统地梳理研发流程和版本控制（去年是快速出产品的一年，管理上稍微糙一点），几个月前还特意总结了一篇《前端小微团队的Gitlab实践》，经过数月的不断实践和改进，我感觉这套Git体系基本覆盖了我司的研发流程，至今没出过事故，发版节奏一直良好。 其实几个月前我就想在部门内分享下我这套版本控制流程，但是一方面是考虑到自己刚摸索出来，不太熟练，另一方面是自己资历尚浅，如果跨Team直接给后端老哥们“上课”也不太好吧（其实这个顾虑是多余的_）。 嗯，大概是这么一个心路历程，而现在正是必须站出来的时候，我希望这次我的分享能为团队尽绵薄之力！具体分享的内容是这样的，且听我慢慢道来！ 个人感受Git对我们来说既熟悉又陌生。感觉熟悉是因为我们似乎已经掌握了大量常用的Git命令，感到陌生是因为我们在实际项目中总是用不好它。是的，我也有过这样的感受，直到现在，我觉得Git仍有很多待探索的空间，比如难以理解的git rebase，又或者是Git提供的Hooks，让自动化部署有了更多可能。甚至一些平台将代码托管，敏捷开发，CI/CD，DevOps融合到了一起，提供了一站式解决方案。 始于Git，却不止于Git，Git还有太多值得我们折腾的小惊喜。那么，今天我以如何在实际项目中运用Git分支管理这个主题作为切入点做一次内部分享。 分布式版本控制我们知道，Git是一个开源的分布式版本控制系统，这让团队协作成为了可能。我们可以通过fetch/pull将远程仓库的代码拉取到本地，也可以将本地代码push到远程仓库。 而我们向版本库提交代码的一个基本方向是： 工作区 –&gt; 暂存区 –&gt; 版本库 当对工作区修改（或新增）的文件执行git add命令时，暂存区的目录树被更新。 当执行git commit命令进行提交操作时，暂存区的目录树写到版本库中。 分支管理Git最核心的内容当然是分支管理，设置合理的分支可以让研发流程有条不紊。使用分支意味着你可以从开发主线上抽离出来，不影响主线的前提下进行工作，最后完成工作再通过git merge将代码合入到主干分支上。 简单的分支管理在生产实践中，一般来说，我们会保持至少三个分支，分别是开发分支develop，测试分支release，生产主干分支master。不同的团队或个人在分支命名上可能会有所差异，但是基本逻辑都是大体一致的。 开发分支develop：最不稳定的分支，所有和特性，缺陷相关的代码都会陆续地被提交到这个分支。 测试分支release：一个敏捷迭代结束时，正常情况下，所有develop分支的代码都会被merge到release分支，准备发测试版本。 生产分支master：最稳定的分支，待交付的版本上线前，测试通过的release分支会被merge到master分支。 然而很多团队在管理develop分支时存在一个很大的问题：所有开发者都直接向develop分支push代码。 这样会造成很多隐患，包括但不限于： 团队成员间代码冲突。当然，直接向develop分支push代码也不是造成冲突的根本原因。但是，这会让冲突更容易发生！ 代码质量不可控。这个问题大家都比较清楚了，这是因为所有代码都没有经过Review就入库了！ 版本不可控。相信大家都遇到过，临到上线时间点，突然发现某某开发者的转测功能存在重大缺陷，不能上线。这个时候，选出能上线的代码让人头疼！根本原因是开发者的代码都直接进了develop分支，这让挑选代码变成了一件非常复杂的事情！ 可控的分支管理那么如何才能解决上述痛点呢？我们可以从分支的设计上入手。 保护分支（Protected Branchs）。禁止开发者直接向保护分支提交代码，develop，release，master都应该被设置为保护分支！ 增加特性/缺陷分支，避免直接向develop分支push代码。 增加代码Review环节，基本上所有代码托管平台都支持这个环节！ 具体操作流程是这样的： 如上图所示，我们约定一个特性或一个缺陷就是一个开发任务，所有的开发任务都应该在本地建立独立的分支。 开发者在特性/缺陷分支上进行开发。由于我们禁止了向保护分支直接push代码，所以开发者完成代码编写后，需要将本地分支同步到远程同名分支。 在代码托管平台如Gitlab上发起Merge Request，请求将特性/缺陷分支合入到develop分支。 Maintainer（一般是团队资深成员，拥有同意MR的权限）负责Code Review，确认基本无误后同意MR，代码就顺利进入develop分支了。 后面全量发版本的流程就简单了，无脑merge即可！ 如果不能全量发版，必须进行代码挑选，此时就需要cherry-pick出场了！ 特别注意，一定要保证分支的原子性，一个分支只干一件事。千万不要写着写着代码，突然萌生了在当前分支顺手改另一个问题的想法，这可能会让你陷入更大的麻烦！ 分支命名取名字永远是个难题，组件如何命名，方法如何命名，这些问题在平时开发过程中总是让人抓耳挠腮。当然，Git分支命名也不例外。 我之前也试过分支语义化命名，但是也发现了要用有限的单词描绘出复杂的含义永远是个伪命题。如上图所示，我们可能会在做一个新功能时，把相关分支命名为feature/xxx，而后面有优化类需求时，又会新建一个feature/xxx-optimization之类的分支。然而，往往一个功能会有一次又一次的优化、变更或bug，采取这样的命名策略永远会让自己直面灵魂拷问！ 并且在追溯问题时，这种分支命名方式往往让人心力交瘁！ 那么如何命名能解决这样的问题呢？我采用了下面这种策略！ 我在观察很多开源软件时发现，他们的维护者都会用issue来记录各种开发相关的活动。比如需求，缺陷都会被记录在issue中，这让我觉得用issue来管理分支也是一个非常棒的idea！ 我们可以在创建issue时填写标题和描述，并且可以通过链接等形式与敏捷管理平台的需求和缺陷关联上，还可以给issue打上不同的标签，看起来会非常直观。 issue还可以与milestone（里程碑）关联，用于检验和衡量阶段性的成果！想要知道更多细节，不妨打开《前端小微团队的Gitlab实践》细致阅读！ 而issue本身有一个编号，或者叫ID，这种唯一标识让我们命名分支变得简单。假定一个issue的编号是1，那么我们在本地创建分支时，只需要将分支命名为issue/1即可，根据这个编号，我就能查到这个分支处理的是哪个issue，而打开Gitlab的issue，我就能知道这个issue与什么需求或缺陷有关。这不仅给开发者带来了方便，也让管理者变得更轻松！ 实际项目中如何操作？对上文中的知识有了一定了解后，接下来就是看看如何在项目中把这些知识运用起来，形成一个合理，高效的流程！我以新需求为例，简单画了一下流程，请看下图： 打通了这么一个主流程后，相信无论是修复bug，还是其他的场景，你都能举一反三！ 分支节点可拓展实际上，不同公司在分支节点上的数量是不一样的。有的公司可能从开发到上线，会涉及多套环境验证，这样下来，就可能对应多个Git分支节点。加节点也不用怕，结合git merge和git cherry-pick，理论上再多节点也能应付得过来！ 所以，我也在内部分享结尾时，提出了增加预发布环境的建议。测试环境尽可能发挥想象，可以测试各种极端情况。而预发布环境尽量模拟生产环境，保证数据和流程的合理性。这样一来，结合测试环境和预发布环境，我们能覆盖更多的测试用例，上线故障率会更低！ VSCODE必备扩展：GitLens最后推荐大家安装一个非常好用的VSCODE扩展：GitLens 有了它，我们就可以随时看到每一行代码最近一次的改动都是谁提交的。 这也避免了大家查问题时，突然翻到一行可疑代码，然后感叹：这是哪个傻X写的！ 最后一查记录发现是自己写的…… 科科，GitLens它不香吗？ 感谢阅读由于时间有限，本次分享的PPT和作图都有些简单，请勿介意！本次分享主要讲解了笔者是如何运用Git分支去解决项目中实际遇到的痛点，总的来说还是干货满满的，希望对大家有所帮助，喜欢的朋友请留下您的关注和点赞支持一下我吧！ PPT也分享出来了，有需要的请自取。搜索公众号【前端司南】，回复PPT，获取本期内部分享PPT！","link":"/从亲身经历谈谈如何用Git分支解决项目生产实践中的痛点.html"},{"title":"从部署上做到前后端分离","text":"记得在让Nodejs支持H5 History模式（connect-history-api-fallback源码分析）一文中提到了HTML5的History Mode。然而在最近的使用过程中发现connect-history-api-fallback这个包效果并不是那么理想，用一段时间就会报错。而且本身我的博客项目前后端并未完全分离，虽然开发时是独立的工程，但是前端工程打包后还是放在了express的静态资源文件夹下进行部署。考虑到这两个痛点，我决定在nginx配置中对前后端进行部署分离。 前端独立部署前端工程npm run build打包后，不再copy到后端工程public目录下。而是独立部署在nginx的静态资源目录下，我放置的目录是/usr/nginx/share/html/blog 相关nginx配置如下： 12345678910111213#博客转发 blog.wbjiang.cnserver { listen 80; server_name blog.wbjiang.cn; root /usr/share/nginx/html/blog; access_log logs/blog.log; error_log logs/blog.error; #博客静态文件 location / { try_files $uri /index.html; }} 小建议：可以在开发新功能完毕后，就将打包完毕的代码提交到仓库的release分支，然后直接在linux服务器上对应目录下的Git仓库中git pull，也算是半自动化部署了（后面也准备研究下全自动化部署）。 后端接口转发blog.wbjiang.cn/api前缀的视为接口请求，统一转发到express后台服务。配置如下： 12345678910#api转发location /api { proxy_pass http://blog_pool; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; rewrite ^/api/(.*)$ /$1 break;} 负载均衡池配置（虽然只有一个服务，手动“狗头”） 123upstream blog_pool{ server 127.0.0.1:8002;} 重启服务pm2重启 1pm2 restart blog nginx重启 1nginx -s reload 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/从部署上做到前后端分离.html"},{"title":"入坑自媒体写作，我有干货与你分享","text":"自媒体时代，人人都可以发声，大家都可以通过互联网发表自己的言论和观点。常见的自媒体平台有微信公众号，知乎，微博，头条，以及各个新闻博客平台等。自媒体写作与传统写作最大的不同，就是突出个性思维，只要找准自己的定位，一直坚持一个方向深耕，且不说会得到什么样的收益，但一定会提升自己的综合能力。之前也不止一次问过自己，你又不是大咖，写什么文章？质量还不高？我想，大概是兴趣驱动，写作是一种思考和沉淀的过程，于我而言是收获。 借用《后浪》里的一句话： 人与人之间的壁垒被打破，你们只凭相同的爱好，就能结交千万个值得干杯的朋友，你们拥有了我们曾经梦寐以求的权利——选择的权利。 是的，我们有幸生在这个时代，自媒体已经没有职业之分了，任何职业的个体都可以在网络上发文分享自己的知识、经验、见识，也可以通过短视频这个当红的渠道快速传播。对于我们IT技术人来讲，一般会选择从技术知识写作入手，那么怎样才能写好一篇文章呢？作为一个粉丝数接近0的作者，我还是有一点干货与你分享。 准备工作准备一篇有品质的文章，除了实打实的文章质量，美观的排版设计和丰富的素材也会加不少分。那么要从哪些方面入手呢？不着急，马上给您安排！ 写作方式最重要的当然是写作方式，选择一些好的编辑器往往让你事半功倍。一般而言，我们会选择富文本编辑器和Markdown编辑器两大类。 富文本编辑器一般的写作平台都标配了富文本编辑器，所见即所得，这种感觉可能跟使用Word文档差不多。对于大多数人来说，富文本编辑器是一个非常棒的选择。下面是微信公众号的一个富文本编辑器界面： 虽然有了富文本编辑器，但是写作仍然是一个伤脑筋的事情，比如找一些关注引导推荐类的素材还不够方便，所以我们还需要一个有大量可用素材模板的编辑器。 有流量的地方自然有人去做，微信公众号这么一个巨大的流量通道，市面上自然少不了各种微信图文编辑器。大家可以自行去搜索下，我这里就不实名推荐了，防止广告嫌疑。 这些编辑器内的素材都可以方便地复制到微信公众号的编辑器里，有的甚至做了一键导入到微信公众号的能力。 当然这里不可避免会出现一些收费的素材，但是免费的基本上已经满足大众需求了，不用过于担心。 Markdown作为程序狗，自然忍不住要提一提Markdown。Markdown是一种标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式，可以代表标题，文本，表格，图片，链接等等。 你完全不用担心Markdown效果不好，虽然Markdown默认是极简风格，但是结合现在的表现层语言，它可以做得很漂亮。下面是一个简单的例子： 你也不用担心不会使用Markdown，市面上已经有很多非常nice的Markdown编辑器。有了这些编辑器，你可以像写word文档一般玩转Markdown。 typora这里必须强力推荐一款编辑器typora了，是因为它真的很好用。 在typora，你可以选择各种主题： 利用这些主题，你可以专注于把控文章质量，写好之后直接复制到微信公众号，知乎等平台上的编辑器中，效果非常棒！ mdnice等在线编辑器如果不想用本地的markdown编辑器，也有在线的备选项，搜索“在线markdown编辑器”就好了。 这里推荐一个mdeditor，但是一般的在线markdown编辑器都没有主题功能，如果你需要做出个性化的效果，可能这些还不够。 所以必须要推荐我现在很喜欢的一款编辑器mdnice了。mdnice可以说是把CSS的威力发挥得淋漓尽致了，支持的主题很多，也可以自行定义主题（如果你会使用CSS语言的话，可以尝试一下），下面这个主题是我自己定制的，个人觉得效果还行。 mdnice也支持一键复制到微信公众号，掘金，知乎等平台，可以满足多数人的需求。 并且mdnice支持缓存你的历史修改版本，这样也可以从一定程度上防止写作内容丢失了！ 还有一款类似的编辑器，做得也挺好的，就是主题太少了点。附上链接：https://lab.lyric.im/wxformat/# 之前还用过一款md2all，不过好像停更了，链接是：http://md.aclickall.com/ 语雀有一次我本地用typora写作，结果系统崩了，没保存到，心态有点炸。最近我开始慢慢地在语雀上写个大概的草稿，然后可以导出markdown格式，转到typora或者mdnice再细致改改。有云同步的功能还是保险啊。 我在公司写文档也基本上是用语雀的(之前还试过自己搭gitbook，不过没语雀给力)，这是阿里内部孵化的很好的一款工具，强烈推荐！ 说了这么多编辑器，并不是说选择哪一款就可以解决所有问题，一般来说，结合起来使用，效果更棒，可以自行体会下！ 素材搞清楚了如何选择编辑器，接下来的重点就是素材的收集和处理了。灵活地运用素材，会让你的文章显得很饱满，生动有趣！ 无版权图首先要说的就是图片素材，写作的过程中，我们大部分时候会希望插入一些优质的图片，或是风景图，或是卡通，或是人物图。找图片素材自然要上一些靠谱的网站了，我这里也推荐一些，有些是否能商用要仔细看看，反正个人用途基本上没问题的。 https://wallhaven.cc/ 这个是我用得最多的，并且支持原图在线裁剪。 https://www.pexels.com/zh-tw/ https://pixabay.com/zh/photos/ https://stocksnap.io/ 图标有时候我们可能也不需要找很大的图片素材，如果只是寻找一个小图标的话，上iconfont就基本上解决了，支持导出主流的图片格式，并且可以自定义修改颜色，大小等。对了，iconfont是前端工程师日常开发中一个很重要的工具哦！ 动图如果需要录制一些GIF动图，比如操作引导之类的，就需要一个比较方便的工具了。我这里使用的是GifCam，如果您有更好的工具，请不吝赐教。 录屏如果要录视频的话，可以选择FSCapture，除了录屏之外，还可以实现截图，滚动截图等能力哦，可谓是小而美。 之前还用过一款超级录屏，也是不错的。 当然还有一个神器OBS Studio，接触过直播的应该都知道（别问我为什么知道）。 表情包有时候还是要来点表情包活跃下气氛的，除了日常搜集的表情包，我们有时候可能希望制作一些跟我们写作主题相关的表情，这个时候就要搜一下表情包制作了，这种工具很多，自行筛选即可。这里也简单地列举几个吧： https://fabiaoqing.com/diy https://app.xuty.tk/static/app/index.html https://www.52doutu.cn/diy/ Emoji插入emoji也是个基本操作了，但是很多平台的编辑器还不支持直接识别emoji编码，直接复制上去是不行的，会被认定为普通文本。 而typora编辑器是支持emoji的，只要把emoji编码复制上去，马上就呈现出来了。 所以我们可以先在typora编辑器里面把emoji弄好，然后复制到其他平台上的富文本编辑器，就可以显示出来了。 据我测试，大部分markdown编辑器是不支持这样做的，如果想把emoji复制到markdown编辑器上，需要先从typora复制到富文本编辑器，然后就可以把emoji表情从富文本编辑器复制到markdown编辑器上了。 关于emoji的编码，这里有比较完整的一个列表。https://www.webfx.com/tools/emoji-cheat-sheet/ 流程图/结构图/架构图画图是一个很有用的方法，可以帮助我们把一个复杂的过程简单而直观地展示出来，极大提高了我们的效率。 桌面端有强大的visio 在线的绘图平台有ProcessOn 思维导图ProcessOn也可以画思维导图，类似的还有百度脑图。不过我还是更习惯用桌面端的xmind。 资源压缩一般来说，找一些在线的压缩工具即可。但是有的要收费，要注意避坑。 压缩图片 https://tinypng.com/ https://www.tutieshi.com/compress/ https://www.soogif.com/compress https://docsmall.com/image-compress 压缩视频 我几乎不用视频素材，如果要压缩视频，一般是找桌面端工具了，可以自行搜索下，或者看看这篇知乎如何压缩视频大小？ 图床我目前只用了七牛云和路过图床。 七牛云对象存储，如果不用https的话，存图片是免费的。 路过图床，这个是免费的，但是复制到微信公众号编辑器上，直接加载失败，头疼，估计是做了防盗链。 还有一个比较好的工具PicGo，集合了多个图床平台，有兴趣的可以试试。 在线作图有时候我们要处理下封面，或者公众号首图，光有素材可能还不够的，一般人也不会使用PS，那么在线作图还是很重要的，可以节省很多时间。 这里推荐我用过的两款： 稿定设计：素材比较丰富，也支持同步到微信公众号素材库。 Canva 我早期用的一个在线作图工具。 骚操作图片加阴影我们经常会截图作为素材，但是有时候截图的轮廓感不是很强，这个时候就要给图片来加个阴影效果了。我试过直接在mdnice上用css的box-shadow做阴影，但是感觉比较容易受盒子的影响，出现不太好的效果。 所以我觉得还是直接改图片本身比较好，我现在使用的图片处理工具是ShareX。如果你会使用PS，那就自然不必多说。 typora主题定制typora支持主题定制，首先要找到typora的主题目录。 然后添加一个css文件，例如feibai.css，写下需要定制的css内容，比如： 1234567891011121314h1 { background: url(http://qncdn.xxx.cn/xxx.svg); background-size: 48px 48px; background-position: top center; background-repeat: no-repeat; text-align: center; font-size: 24px;}h1 &gt; span { padding-top: 48px; display: block; color: #135ce0;} 接着在typora选择你刚才写的主题，就可以看到效果了。 如果想要详细了解如何定制typora主题，可以主动联系我。 最后做了这些准备工作，我不敢打包票说能写出很nice的文章，但至少能过得了自己眼球这一关吧。好了，本次分享结束，如果您觉得这篇文章还不错，欢迎关注+在看+分享鼓励一下我，也可以留言加我微信交流，谢谢！","link":"/入坑自媒体写作，我有干货与你分享.html"},{"title":"入门babel，我们需要了解些什么","text":"说实话，我从工作开始就一直在接触babel，然而对于babel并没有一个清晰的认识，只知道babel是用于编译javascript，让开发者能使用超前的ES6+语法进行开发。自己配置babel的时候，总是遇到很多困惑，下面我就以babel@7为例，重新简单认识下babel。 什么是babel Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。 babel的配置文件一般是根目录下的.babelrc，babel@7目前已经支持babel.config.js，不妨用babel.config.js试试。 泰拳警告 babel提供的基础能力是语法转换，或者叫语法糖转换。比如把箭头函数转为普通的function，而对于ES6新引入的全局对象是默认不做处理的，如Promise, Map, Set, Reflect, Proxy等。对于这些全局对象和新的API，需要用垫片polyfill处理，core-js有提供这些内容。 所以babel做的事情主要是： 根据你的配置做语法糖解析，转换 根据你的配置塞入垫片polyfill 如果不搞清楚这点，babel的文档看起来会很吃力！ 必须掌握的概念pluginsbabel默认不做任何处理，需要借助插件来完成语法的解析，转换，输出。 插件分为语法插件Syntax Plugins和转换插件Transform Plugins。 语法插件语法插件仅允许babel解析语法，不做转换操作。我们主要关注的是转换插件。 转换插件转换插件，顾名思义，负责的是语法转换。 转换插件将启用相应的语法插件，如果启用了某个语法的转换插件，则不必再另行指定相应的语法插件了。 语法转换插件有很多，从ES3到ES2018，甚至是一些实验性的语法和相关框架生态下的语法，都有相关的插件支持。 语法转换插件主要做的事情有： 利用@babel/parser进行词法分析和语法分析，转换为AST –&gt; 利用babel-traverse进行AST转换（涉及添加，更新及移除节点等操作） –&gt; 利用babel-generator生成目标环境js代码 插件简写babel@7之前的缩写形式是这样的： 12345678// 完整写法plugins: [ \"babel-plugin-transform-runtime\"]// 简写形式plugins: [ \"transform-runtime\"] 而在babel@7之后，由于plugins都归到了@babel目录下，所以简写形式也有所改变： 12345678// babel@7插件完整写法plugins: [ \"@babel/plugin-transform-runtime\"]// 简写形式，需要保留目录plugins: [ \"@babel/transform-runtime\"] 插件开发我们自己也可以开发插件，官网上的一个非常简单的小例子： 1234567891011121314export default function() { return { visitor: { Identifier(path) { const name = path.node.name; // reverse the name: JavaScript -&gt; tpircSavaJ path.node.name = name .split(\"\") .reverse() .join(\"\"); }, }, };} presetspreset，意为“预设”，其实是一组plugin的集合。我的理解是，根据这项配置，babel会为你预设（或称为“内置”）好一些ECMA标准，草案，或提案下的语法或API，甚至是你自己写的一些语法规则。当然，这都是基于plugin实现的。 官方presets @babel/preset-env @babel/preset-flow @babel/preset-react @babel/preset-typescript @babel/preset-env@babel/preset-env提供了一种智能的预设，根据配置的options来决定支持哪些能力。 我们看看关键的options有哪些。 targets 描述你的项目要支持的目标环境。写法源于开源项目browserslist。这项配置应该根据你需要兼容的浏览器而设置，不必与其他人一模一样。示例如下： 123\"targets\": { \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 9\"]} loose 可以直译为“松散模式”，默认为false，即为normal模式。简单地说，就是normal模式转换出来的代码更贴合ES6风格，更严谨；而loose模式更像我们平时的写法。以class写法举例： 我们先写个简单的class： 12345678910class TestBabelLoose { constractor(name) { this.name = name } getName() { return this.name }}new TestBabelLoose('Tusi') 使用normal模式编译得到结果如下： 1234567891011121314151617181920212223242526272829function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }function _defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }var TestBabelLoose =/*#__PURE__*/function () { function TestBabelLoose() { _classCallCheck(this, TestBabelLoose); } _createClass(TestBabelLoose, [{ key: \"constractor\", value: function constractor(name) { this.name = name; } }, { key: \"getName\", value: function getName() { return this.name; } }]); return TestBabelLoose;}();new TestBabelLoose('Tusi'); 而使用loose模式编译得到结果是这样的，是不是更符合我们用prototype实现类的写法？ 123456789101112131415161718192021\"use strict\";var TestBabelLoose =/*#__PURE__*/function () { function TestBabelLoose() {} var _proto = TestBabelLoose.prototype; _proto.constractor = function constractor(name) { this.name = name; }; _proto.getName = function getName() { return this.name; }; return TestBabelLoose;}();new TestBabelLoose('Tusi'); 个人推荐配置loose: false，当然也要结合项目实际去考量哪种模式更合适。 modules 可选值有：&quot;amd&quot; | &quot;umd&quot; | &quot;systemjs&quot; | &quot;commonjs&quot; | &quot;cjs&quot; | &quot;auto&quot; | false，默认是auto 该配置将决定是否把ES6模块语法转换为其他模块类型。注意，cjs是commonjs的别名。 其实我一直有个疑惑，为什么我看到的开源组件中，基本都是设置的modules: false？后面终于明白了，原来这样做的目的是把转换模块类型的处理权交给了webpack，由webpack去处理这项任务。所以，如果你也使用webpack，那么设置modules: false就没错啦。 useBuiltIns 可选值有：&quot;entry&quot; | &quot;usage&quot; | false，默认是false 该配置将决定@babel/preset-env如何去处理polyfill &quot;entry&quot; 如果useBuiltIns设置为&quot;entry&quot;，我们需要安装@babel/polyfill，并且在入口文件引入@babel/polyfill，最终会被转换为core-js模块和regenerator-runtime/runtime。对了，@babel/polyfill也不会处理stage &lt;=3的提案。 我们用一段包含了Promise的代码来做下测试： 12345678910111213141516import \"@babel/polyfill\";class TestBabelLoose { constractor(name) { this.name = name } getName() { return this.name } testPromise() { return new Promise(resolve =&gt; { resolve() }) }}new TestBabelLoose('Tusi') 但是编译后，貌似引入了很多polyfill啊，一共149个，怎么不是按需引入呢？嗯…你需要往下看了。 123456import \"core-js/modules/es6.array.map\";import \"core-js/modules/es6.map\";import \"core-js/modules/es6.promise\";import \"core-js/modules/es7.promise.finally\";import \"regenerator-runtime/runtime\";// 此处省略了144个包。。。 &quot;usage&quot; 如果useBuiltIns设置为&quot;usage&quot;，我们无需安装@babel/polyfill，babel会根据你实际用到的语法特性导入相应的polyfill，有点按需加载的意思。 12345// 上个例子中，如果改用useBuiltIns: 'usage'，最终转换的结果，只有四个模块import \"core-js/modules/es6.object.define-property\";import \"core-js/modules/es6.promise\";import \"core-js/modules/es6.object.to-string\";import \"core-js/modules/es6.function.name\"; 配置&quot;usage&quot;时，常搭配corejs选项来指定core-js主版本号 12useBuiltIns: \"usage\",corejs: 3 false 如果useBuiltIns设置为false，babel不会自动为每个文件加上polyfill，也不会把import &quot;@babel/polyfill&quot;转为一个个独立的core-js模块。 @babel/preset-env还有一些配置，自己慢慢去折腾吧…… stage-xstage-x描述的是ECMA标准相关的内容。根据TC39（ECMA39号技术专家委员会）的提案划分界限，stage-x大致分为以下几个阶段： stage-0：strawman，还只是一种设想，只能由TC39成员或者TC39贡献者提出。 stage-1：proposal，提案阶段，比较正式的提议，只能由TC39成员发起，这个提案要解决的问题须有正式的书面描述，一般会提出一些案例，以及API，语法，算法的雏形。 stage-2：draft，草案，有了初始规范，必须对功能的语法和语义进行正式描述，包括一些实验性的实现，也可以提出一些待办事项。 stage-3：condidate，候选，该提议基本已经实现，需要等待实践验证，用户反馈及验收测试通过。 stage-4：finished，已完成，必须通过Test262验收测试，下一步就是纳入到ECMA标准中。比如一些ES2016，ES2017的语法就是通过这个阶段被合入ECMA标准中了。 有兴趣了解的可以关注ecma262。 需要注意的是，babel@7已经移除了stage-x的preset，stage-4部分的功能已经被@babel/preset-env集成了，而如果你需要stage &lt;= 3部分的功能，则需要自行通过plugins组装。 1234567891011121314151617181920As of v7.0.0-beta.55, we&apos;ve removed Babel&apos;s Stage presets.Please consider reading our blog post on this decision athttps://babeljs.io/blog/2018/07/27/removing-babels-stage-presetsfor more details. TL;DR is that it&apos;s more beneficial in the long run to explicitly add which proposals to use.If you want the same configuration as before:{ &quot;plugins&quot;: [ // Stage 2 [&quot;@babel/plugin-proposal-decorators&quot;, { &quot;legacy&quot;: true }], &quot;@babel/plugin-proposal-function-sent&quot;, &quot;@babel/plugin-proposal-export-namespace-from&quot;, &quot;@babel/plugin-proposal-numeric-separator&quot;, &quot;@babel/plugin-proposal-throw-expressions&quot;, // Stage 3 &quot;@babel/plugin-syntax-dynamic-import&quot;, &quot;@babel/plugin-syntax-import-meta&quot;, [&quot;@babel/plugin-proposal-class-properties&quot;, { &quot;loose&quot;: false }], &quot;@babel/plugin-proposal-json-strings&quot; ]} 自己写preset如需创建一个自己的preset，只需导出一份配置即可，主要是通过写plugins来实现preset。此外，我们也可以在自己的preset中包含第三方的preset。 1234567891011121314module.exports = function() { return { // 增加presets项去包含别人的preset presets: [ require(\"@babel/preset-env\") ], // 用插件来包装成自己的preset plugins: [ \"pluginA\", \"pluginB\", \"pluginC\" ] };} @babel/runtimebabel运行时，很重要的一个东西，它一定程度上决定了你产出的包的大小！一般适合于组件库开发，而不是应用级的产品开发。 说明这里有两个东西要注意，一个是@babel/runtime，它包含了大量的语法转换包，会根据情况被按需引入。另一个是@babel/plugin-transform-runtime，它是插件，负责在babel转换代码时分析词法语法，分析出你真正用到的ES6+语法，然后在transformed code中引入对应的@babel/runtime中的包，实现按需引入。 举个例子，我用到了展开运算符...，那么经过@babel/plugin-transform-runtime处理后的结果是这样的： 123456789101112131415161718/* 0 *//***/ (function(module, exports, __webpack_require__) {var arrayWithoutHoles = __webpack_require__(2);var iterableToArray = __webpack_require__(3);var nonIterableSpread = __webpack_require__(4);function _toConsumableArray(arr) { return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();}module.exports = _toConsumableArray; // EXTERNAL MODULE: ../node_modules/@babel/runtime/helpers/toConsumableArray.jsvar toConsumableArray = __webpack_require__(0);var toConsumableArray_default = /*#__PURE__*/__webpack_require__.n(toConsumableArray); 安装和简单配置@babel/runtime是需要按需引入到生产环境中的，而@babel/plugin-transform-runtime是babel辅助插件。因此安装方式如下： 12npm i --save @babel/runtimenpm i --save-dev @babel/plugin-transform-runtime 配置时也挺简单： 123456789const buildConfig = { presets: [ // ...... ], plugins: [ \"@babel/plugin-transform-runtime\" ], // ......} @babel/runtime和useBuiltIns: ‘usage’有什么区别？两者看起来都实现了按需加载的能力，但是实际上作用是不一样的。@babel/runtime处理的是语法支持，把新的语法糖转为目标环境支持的语法；而useBuiltIns: 'usage'处理的是垫片polyfill，为旧的环境提供新的全局对象，如Promise等，提供新的原型方法支持，如Array.prototype.includes等。如果你开发的是组件库，一般不建议处理polyfill的，应该由调用者去做这些支持，防止重复的polyfill。 开发组件时，如果仅使用@babel/plugin-transform-runtime 加上useBuiltIns: 'usage'，多了很多不必要的包。 babel@7要注意的地方最后简单地提一下使用babel@7要注意的地方，当然更详细的内容还是要看babel官方。 babel@7相关的包命名都改了，基本是@babel/plugin-xxx, @babel/preset-xxx这种形式。这是开发插件体系时一个比较标准的命名和目录组织规范。 建议用babel.config.js代替.babelrc，这在你要支持不同环境时特别有用。 babel@7已经移除了stage-x的presets，也不鼓励再使用@babel/polyfill。 不要再使用babel-preset-es2015, babel-preset-es2016等preset了，应该用@babel/preset-env代替。 …… 结语本人只是对babel有个粗略的认识，所以这是一篇babel入门的简单介绍，并没有提到深入的内容，可能也存在错误之处。自己翻来覆去也看过好几遍babel的文档了，一直觉得收获不大，也没理解到什么东西，在与webpack配合使用的过程中，还是有很多疑惑没搞懂的。其实错在自己不该在复杂的项目中直接去实践。在最近重新学习webpack和babel的过程中，我觉得，对于不是很懂的东西，我们不妨从写一个hello world开始，因为不是每个人都是理解能力超群的天才…… 首发于掘金社区","link":"/入门babel，我们需要了解些什么.html"},{"title":"关于数据类型的一些小疑惑","text":"上期在阅读《Javascript权威指南》第六版类型转换这一章节的时候，我虽然搞清楚了之前留下的很多疑问，比如说数据类型转换的基本规则，对象到原始值的转换规则等。但是对于书中3.8.3节（对象转换为原始值）中的一段文字存有疑惑，今天回头又看了一遍，总算是搞明白了。 首先引用下这段文字。 “+”和“==”应用的对象到原始值的转换包含日期对象的一种特殊情形。日期类是JavaScript语言核心中唯一的预先定义类型，它定义了有意义的向字符串和数字类型的转换。对于所有非日期的对象来说，对象到原始值的转换基本上是对象到数字的转换（首先调用valueOf），日期对象则使用对象到字符串的转换模式，然而，这里的转换和上文讲述的并不完全一致：通过valueOf或toString返回的原始值将被直接使用，而不会被强制转换为数字或字符串。 和“==”一样，“&lt;”运算符以及其他关系运算符也会做对象到原始值的转换，但要除去日期对象的特殊情形：任何对象都会首先尝试调用valueOf，然后调用toString。不管得到的原始值是否直接使用，它都不会进一步被转换为数字或字符串。 “+”、“==”、“!=”和关系运算符是唯一执行这种特殊的字符串到原始值的转换方式的运算符。其他运算符到特定类型的转换都很明确，而且对日期对象来讲也没有特殊情况。例如“-”（减号）运算符把它的两个操作数都转换为数字。 复制这么长一段文字呢，也不是为了凑字数，是我一开始真的没看明白这段。因为我一直纠结在这节内容前面说的对象转换为原始值的规则，死死地认为： 对象转原始值都应该按照两条路线走，一条路线是转为字符串，一条路线是转为数字。 对象转为字符串这条路线，是优先调用toString()方法，其次调用valueOf()方法，如果最后得到的原始值不是字符串，再把这个原始值转为字符串。 对象转为数字这条路线，是优先调用valueOf()方法，其次调用toString()方法，如果最后得到的原始值不是数字，再把这个原始值转为数字。 否则就抛出类型错误。 这里写的转换规则比较粗略了，因为上一篇笔记中已经提到了比较详细的规则了，这里就捡重点看了。 掉进这个规则里，我就产生了固化思维，觉得所有的对象转原始值的情况都应该按这个规则来。所以对上面引用的这段话就开始想不明白了。大概产生了这些疑问： 引文中第一段的最后一句“通过valueOf或toString返回的原始值将被直接使用，而不会被强制转换为数字或字符串。”。我的疑惑是：为什么最后不会再强制转换了？ 第二段中提到的“关系运算符中对象到原始值的转换，都会首先调用valueOf，然后调用toString”。我的疑惑是：为什么日期对象又不特殊处理（首先调用toString）了呢？ 其实我上篇写到最后一小节隐式转换的时候，已经提到了，不同运算符对于对象的转换规则是特殊的。 在不同的使用场景中，javascript会根据实际情况进行类型的隐式转换。 可能是写完之后回头看这段文字又串戏了，懵逼了。 其实还是要看javascript到底期望什么类型的操作数。之所以+， ==比较特殊，是因为javascript不太明确操作数的类型。 就拿+来说吧，可能是用来做数字加法，也可能是用来拼接字符串。所以javascript必须把这些情况都考虑到，针对这个运算符来定个特殊的规则。 而==是相等运算符，与恒等运算符===是不一样的。恒等运算符会首先判断数据类型是否一致，而==运算符不要求两个操作数类型一致，当两个操作数不一致时，会按照一定的规则进行操作数的隐式转换。 而一些其他算术运算符，比如-, *, /，它们都很明确操作数的类型，希望操作数是数字。所以即使你给的操作数不是数字，它也会转为数字来运算。 所以，如果其中一个操作数是对象，会发生对象到原始值的转换，然后这个原始值也会被转为数字（如果这个原始值本身不是数字）。 12345var a = {name: '飞白'};a / 2; // NaNvar b = new Date();b / 2; // 795202699143 大概的思路是这个样子的，而每个运算符是怎么样的一个运算流程，还是要看去看它的官方说明。 写这么一篇没什么实际内容的东西，主要还是想记录下自己的这种疑惑吧，希望自己以后不要再被这种文字绕进去了，要多想想程序这样设计到底是为了解决什么问题，这样才能更容易理解或猜到规则背后的逻辑。","link":"/关于数据类型的一些小疑惑.html"},{"title":"写给自己的Object和Function的3个灵魂拷问","text":"最近在研究函数和原型链这块内容时，我遇到了不少疑惑，对自己而言，这些疑惑可以算得上是灵魂拷问吧。在一步步探究和查证的过程中，我也许理解了一部分，也许还是什么都没懂吧，以文记之，只求能收获二三分。不知这里面有没有你遇到的疑惑呢？一起来看下吧！ Object和Function谁是谁的实例Object instanceof Functioninstanceof检查的是右操作数的prototype属性是否在左操作数的原型链上。 首先Object是一个对象类型的构造函数，而函数的构造函数是谁，当然是函数的鼻祖Function。所以Object是Function的实例这一点还是比较容易理解的。 12Object.__proto__ === Function.prototype;// true 其实通过下面的代码也可以侧面证明Object是Function的实例。 12Object.constructor === Function;// true Function instanceof ObjectFunction反过来又是Object的实例，这又该如何理解呢？我们知道，除去null这种情况，原型链的顶端是Object.prototype，这一定程度上说明了javascript中所有的引用类型都是由Object.prototype构造而来。 按照我们一般的思路来看，实例的原型可以通过构造函数的prototype属性来访问。那么这里的实例主角是谁？没错，是Function，那么Function有构造函数吗？显然，在我们认知的javascript中，Function本身就是函数的构造器，自然是没有Function的构造函数的，有的话，那也是V8引擎干的事了吧。 那么没有构造函数就不配有原型了吗？答案是否定的。还记得我在「思维导图学前端 」6k字一文搞懂Javascript对象，原型，继承中提到的Object.create()方法吗？通过Object.create()可以直接创建一个新对象，并可以指定现有的对象作为这个新对象的原型，此过程并没有构造函数参与进来。你想啊，连ES5暴露给我们的API都能这么做，那么在实现V8等js引擎的过程当然也可以这么做。 所以，Function也有原型，也就是Function.__proto__。那么Function.__proto__到底指向哪里？我们可以从下面这个语句中发现端倪。 12Function.__proto__ === Function.prototype;// true 上面的表达式的结果是true。震惊，Function.__proto__竟然是Function.prototype！ 而Function.prototype的原型就是Object.prototype。这一点可以从下面的语句中得到验证！ 12Function.prototype.__proto__ === Object.prototype;// true 由于从Function到Object.prototype存在这样一段原型链关系，所以Function instanceof Object也是成立的。 Object instanceof Object从上面我们已经知道Object instanceof Function和Function instanceof Object都是成立的。根据这些已知结果，我们很容易推断出Object instanceof Object也是成立的。这是因为Object是Function的实例，Function是Object的实例，显然Object也是Object的实例。 1Object instanceof Object; // true Function instanceof Function有了以上的推论过程，我们自然也能理解Function instanceof Function是成立的。 Function.prototype是一个函数？12345Function.prototype;// ƒ () { [native code] }// 以下代码可以正常执行Function.prototype(); Function.prototype()可以执行，不会报错，说明Function.prototype真的是一个函数。 1typeof Function.prototype; // \"function\" 还有个有意思的地方，就是： 12Function.prototype.constructor === Function;// true 666，Function的原型指向Function.prototype，而Function.prototype的构造器反过来又是Function，有内味了！ 回头想了一下，这是原型三角关系，思考这部分的时候有点被绕进去了，小题大做了。 Function和Object鸡生蛋蛋生鸡？有了上面这些复杂的关系，我们不免要问问自己，到底是先有Object还是Function？ 我也尝试从V8源码去找一些线索，但是恕我太菜，学校教的C++基本忘光了，从源码中完全找不到思路。V8的官方文档也没有说这些东西（可能是我没找到吧）。 于是我找了一些分析这个问题的文章，大概有了一些认知。重要的事情说三遍： 只是认知，不是答案！ 只是认知，不是答案！ 只是认知，不是答案！ 毕竟我也没找到直接甩V8源码进行分析的文章，如果有大佬知道这方面资源，还望分享一下链接，感谢！ OK，总体的认知是这样的，加了一些我的理解在里面，希望对你有所帮助！ V8先构造了Object的原型[[Prototype]]，简称OP，初始化其内部属性，但不包括其行为。这里有必要猜想一下，这里说的“内部属性”应该是OP在V8引擎中的属性，因为我看Object.prototype基本上是没有属性的，只有方法。而行为，则代表方法。 基于OP构造了Function的原型[[Prototype]]，简称FP，初始化其内部属性，但不包括其行为。 将FP的原型[[Prototype]]指向OP。 创建各种内置引用类型如Object, Function, Array, Date等。 将各个内置引用类型的[[Prototype]]指向FP。 将Function的prototype属性指向FP。 将Object的prototype属性指向OP。 用Function实例化OP，FP，Object的行为并挂载。这里别看错了，是实例化行为，也就是把OP，FP，Object的方法创建好，然后挂载到相应对象上。 用Object实例化除了Object及Function之外的其他内置引用类型的prototype属性对象。除了之外这四个字是一个要关注的重点，另一个重点就是要理解prototype是一个对象，所以用Object实例化。 用Function实例化除了Object及Function之外的其他内置引用类型的prototype属性对象的行为并挂载。我们知道，prototype是一个对象，在上一步被创建了，prototype对象下会有很多方法，比如数组的push()方法，就是在这个时候被创建的。而方法当然是用Function实例化。 实例化内置对象Math以及Global对象。 上面说的[[Prototype]]指的是一个对象的原型，与我们所熟知的prototype是有区别的，prototype只是一个属性，是指向原型的一个引用。 理清[[Prototype]]和prototype的关系后，再仔细去想想，你会发现上面说的这些步骤是有道理的。慢慢品味吧！ 所以严格上来说，Function和Object没有创建时间上的先后顺序关系，与它们相比，先出现的也是它们的原型[[Prototype]]。而在它们的原型中，先有的是Object的原型，后有的是Function的原型。 Function和Object没有所谓的鸡生蛋和蛋生鸡的关系，它们之间是一种互相成就的关系。 灵魂拷问总是让人难以回答，啰嗦了一番，不知道我懂了没，也不知道在座的各位懂了没…… 可以参考的资料有： ECMAScript5注解 高能！typeof Function.prototype 引发的先有 Function 还是先有 Object 的探讨","link":"/写给自己的Object和Function的3个灵魂拷问.html"},{"title":"彻底搞懂闭包，柯里化，手写代码，金九银十不再丢分！","text":"这段时间我试着通过思维导图来总结知识点，主要关注的是一些相对重要或理解难度较高的内容。下面是同系列文章： 「思维导图学前端 」6k字一文搞懂Javascript对象，原型，继承 「思维导图学前端 」初中级前端值得收藏的正则表达式知识点扫盲 如果您需要换个角度看闭包，请直接打开解读闭包，这次从ECMAScript词法环境，执行上下文说起。 本文总结了javascript中函数的常见知识点，包含了基础概念，闭包，this指向问题，高阶函数，柯里化等，手写代码那部分也是满满的干货，无论您是想复习准备面试，还是想深入了解原理，本文都应该有你想看的点，总之还是值得一看的。 老规矩，先上思维导图。 什么是函数 一般来说，一个函数是可以通过外部代码调用的一个“子程序”（或在递归的情况下由内部函数调用）。像程序本身一样，一个函数由称为函数体的一系列语句组成。值可以传递给一个函数，函数将返回一个值。 函数首先是一个对象，并且在javascript中，函数是一等对象（first-class object）。函数可以被执行（callable，拥有内部属性[[Call]]），这是函数的本质特性。除此之外，函数可以赋值给变量，也可以作为函数参数，还可以作为另一个函数的返回值。 函数基本概念函数名函数名是函数的标识，如果一个函数不是匿名函数，它应该被赋予函数名。 函数命名需要符合javascript标识符规则，必须以字母、下划线_或美元符$开始，后面可以跟数字，字母，下划线，美元符。 函数命名不能使用javascript保留字，保留字是javascript中具有特殊含义的标识符。 函数命名应该语义化，尽量采用动宾结构，小驼峰写法，比如getUserName()，validateForm(), isValidMobilePhone()。 对于构造函数，我们通常写成大驼峰格式（因为构造函数与类的概念强关联）。 下面是一些不成文的约定，不成文代表它不必遵守，但是我们按照这样的约定来执行，会让开发变得更有效率。 __xxx__代表非标准的方法。 _xxx代表私有方法。 函数参数形参形参是函数定义时约定的参数列表，由一对圆括号()包裹。 在MDN上有看到，一个函数最多可以有255个参数。 然而形参太多时，使用者总是容易在引用时出错。所以对于数量较多的形参，一般推荐把所有参数作为属性或方法整合到一个对象中，各个参数作为这个对象的属性或方法来使用。举个例子，微信小程序的提供的API基本上是这种调用形式。 1wx.redirectTo(Object object) 调用示例如下： 12345wx.redirectTo({ url: '/article/detail?id=1', success: function() {}, fail: function() {}}) 形参的数量可以由函数的length属性获得，如下所示。 12function test(a, b, c) {}test.length; // 3 实参实参是调用函数时传入的，实参的值在函数执行前被确定。 javascript在函数定义时并不会约定参数的数据类型。如果你期望函数调用时传入正确的数据类型，你必须在函数体中对入参进行数据类型判断。 12345function add(a, b) { if (typeof a !== 'number' || typeof b !== 'number') { throw new Error(\"参数必须是数字类型\") }} 好在Typescript提供了数据类型检查的能力，这一定程度上防止了意外情况的发生。 实参的数量可以通过函数中arguments对象的length属性获得，如下所示。 实参数量不一定与形参数量一致。 12345function test(a, b, c) { var argLength = arguments.length; return argLength;}test(1, 2); // 2 默认参数函数参数的默认值是undefined，如果你不传入实参，那么实际上在函数执行过程中，相应参数的值是undefined。 ES6也支持在函数声明时设置参数的默认值。 1234function add(a, b = 2) { return a + b;}add(1); // 3 在上面的add函数中，参数b被指定了默认值2。所以，即便你不传第二个参数b，也能得到一个预期的结果。 假设一个函数有多个参数，我们希望不给中间的某个参数传值，那么这个参数值必须显示地指定为undefined，否则我们期望传给后面的参数的值会被传到中间的这个参数。 1234567function printUserInfo(name, age = 18, gender) { console.log(`姓名：${name}，年龄：${age}，性别：${gender}`);}// 正确地使用printUserInfo('Bob', undefined, 'male');// 错误，'male'被错误地传给了age参数printUserInfo('Bob', 'male'); PS：注意，如果你希望使用参数的默认值，请一定传undefined，而不是null。 当然，我们也可以在函数体中判断参数的数据类型，防止参数被误用。 123456789function printUserInfo(name, age = 18, gender) { if (typeof arguments[1] === 'string') { age = 18; gender = arguments[1]; } console.log(`姓名：${name}，年龄：${age}，性别：${gender}`);}printUserInfo('bob', 'male'); // 姓名：bob，年龄：18，性别：male 这样一来，函数的逻辑也不会乱。 剩余参数 剩余参数语法允许我们将一个不定数量的参数表示为一个数组。 剩余参数通过剩余语法...将多个参数聚合成一个数组。 12345function add(a, ...args) { return args.reduce((prev, curr) =&gt; { return prev + curr }, a)} 剩余参数和arguments对象之间的区别主要有三个： 剩余参数只包含那些没有对应形参的实参，而arguments对象包含了传给函数的所有实参。 arguments对象不是一个真正的数组，而剩余参数是真正的Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如sort，map，forEach或pop。而arguments需要借用call来实现，比如[].slice.call(arguments)。 arguments对象还有一些附加的属性（如callee属性）。 剩余语法和展开运算符看起来很相似，然而从功能上来说，是完全相反的。 剩余语法(Rest syntax) 看起来和展开语法完全相同，不同点在于, 剩余参数用于解构数组和对象。从某种意义上说，剩余语法与展开语法是相反的：展开语法将数组展开为其中的各个元素，而剩余语法则是将多个元素收集起来并“凝聚”为单个元素。 arguments函数的实际参数会被保存在一个类数组对象arguments中。 类数组（ArrayLike）对象具备一个非负的length属性，并且可以通过从0开始的索引去访问元素，让人看起来觉得就像是数组，比如NodeList，但是类数组默认没有数组的那些内置方法，比如push, pop, forEach, map。 我们可以试试，随便找一个网站，在控制台输入： 1var linkList = document.querySelectorAll('a') 会得到一个NodeList，我们也可以通过数字下标去访问其中的元素，比如linkList[0]。 但是NodeList不是数组，它是类数组。 1Array.isArray(linkList); // false 回到主题，arguments也是类数组，arguments的length由实参的数量决定，而不是由形参的数量决定。 123456function add(a, b) { console.log(arguments.length); return a + b;}add(1, 2, 3, 4);// 这里打印的是4，而不是2 arguments也是一个和严格模式有关联的对象。 在非严格模式下，arguments里的元素和函数参数都是指向同一个值的引用，对arguments的修改，会直接影响函数参数。 123456function test(obj) { arguments[0] = '传入的实参是一个对象，但是被我变成字符串了' console.log(obj)}test({name: 'jack'})// 这里打印的是字符串，而不是对象 在严格模式下，arguments是函数参数的副本，对arguments的修改不会影响函数参数。但是arguments不能重新被赋值，关于这一点，我在解读闭包，这次从ECMAScript词法环境，执行上下文说起这篇文章中解读不可变绑定时有提到。在严格模式下，也不能使用arguments.caller和arguments.callee，限制了对调用栈的检测能力。 函数体函数体（FunctionBody）是函数的主体，其中的函数代码(function code)由一对花括号{}包裹。函数体可以为空，也可以由任意条javascript语句组成。 函数的调用形式大体来说，函数的调用形式分为以下四种： 作为普通函数函数作为普通函数被调用，这是函数调用的常用形式。 1234function add(a, b) { return a + b;}add(); // 调用add函数 作为普通函数调用时，如果在非严格模式下，函数执行时，this指向全局对象，对于浏览器而言则是window对象；如果在严格模式下，this的值则是undefined。 作为对象的方法函数也可以作为对象的成员，这种情况下，该函数通常被称为对象方法。当函数作为对象的方法被调用时，this指向该对象，此时便可以通过this访问对象的其他成员变量或方法。 1234567var counter = { num: 0, increase: function() { this.num++; }}counter.increase(); 作为构造函数函数配合new关键字使用时就成了构造函数。构造函数用于实例化对象，构造函数的执行过程大致如下： 首先创建一个新对象，这个新对象的__proto__属性指向构造函数的prototype属性。 此时构造函数的this指向这个新对象。 执行构造函数中的代码，一般是通过this给新对象添加新的成员属性或方法。 最后返回这个新对象。 实例化对象也可以通过一些技巧来简化，比如在构造函数中显示地return另一个对象，jQuery很巧妙地利用了这一点。具体分析详见面试官真的会问：new的实现以及无new实例化。 通过call, apply调用apply和call是函数对象的原型方法，挂载于Function.prototype。利用这两个方法，我们可以显示地绑定一个this作为调用上下文，同时也可以设置函数调用时的参数。 apply和call的区别在于：提供参数的形式不同，apply方法接受的是一个参数数组，call方法接受的是参数列表。 12someFunc.call(obj, 1, 2, 3)someFunc.apply(obj, [1, 2, 3]) 注意，在非严格模式下使用call或者apply时，如果第一个参数被指定为null或undefined，那么函数执行时的this指向全局对象（浏览器环境中是window）；如果第一个参数被指定为原始值，该原始值会被包装。这部分内容在下文中的手写代码会再次讲到。 call是用来实现继承的重要方法。在子类构造函数中，通过call来调用父类构造函数，以使对象实例获得来自父类构造函数的属性或方法。 12345678910function Father() { this.nationality = 'Han';};Father.prototype.propA = '我是父类原型上的属性';function Child() { Father.call(this);};Child.prototype.propB = '我是子类原型上的属性';var child = new Child();child.nationality; // \"Han\" call, apply, bindcall，apply，bind都可以绑定this，区别在于：apply和call是绑定this后直接调用该函数，而bind会返回一个新的函数，并不直接调用，可以由程序员决定调用的时机。 bind的语法形式如下： 1function.bind(thisArg[, arg1[, arg2[, ...]]]) bind的arg1, arg2, ...是给新函数预置好的参数（预置参数是可选的）。当然新函数在执行时也可以继续追加参数。 手写call, apply, bind提到call，apply，bind总是无法避免手写代码这个话题。手写代码不仅仅是为了应付面试，也是帮助我们理清思路和深入原理的一个好方法。手写代码一定不要抄袭，如果实在没思路，可以参考下别人的代码整理出思路，再自己按照思路独立写一遍代码，然后验证看看有没有缺陷，这样才能有所收获，否则忘得很快，只能短时间应付应付。 那么如何才能顺利地手写代码呢？首先是要清楚一段代码的作用，可以从官方对于它的定义和描述入手，同时还要注意一些特殊情况下的处理。 就拿call来说，call是函数对象的原型方法，它的作用是绑定this和参数，并执行函数。调用形式如下： 1function.call(thisArg, arg1, arg2, ...) 那么我们慢慢来实现它，将我们要实现的函数命名为myCall。首先myCall是一个函数，接受的第一个参数thisArg是目标函数执行时的this的值，从第二个可选参数arg1开始的其他参数将作为目标函数执行时的实参。 这里面有很多细节要考虑，我大致罗列了一下： 要考虑是不是严格模式。如果是非严格模式，对于thisArg要特殊处理。 如何判断严格模式？ thisArg被处理后还要进行非空判断，然后考虑是以方法的形式调用还是以普通函数的形式调用。 目标函数作为方法调用时，如何不覆盖对象的原有属性？ 实现代码如下，请仔细看我写的注释，这是主要的思路！ 12345678910111213141516171819202122232425262728293031323334353637383940414243// 首先apply是Function.prototype上的一个方法Function.prototype.myCall = function() { // 由于目标函数的实参数量是不定的，这里就不写形参了 // 实际上通过arugments对象，我们能拿到所有实参 // 第一个参数是绑定的this var thisArg = arguments[0]; // 接着要判断是不是严格模式 var isStrict = (function(){return this === undefined}()) if (!isStrict) { // 如果在非严格模式下，thisArg的值是null或undefined，需要将thisArg置为全局对象 if (thisArg === null || thisArg === undefined) { // 获取全局对象时兼顾浏览器环境和Node环境 thisArg = (function(){return this}()) } else { // 如果是其他原始值，需要通过构造函数包装成对象 var thisArgType = typeof thisArg if (thisArgType === 'number') { thisArg = new Number(thisArg) } else if (thisArgType === 'string') { thisArg = new String(thisArg) } else if (thisArgType === 'boolean') { thisArg = new Boolean(thisArg) } } } // 截取从索引1开始的剩余参数 var invokeParams = [...arguments].slice(1); // 接下来要调用目标函数，那么如何获取到目标函数呢？ // 实际上this就是目标函数，因为myCall是作为一个方法被调用的，this当然指向调用对象，而这个对象就是目标函数 // 这里做这么一个赋值过程，是为了让语义更清晰一点 var invokeFunc = this; // 此时如果thisArg对象仍然是null或undefined，那么说明是在严格模式下，并且没有指定第一个参数或者第一个参数的值本身就是null或undefined，此时将目标函数当成普通函数执行并返回其结果即可 if (thisArg === null || thisArg === undefined) { return invokeFunc(...invokeParams) } // 否则，让目标函数成为thisArg对象的成员方法，然后调用它 // 直观上来看，可以直接把目标函数赋值给对象属性，比如func属性，但是可能func属性本身就存在于thisArg对象上 // 所以，为了防止覆盖掉thisArg对象的原有属性，必须创建一个唯一的属性名，可以用Symbol实现，如果环境不支持Symbol，可以通过uuid算法来构造一个唯一值。 var uniquePropName = Symbol(thisArg) thisArg[uniquePropName] = invokeFunc // 返回目标函数执行的结果 return thisArg[uniquePropName](...invokeParams)} 写完又思考了一阵，我突然发现有个地方考虑得有点多余了。 12345// 如果在非严格模式下，thisArg的值是null或undefined，需要将thisArg置为全局对象if (thisArg === null || thisArg === undefined) { // 获取全局对象时兼顾浏览器环境和Node环境 thisArg = (function(){return this}())} else { 其实这种情况下不用处理thisArg，因为代码执行到该函数后面部分，目标函数会被作为普通函数执行，那么this自然指向全局对象！所以这段代码可以删除了！ 接着来测试一下myCall是否可靠，我写了一个简单的例子： 123456789101112131415function test(a, b) { var args = [].slice.myCall(arguments) console.log(arguments, args)}test(1, 2)var obj = { name: 'jack'};var name = 'global';function getName() { return this.name;}getName();getName.myCall(obj); 我不敢保证我写的这个myCall方法没有bug，但也算是考虑了很多情况了。就算是在面试过程中，面试官主要关注的就是你的思路和考虑问题的全面性，如果写到这个程度还不能让面试官满意，那也无能为力了…… 理解了手写call之后，手写apply也自然触类旁通，只要注意两点即可。 myApply接受的第二个参数是数组形式。 要考虑实际调用时不传第二个参数或者第二个参数不是数组的情况。 直接上代码： 12345678910111213141516171819202122Function.prototype.myApply = function(thisArg, params) { var isStrict = (function(){return this === undefined}()) if (!isStrict) { var thisArgType = typeof thisArg if (thisArgType === 'number') { thisArg = new Number(thisArg) } else if (thisArgType === 'string') { thisArg = new String(thisArg) } else if (thisArgType === 'boolean') { thisArg = new Boolean(thisArg) } } var invokeFunc = this; // 处理第二个参数 var invokeParams = Array.isArray(params) ? params : []; if (thisArg === null || thisArg === undefined) { return invokeFunc(...invokeParams) } var uniquePropName = Symbol(thisArg) thisArg[uniquePropName] = invokeFunc return thisArg[uniquePropName](...invokeParams)} 用比较常用的Math.max来测试一下： 12Math.max.myApply(null, [1, 2, 4, 8]);// 结果是8 接下来就是手写bind了，首先要明确，bind与call, apply的不同点在哪里。 bind返回一个新的函数。 这个新的函数可以预置参数。 好的，按照思路开始写代码。 1234567891011121314151617181920Function.prototype.myBind = function() { // 保存要绑定的this var boundThis = arguments[0]; // 获得预置参数 var boundParams = [].slice.call(arguments, 1); // 获得绑定的目标函数 var boundTargetFunc = this; if (typeof boundTargetFunc !== 'function') { throw new Error('绑定的目标必须是函数') } // 返回一个新的函数 return function() { // 获取执行时传入的参数 var restParams = [].slice.call(arguments); // 合并参数 var allParams = boundParams.concat(restParams) // 新函数被执行时，通过执行绑定的目标函数获得结果，并返回结果 return boundTargetFunc.apply(boundThis, allParams) }} 本来写到这觉得已经结束了，但是翻到一些资料，都提到了手写bind需要支持new调用。仔细一想也对，bind返回一个新的函数，这个函数被作为构造函数使用也是很有可能的。 我首先思考的是，能不能直接判断一个函数是不是以构造函数的形式执行的呢？如果能判断出来，那么问题就相对简单了。 于是我想到构造函数中很重要的一点，那就是在构造函数中，this指向对象实例。所以，我利用instanceof改了一版代码出来。 12345678910111213141516171819202122Function.prototype.myBind = function() { var boundThis = arguments[0]; var boundParams = [].slice.call(arguments, 1); var boundTargetFunc = this; if (typeof boundTargetFunc !== 'function') { throw new Error('绑定的目标必须是函数') } function fBound () { var restParams = [].slice.call(arguments); var allParams = boundParams.concat(restParams) // 通过instanceof判断this是不是fBound的实例 var isConstructor = this instanceof fBound; if (isConstructor) { // 如果是，说明是通过new调用的（这里有bug，见下文），那么只要把处理好的参数传给绑定的目标函数，并通过new调用即可。 return new boundTargetFunc(...allParams) } else { // 如果不是，说明不是通过new调用的 return boundTargetFunc.apply(boundThis, allParams) } } return fBound} 最后看了一下MDN提供的bind函数的polyfill，发现思路有点不一样，于是我通过一个实例进行对比。 1234567function test() {}var fBoundNative = test.bind()var obj1 = new fBoundNative()var fBoundMy = test.myBind()var obj2 = new fBoundMy()var fBoundMDN = test.mdnBind()var obj3 = new fBoundMDN() 我发现我的写法看起来竟然更像原生bind。瞬间怀疑自己，但一下子却没找到很明显的bug…… 终于我还是意识到了一个很大的问题，obj1是fBoundNative的实例，obj3是fBoundMDN的实例，但obj2不是fBoundMy的实例（实际上obj2是test的实例）。 123obj1 instanceof fBoundNative; // trueobj2 instanceof fBoundMy; // falseobj3 instanceof fBoundMDN; // true 存在这个问题麻烦就大了，假设我要在fBoundMy.prototype上继续扩展原型属性或方法，obj2是无法继承它们的。所以最直接有效的方法就是用继承的方法来实现，虽然不能达到原生bind的效果，但已经够用了。于是我参考MDN改了一版。 123456789101112131415Function.prototype.myBind = function() { var boundTargetFunc = this; if (typeof boundTargetFunc !== 'function') { throw new Error('绑定的目标必须是函数') } var boundThis = arguments[0]; var boundParams = [].slice.call(arguments, 1); function fBound () { var restParams = [].slice.call(arguments); var allParams = boundParams.concat(restParams) return boundTargetFunc.apply(this instanceof fBound ? this : boundThis, allParams) } fBound.prototype = Object.create(boundTargetFunc.prototype || Function.prototype) return fBound} 这里面最重要的两点：处理好原型链关系，以及理解bind中构造实例的过程。 原型链处理 1fBound.prototype = Object.create(boundTargetFunc.prototype || Function.prototype) 这一行代码中用了一个||运算符，||的两端充分考虑了myBind函数的两种可能的调用方式。 常规的函数绑定 123456function test(name, age) { this.name = name; this.age = age;}var bound1 = test.myBind('小明')var obj1 = new bound1(18) 这种情况把fBound.prototype的原型指向boundTargetFunc.prototype，完全符合我们的思维。 直接使用Function.prototype.myBind 12var bound2 = Function.prototype.myBind()var obj2 = new bound2() 这相当于创建一个新的函数，绑定的目标函数是Function.prototype。这里必然有朋友会问了，Function.prototype也是函数吗？是的，请看！ 1typeof Function.prototype; // \"function\" 虽然我还不知道第二种调用方式存在的意义，但是存在即合理，既然存在，我们就支持它。 理解bind中构造实例的过程 首先要清楚new的执行过程，如果您还不清楚这一点，可以看看我写的这篇面试官真的会问：new的实现以及无new实例化。 还是之前那句话，先要判断是不是以构造函数的形式调用的。核心就是这： 1this instanceof fBound 我们用一个例子再来分析下new的过程。 12345678function test(name, age) { this.name = name; this.age = age;}var bound1 = test.myBind('小明')var obj1 = new bound1(18)obj1 instanceof bound1 // trueobj1 instanceof test // true 执行构造函数bound1，实际上是执行myBind执行后返回的新函数fBound。首先会创建一个新对象obj1，并且obj1的非标准属性__proto__指向bound1.prototype，其实就是myBind执行时声明的fBound.prototype，而fBound.prototype的原型指向test.prototype。所以到这里，原型链就串起来了！ 执行的构造函数中，this指向这个obj1。 执行构造函数，由于fBound是没有实际内容的，执行构造函数本质上还是要去执行绑定的那个目标函数，本例中也就是test。因此如果是以构造函数形式调用，我们就把实例对象作为this传给test.apply。 通过执行test，对象实例被挂载了name和age属性，一个崭新的对象就出炉了！ 最后附上Raynos大神写的bind实现，我感觉又受到了“暴击”！有兴趣钻研bind终极奥义的朋友请点开链接查看源码！ this指向问题分析this的指向，首先要确定当前执行代码的环境。 全局环境中的this指向全局环境中，this指向全局对象（视宿主环境而定，浏览器是window，Node是global）。 函数中的this指向在上文中介绍函数的调用形式时已经比较详细地说过this指向问题了，这里再简单总结一下。 函数中this的指向取决于函数的调用形式，在一些情况下也受到严格模式的影响。 作为普通函数调用：严格模式下，this的值是undefined，非严格模式下，this指向全局对象。 作为方法调用：this指向所属对象。 作为构造函数调用：this指向实例化的对象。 通过call, apply, bind调用：如果指定了第一个参数thisArg，this的值就是thisArg的值（如果是原始值，会包装为对象）；如果不传thisArg，要判断严格模式，严格模式下this是undefined，非严格模式下this指向全局对象。 函数声明和函数表达式撕了这么久代码，让大脑休息一会儿，先看点轻松点的内容。 函数声明函数声明是独立的函数语句。 1function test() {} 函数声明存在提升（Hoisting）现象，如变量提升一般，对于同名的情况，函数声明优于变量声明（前者覆盖后者，我说的是声明阶段哦）。 函数表达式函数表达式不是独立的函数语句，常作为表达式的一部分，比如赋值表达式。 函数表达式可以是命名的，也可以是匿名的。 1234// 命名函数表达式var a = function test() {}// 匿名函数表达式var b = function () {} 匿名函数就是没有函数名的函数，它不能单独使用，只能作为表达式的一部分使用。匿名函数常以IIFE（立即执行函数表达式）的形式使用。 1(function(){console.log(\"我是一个IIFE\")}()) 闭包关于闭包，我已经写了一篇超详细的文章去分析了，是个人原创总结的干货，建议直接打开解读闭包，这次从ECMAScript词法环境，执行上下文说起。 PS：阅读前，您应该对ECMAScript5的一些术语有一些简单的了解，比如Lexical Environment, Execution Context等。 纯函数 纯函数是具备幂等性（对于相同的参数，任何时间执行纯函数都将得到同样的结果），它不会引起副作用。 纯函数与外部的关联应该都来源于函数参数。如果一个函数直接依赖了外部变量，那它就不是纯函数，因为外部变量是可变的，那么纯函数的执行结果就不可控了。 1234567891011121314// 纯函数function pure(a, b) { return a + b;}// 非纯函数function impure(c) { return c + d}var d = 10;pure(1, 2); // 3impure(1); // 11d = 20;impure(1); // 21pure(1, 2); // 3 惰性函数相信大家在兼容事件监听时，都写过这样的代码。 123456789function addEvent(element, type, handler) { if (window.addEventListener) { element.addEventListener(type, handler, false); } else if (window.attachEvent){ element.attachEvent('on' + type, handler); } else { element['on' + type] = handler; }} 仔细看下，我们会发现，每次调用addEvent，都会做一次if-else的判断，这样的工作显然是重复的。这个时候就用到惰性函数了。 惰性函数表示函数执行的分支只会在函数第一次调用的时候执行。后续我们所使用的就是这个函数执行的结果。 利用惰性函数的思维，我们可以改造下上述代码。 12345678910111213141516function addEvent(element, type, handler) { if (window.addEventListener) { addEvent = function(element, type, handler) { element.addEventListener(type, handler, false); } } else if (window.attachEvent){ addEvent = function(element, type, handler) { element.attachEvent('on' + type, handler); } } else { addEvent = function(element, type, handler) { element['on' + type] = handler; } } addEvent(element, type, handler);} 这代码看起来有点low，但是它确实减少了重复的判断。在这种方式下，函数第一次执行时才确定真正的值。 我们还可以利用IIFE提前确定函数真正的值。 123456789101112131415var addEvent = (function() { if (window.addEventListener) { return function(element, type, handler) { element.addEventListener(type, handler, false); } } else if (window.attachEvent){ return function(element, type, handler) { element.attachEvent('on' + type, handler); } } else { return function(element, type, handler) { element['on' + type] = handler; } }}()) 高阶函数函数在javascript中是一等公民，函数可以作为参数传给其他函数，这让函数的使用充满了各种可能性。 不如来看看维基百科中高阶函数（High-Order Function）的定义： 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 接受一个或多个函数作为输入 输出一个函数 看到这，大家应该都意识到了，平时使用过很多高阶函数。数组的一些高阶函数使用得尤为频繁。 1234[1, 2, 3, 4].forEach(function(item, index, arr) { console.log(item, index, arr)})[1, 2, 3, 4].map(item =&gt; `小老弟${item}`) 可以发现，传入forEach和map的就是一个函数。我们自己也可以封装一些复用的高阶函数。 我们知道Math.max可以求出参数列表中最大的值。然而很多时候，我们需要处理的数据并不是1, 2, 3, 4这么简单，而是对象数组。 假设有这么一个需求，存在一个数组，数组元素都是表示人的对象，我们想从数组中选出年纪最大的人。 这个时候，就需要一个高阶函数来完成。 123456789101112131415161718/** * 根据求值条件判断数组中最大的项 * @param {Array} arr 数组 * @param {String|Function} iteratee 返回一个求值表达式，可以根据对象属性的值求出最大项，比如item.age。也可以通过自定义函数返回求值表达式。 */function maxBy(arr, iteratee) { let values = []; if (typeof iteratee === 'string') { values = arr.map(item =&gt; item[iteratee]); } else if (typeof iteratee === 'function') { values = arr.map((item, index) =&gt; { return iteratee(item, index, arr); }); } const maxOne = Math.max(...values); const maxIndex = values.findIndex(item =&gt; item === maxOne); return arr[maxIndex];} 利用这个高阶函数，我们就可以求出数组中年纪最大的那个人。 1234567var list = [ {name: '小明', age: 18}, {name: '小红', age: 19}, {name: '小李', age: 20}]// 根据age字段求出最大项，结果是小李。var maxItem = maxBy(list, 'age'); 我们甚至可以定义更复杂的求值规则，比如我们需要根据一个字符串类型的属性来判定优先级。这个时候，就必须传一个自定义的函数作为参数了。 12345678910const list = [ {name: '小明', priority: 'middle'}, {name: '小红', priority: 'low'}, {name: '小李', priority: 'high'}]const maxItem = maxBy(list, function(item) { const { priority } = item const priorityValue = priority === 'low' ? 1 : priority === 'middle' ? 2 : priority === 'high' ? 3 : 0 return priorityValue;}); maxBy接受的参数最终都应该能转化为一个Math.max可度量的值，否则就没有可比较性了。 要理解这样的高阶函数，我们可以认为传给高阶函数的函数就是一个中间件，它把数据预处理好了，然后再转交给高阶函数继续运算。 PS：写完这句总结，突然觉得挺有道理的，反手给自己一个赞！ 柯里化说柯里化之前，首先抛出一个疑问，如何实现一个add函数，使得这个add函数可以灵活调用和传参，支持下面的调用示例呢？ 123456add(1, 2, 3) // 6add(1) // 1add(1)(2) // 3add(1, 2)(3) // 6add(1)(2)(3) // 6add(1)(2)(3)(4) // 10 要解答这样的疑问，还是要先明白什么是柯里化。 在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 这段解释看着还是挺懵逼的，不如举个例子： 本来有这么一个求和函数dynamicAdd()，接受任意个参数。 12345function dynamicAdd() { return [...arguments].reduce((prev, curr) =&gt; { return prev + curr }, 0)} 现在需要通过柯里化把它变成一个新的函数，这个新的函数预置了第一个参数，并且可以在调用时继续传入剩余参数。 看到这，我觉得有点似曾相识，预置参数的特性与bind很相像。那么我们不如用bind的思路来实现。 123456789function curry(fn, firstArg) { // 返回一个新函数 return function() { // 新函数调用时会继续传参 var restArgs = [].slice.call(arguments) // 参数合并，通过apply调用原函数 return fn.apply(this, [firstArg, ...restArgs]) }} 接着我们通过一些例子来感受一下柯里化。 123456789// 柯里化，预置参数10var add10 = curry(dynamicAdd, 10)add10(5); // 15// 柯里化，预置参数20var add20 = curry(dynamicAdd, 20);add20(5); // 25// 也可以对一个已经柯里化的函数add10继续柯里化，此时预置参数10即可var anotherAdd20 = curry(add10, 10);anotherAdd20(5); // 25 可以发现，柯里化是在一个函数的基础上进行变换，得到一个新的预置了参数的函数。最后在调用新函数时，实际上还是会调用柯里化前的原函数。 并且柯里化得到的新函数可以继续被柯里化，这看起来有点像俄罗斯套娃的感觉。 实际使用时也会出现柯里化的变体，不局限于只预置一个参数。 1234567891011function curry(fn) { // 保存预置参数 var presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 return function() { // 新函数调用时会继续传参 var restArgs = [].slice.call(arguments) // 参数合并，通过apply调用原函数 return fn.apply(this, [...presetArgs, ...restArgs]) }} 其实Function.protoype.bind就是一个柯里化的实现。不仅如此，很多流行的库都大量使用了柯里化的思想。 实际应用中，被柯里化的原函数的参数可能是定长的，也可能是不定长的。 参数定长的柯里化假设存在一个原函数fn，fn接受三个参数a, b, c，那么函数fn最多被柯里化三次（有效地绑定参数算一次）。 12345678910function fn(a, b, c) { return a + b + c}var c1 = curry(fn, 1);var c2 = curry(c1, 2);var c3 = curry(c2, 3);c3(); // 6// 再次柯里化也没有意义，原函数只需要三个参数var c4 = curry(c3, 4);c4(); 也就是说，我们可以通过柯里化缓存的参数数量，来判断是否到达了执行时机。那么我们就得到了一个柯里化的通用模式。 12345678910111213141516171819function curry(fn) { // 获取原函数的参数长度 const argLen = fn.length; // 保存预置参数 const presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 return function() { // 新函数调用时会继续传参 const restArgs = [].slice.call(arguments) const allArgs = [...presetArgs, ...restArgs] if (allArgs.length &gt;= argLen) { // 如果参数够了，就执行原函数 return fn.apply(this, allArgs) } else { // 否则继续柯里化 return curry.call(null, fn, ...allArgs) } }} 这样一来，我们的写法就可以支持以下形式。 123456789function fn(a, b, c) { return a + b + c;}var curried = curry(fn);curried(1, 2, 3); // 6curried(1, 2)(3); // 6curried(1)(2, 3); // 6curried(1)(2)(3); // 6curried(7)(8)(9); // 24 参数不定长的柯里化解决了上面的问题，我们难免会问自己，假设原函数的参数不定长呢，这种情况如何柯里化？ 首先，我们需要理解参数不定长是指函数声明时不约定具体的参数，而在函数体中通过arguments获取实参，然后进行运算。就像下面这种。 12345function dynamicAdd() { return [...arguments].reduce((prev, curr) =&gt; { return prev + curr }, 0)} 回到最开始的问题，怎么支持下面的所有调用形式？ 123456add(1, 2, 3) // 6add(1) // 1add(1)(2) // 3add(1, 2)(3) // 6add(1)(2)(3) // 6add(1)(2)(3)(4) // 10 思考了一阵，我发现在参数不定长的情况下，要同时支持1~N次调用还是挺难的。add(1)在一次调用后可以直接返回一个值，但它也可以作为函数接着调用add(1)(2)，甚至可以继续add(1)(2)(3)。那么我们实现add函数时，到底是返回一个函数，还是返回一个值呢？这让人挺犯难的，我也不能预测这个函数将如何被调用啊。 而且我们可以拿上面的成果来验证下： 1curried(1)(2)(3)(4); 运行上面的代码会报错：Uncaught TypeError: curried(…)(…)(…) is not a function，因为执行到curried(1)(2)(3)，结果就不是一个函数了，而是一个值，一个值当然是不能作为函数继续执行的。 所以如果要支持参数不定长的场景，已经柯里化的函数在执行完毕时不能返回一个值，只能返回一个函数；同时要让JS引擎在解析得到的这个结果时，能求出我们预期的值。 大家看了这个可能还是不懂，好，说人话！我们实现的curry应该满足： 经curry处理，得到一个新函数，这一点不变。 12// curry是一个函数var curried = curry(add); 新函数执行后仍然返回一个结果函数。 123// curried10也是一个函数var curried10 = curried(10);var curried30 = curried10(20); 结果函数可以被Javascript引擎解析，得到一个预期的值。 1curried10; // 10 好，关键点在于3，如何让Javascript引擎按我们的预期进行解析，这就回到Javascript基础了。在解析一个函数的原始值时，会用到toString。 我们知道，console.log(fn)可以把函数fn的源码输出，如下所示： 1234console.log(fn)ƒ fn(a, b, c) { return a + b + c;} 那么我们只要重写toString，就可以巧妙地实现我们的需求了。 12345678910111213141516function curry(fn) { // 保存预置参数 const presetArgs = [].slice.call(arguments, 1) // 返回一个新函数 function curried () { // 新函数调用时会继续传参 const restArgs = [].slice.call(arguments) const allArgs = [...presetArgs, ...restArgs] return curry.call(null, fn, ...allArgs) } // 重写toString curried.toString = function() { return fn.apply(null, presetArgs) } return curried;} 这样一来，魔性的add用法就都被支持了。 12345678function dynamicAdd() { return [...arguments].reduce((prev, curr) =&gt; { return prev + curr }, 0)}var add = curry(dynamicAdd);add(1)(2)(3)(4) // 10add(1, 2)(3, 4)(5, 6) // 21 至于为什么是重写toString，而不是重写valueOf，这里留个悬念，大家可以想一想，也欢迎与我交流！ 柯里化总结柯里化是一种函数式编程思想，实际上在项目中可能用得少，或者说用得不深入，但是如果你掌握了这种思想，也许在未来的某个时间点，你会用得上！ 大概来说，柯里化有如下特点： 简洁代码：柯里化应用在较复杂的场景中，有简洁代码，可读性高的优点。 参数复用：公共的参数已经通过柯里化预置了。 延迟执行：柯里化时只是返回一个预置参数的新函数，并没有立刻执行，实际上在满足条件后才会执行。 管道式流水线编程：利于使用函数组装管道式的流水线工序，不污染原函数。 小结本文是笔者回顾函数知识点时总结的一篇非常详细的文章。在理解一些晦涩的知识模块时，我加入了一些个人解读，相信对于想要深究细节的朋友会有一些帮助。如果您觉得这篇文章有所帮助，请无情地关注点赞支持一下吧！同时也欢迎加我微信laobaife一起交流学习。","link":"/函数知识总结.html"},{"title":"「思维导图学前端 」初中级前端值得收藏的正则表达式知识点扫盲","text":"本文是思维导图学前端系列第二篇，主题是正则表达式。首先还是想说下我的出发点，之所以自己画一遍思维导图，是因为我整理的思维导图里加入了自己的理解，更容易记忆。之前也看过很多别人整理的思维导图，虽然有点拨之用，但是要想吸收个二三分营养却也是很难。 所以，建议本系列的读者在阅读文章之后，在时间允许的情况下，可以考虑自行整理知识点，便于更好地理解和吸收。 推荐下同系列文章： 「思维导图学前端」6k字一文搞懂Javascript对象，原型，继承 很多前端新手在遇到正则表达式时都望而却步，我自己初学时，也基本上是直接跳过了正则表达式这一章，除了copy网上的一些常用的正则表达式做表单校验，其余时候几乎没有去了解过如何写一个正则表达式。 但是，当自己真正要去写一个适合特定业务的正则表达式时，我发现自己掌握的正则表达式知识真的是捉襟见肘。所以我这里也用思维导图整理了一些正则表达式必知必会的知识点。 什么是正则表达式 正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 在软件开发过程中，我们或多或少会接触到正则表达式，对于前端而言，正则表达式不仅可以校验表单，文本查找和替换，还可以做语法解析器，用于AST，编辑器等领域。 正则表示法直接量表示法直接量也称为字面量，写法如下： 1/^\\d+$/g 直接量写法的正则表达式在执行时会转换为一个新的RegExp对象。我想应该是因为直接量是没有调用方法的能力的，只有转为了对象，才使得调用方法成为可能。所以才有了/^\\d+$/.test()。 当在循环中用到正则对象lastIndex判断终止条件时，一定不要使用直接量正则表达式写法，否则每次循环lastIndex都会被重置为0，这是因为每次执行字面量正则表达式时，都会转换为一个新的RegExp对象，相应的lastIndex当然也会变成0。 RegExp对象表示法1var pattern = new RegExp(/^\\d+$/, 'g') 第一个参数可以接受正则表达式直接量，也可以接受字符串，传递字符串作为第一个参数时，首尾不需要带斜杠，字符串中如果用到特殊字符\\，需要在\\前再加一个\\，防止\\在字符串中被转义。 1\"\\s\" === \"s\" // true 字符串&quot;\\\\s&quot;才能正确地表示\\s 第二个参数代表标志flags，可接受的标志有i, g, m等。 标志flagsi如果启用了标志i，正则表达式在执行时不区分大小写。 /abc/i.test('abc')等价于/abc/i.test('ABC') g如果启用了标志g，正则表达式会执行全局匹配，匹配到一个结果后不会立刻停止匹配，直到后续没有任何符合匹配规则的字符为止。 m如果启用了标志m，正则表达式会执行多行匹配，^可以匹配每一行的开始或整个字符串的开始，而$可以匹配每一行的结束或整个字符串的结束。 示例如下： 12/^\\d+$/.test('123\\n456') // false/^\\d+$/m.test('123\\n456') // true 仍然可以匹配整个字符串 1/^\\d+\\n\\d+$/m.test('123\\n45') // true 位置限定符^匹配字符的开始。比如必须以数字开始，可以这么写： 1/^\\d/ $匹配字符的结束。比如必须以数字结束，可以这么写： 1/\\d$/ 范围匹配范围匹配是利用方括号[]实现的。 方括号[]用于范围匹配，也就是查找某个范围内的字符。比如[0-9]代表匹配数字，而[a-z]可以匹配小写字母a到z这26个字符中的任意一个。 如果要匹配不在方括号中的字符，可以在方括号中以^开头，比如[^0-9]，用于匹配非数字，等价于\\D。 主要元字符.匹配除换行符\\n外的任意字符，如果要匹配任意字符，应该用/[.\\n]*/。 \\s匹配任意空字符，包括空格，制表符\\t，垂直制表符\\v，换行符\\n，回车符\\r，换页符\\f。\\s等价于[ \\t\\v\\n\\r\\f]，注意方括号内第一个位置有空格。 这里也说下换行符和回车符的区别： 换行符\\n：光标下移一行，不回行首。 回车符\\r：光标回到行首，不换行。 \\S\\S是\\s的反集，利用\\s和\\S的这种互为反集的关系，我们就可以匹配任意字符，写法如下： 1/[\\s\\S]/ \\d\\d用于匹配数字，等价于[0-9]。 \\D\\D是\\d的反集，也就是匹配非数字，等价于[^0-9]。 \\w\\w用于匹配单词字符，包含0-9，a-z，A-z以及下划线_，等价于[A-Za-z0-9_]。 \\W\\W是\\w的反集，用于匹配非单词字符，等价于[^A-Za-z0-9_]。 \\n\\n是开发中经常遇到的换行符，而上面提到的\\s是包含\\n在内的。所以，能被\\n匹配的字符，也一定能被\\s匹配。 \\b\\b用于匹配单词的边界，即单词的开始或结束。 一开始其实我不太能理解\\b在正则表达式中的作用。 直到我自己试了一下这个案例 12'I love you'.match(/love/)'Iloveyou'.match(/love/) 这两个表达式都能匹配到结果&quot;love&quot;。 但是有时候我们并不希望这样的字符串'Iloveyou'被匹配，因为它没有单词间的空格。 所以\\b有了它存在的意义。看下面的例子： 12'I love you'.match(/\\blove\\b/)'Iloveyou'.match(/\\blove\\b/) // null 第一个表达式仍然可以正常匹配到结果，而第二个就无法匹配到结果了，这符合我们的预期。 有的人可能会说，那我可以用空格匹配啊。 1'I love you'.match(/ love /) 空格和\\b在这种场景下还是有一点不一样的，这体现在match的结果上。 如果是用空格匹配，那么match的结果数组中的第一项就是&quot; love &quot;，是带了空格的，然而很多时候我们不希望在结果中得到空格，所以\\b存在的意义也就比较明显了。 \\B与\\b相反，代表非单词边界。也就是说，使用\\B匹配时，目标字符前或后不能是空格。 假设\\B在前，比如 1/\\Babc/.test('111 abc') // false 假设\\B在后，比如 1/abc\\B/.test('abc 111') // false 转义字符\\由于正则表达式中很多字符有特殊含义，比如(, ), \\, [, ], +，如果你真的要匹配它们，必须加上转义符\\。 1/\\//.test('/'); // true 或 |实现或的逻辑是比较简单的，正则表达式提供了|。 要注意的是，|隔断的是其左右的整个子表达式，而不是单个普通字符。 所以， 123/^ab|cd|ef$/.test('ab') // true/^ab|cd|ef$/.test('cd') // true/^ab|cd|ef$/.test('ace') // false 还要注意的是，|具有从左到右的优先级，如果左侧的匹配上了，右侧的就被忽略了，即便右侧的匹配看起来更“完美”。 /a|ab/.exec('ab')得到的结果是 1[\"a\", index: 0, input: \"ab\", groups: undefined] 量词?匹配前面的子表达式零次或一次 +匹配前面的子表达式一次或多次 *匹配前面的子表达式零次或任意次 {n,m}匹配前一个普通字符或者子表达式最少n次，最多m次 {n,}匹配前一个普通字符或者子表达式最少n次 {n}匹配前一个普通字符或者子表达式n次 贪婪贪婪匹配是尽可能多地匹配，如果能满足匹配条件，就尽可能侵占后面的匹配规则。 贪婪匹配是默认的，比如/\\d?/会尽可能地匹配1个数字，/\\d+/和/\\d*/会尽可能地匹配多个数字。 举个例子， 1'123456789'.match(/^(\\d+)(\\d{2,})$/) 以上结果中捕获组的第一项是&quot;1234567&quot;，第二项是&quot;89&quot;。 为什么会这样呢？因为\\d+是贪婪匹配，尽可能地多匹配，如果没有后面的\\d{2,}，捕获组第一项会直接是&quot;123456789&quot;。但是由于\\d{2,}的存在，\\d+会给\\d{2,}留个面子，满足它的最小条件，即匹配2个数字，而\\d+自己匹配7个数字。 非贪婪非贪婪匹配是尽可能少地匹配，一般是在量词?, +, *之后再加一个?，表示尽可能少地匹配，把机会留给后面的匹配规则。 还是拿贪婪模式中那个例子举例，稍微改一下，\\d+换成非贪婪模式\\d+?。 1'123456789'.match(/^(\\d+?)(\\d{2,})$/) 捕获组的第一项是&quot;1&quot;，第二项变成了&quot;23456789&quot;。 为什么会这样呢？因为在非贪婪模式下，会尽可能少匹配，把机会留给后面的匹配规则。 分组分组在正则中是一个非常有用的神器，用圆括号()来包裹的内容就是一个分组，在正则中是这种表示形式： 1/(\\d*)([a-z]*)/ 捕获组()利用捕获组，我们能捕获到关键字符。 比如 1var group = '123456789hahaha'.match(/(\\d*)([a-z]*)/) 分组1用于匹配任意个数字，分组2用于匹配任意个小写字母。 那么我们在match方法的返回结果中就可以取到这两个分组匹配的结果，group[1]是&quot;123456789&quot;，group[2]是&quot;hahaha&quot;。 我们还可以在RegExp的静态属性$1~$9取得前9个分组匹配的结果。RegExp.$1是&quot;123456789&quot;，RegExp.$2是&quot;hahaha&quot;。但是RegExp.$1~$9是非标准的，虽然很多浏览器都实现了，尽量不要在生产环境中使用。 这种捕获组的应用在字符串的replace方法中也是类似，不过在调用replace方法时，我们需要通过$1, $2, $n这种形式去引用分组。 1\"123456789hahaha\".replace(/(\\d*)([a-z]*)/, \"$1\") // \"123456789\" 利用$1，我们就可以把源字符串替换为分组1匹配到的字符串，也就是&quot;123456789&quot;。 非捕获组(?:)非捕获组是不生成引用的分组，它也由圆括号()包裹起来，不过圆括号中起头的是?:，也就是/(?:\\d*)/这种形式。 还是改造下之前的例子来看下： 1var group = '123456789hahaha'.match(/(?:\\d*)([a-z]*)/) 由于非捕获组不生成引用，所以group[1]是&quot;hahaha&quot;；同样地，RegExp.$1也是&quot;hahaha&quot;。 看到这里，我不禁也产生了疑问，既然我不需要引用非捕获组，那么非捕获组的意义何在？ 思考了一阵后，我觉得非捕获组大概有这么一些优势和必要性： 与捕获组相比，非捕获组在内存上开销更小，因为它不需要生成引用 分组是为了方便加量词。我们虽然可以不生成引用，但是如果没有分组，就不太方便加给一组字符加量词。 1'1a2b3c...'.match(/(?:\\d[a-z]){2,3}(\\.+)/) 引用\\num正则表达式中可以引用前面的具有引用的分组，通过\\1，\\2这种形式可以实现引用前面的子表达式。 比如，我要匹配一个字符串，要求符合这样的规则： 字符串由单引号或双引号开头和结束，中间内容可以是数字，单词。 那我要保证的是首尾要么是单引号，要么是双引号，所以我的pattern写法可以是： 123var pattern = /^([\"'])[a-z\\d]*\\1$/pattern.test(\"'perfect123'\") // truepattern.test('\"1perfect2\"') // true 零宽断言说实话，一开始看零宽断言的概念和解释时，我真的完全不懂在说什么。 零宽正向先行断言(?=) 零宽负向先行断言(?!) 零宽正向后行断言(?&lt;=) 零宽负向后行断言(?&lt;!) 后面把词汇拆开来看，加入自己的理解，就慢慢有点懂了。 零宽：zero width，断言作为必要条件进行匹配，但是不体现在匹配结果中。 正向：positive，断言中的字符必须被匹配。 负向：negative，断言中的字符不能被匹配。 先行：lookahead，必须满足前方的条件，条件在前方，前方等同于右侧。 后行：lookbehind，必须满足后方的条件，条件在后方，后方等同于左侧。 零宽正向先行断言(?=)约束目标右侧必须存在指定的字符。 1/123(?=a)/.test('123a') // true 上面的例子约束了123右侧必须有a。 零宽负向先行断言(?!)约束目标右侧不能存在指定的字符。 1/123(?!a)/.test('123a') // false 上面的例子约束了123右侧不能有a，否则结果为false。 零宽正向后行断言(?&lt;=)约束目标左侧必须存在指定的字符。 1/(?&lt;=a)123/.test('a123') // true 上面的例子约束了123左侧必须有a。 ES2018才支持零宽后行断言，具体见TC39 Proposals 零宽负向后行断言(?&lt;!)约束目标左侧不能存在指定的字符。 1/(?&lt;!a)123/.test('a123') // false 上面的例子约束了123左侧不能有a，否则结果为false 注：ES2018才支持此特性。 RegExp说到正则表达式，就不得不提到RegExp对象。下面我们从原型方法，静态属性，实例属性等几个方面来认识下RegExp对象。 原型方法RegExp.prototype.testtest()是我们平时最常用的正则方法，test()方法执行一个检索，用来查看正则表达式与指定的字符串是否匹配，返回一个布尔值true或false。 如果正则表达式设置了全局标志g，执行test()会改变RegExp.lastIndex属性，用于记录上次匹配到的字符的起始索引。连续执行test()方法，后续的执行将会从lastIndex处开始匹配字符串。这种情况下，如果test()无法匹配到结果，lastIndex就会重置为0。 RegExp.prototype.execexec()相较于test()能得到更丰富的匹配信息，其结果是一个数组，数组的第0个元素是匹配到的字符串，第1~n个元素是圆括号()分组捕获的结果。 结果数组是数组，数组也是对象类型数据，所以结果数组还有两个属性分别是index和input index代表匹配到的字符位于原始字符串的基于0的索引值 input则代表原始字符串 与test()一致，如果正则表达式设置了g标志符，那么每次执行exec()都会更新lastIndex。 静态属性静态属性不属于任何一个实例，必须通过类名访问，这一点在上一篇「思维导图学前端」6k字一文搞懂Javascript对象，原型，继承已经提到过。 RegExp.$1-$9用于获取分组的匹配结果，RegExp.$1获取的是第一个分组的匹配结果，RegExp.$9则是第九个分组的匹配结果。 具体见上文分组-捕获组一节。 实例属性lastIndexlastIndex，从语义上理解，就是上次匹配到的字符的起始索引。要注意的是，只有设置了g标志，lastIndex才有效。 当还未进行匹配时，lastIndex自然是0，代表从第0个字符串开始匹配。 lastIndex会随着exec()和test()的执行而更新 123456var reg = /\\d/greg.lastIndex // 0reg.test('123456')reg.lastIndex // 1reg.exec('123456')reg.lastIndex // 2 lastIndex可以手动修改，也就是说，你可以自由控制匹配的细节。 flagsflags属性返回一个字符串，代表该正则表达式实例启用了哪些标志。 12var reg = /\\d/igreg.flags; // \"gi\" globalglobal是布尔量，表明正则表达式是否使用了g标志。 ignoreCaseignoreCase是布尔量，表明正则表达式是否使用了i标志。 multilinemultiline是布尔量，表明正则表达式是否使用了m标志。 sourcesource，意为源，是正则表达式的字符串表示，不会包含正则字面量两边的斜杠以及任何的标志字符。 String涉及正则的方法String.prototype.searchsearch()方法用正则表达式对字符串对象进行一次匹配，结果返回一个index，代表正则表达式在字符串中首次匹配项的索引。如果无法匹配，则返回-1。 search()方法的参数必须是正则表达式，如果不是也会被new RegExp()默默转换为正则表达式对象。 1\"123abc\".search(/[a-z]/); // 3 String.prototype.match字符串的match方法用于检索字符串，和正则表达式的exec方法是相似的。match方法的参数也要求是正则表达式。match方法返回一个数组。 与exec()的不同点在于，如果match方法传入的正则表达式带了标识g，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。 12345678910\"123abc456\".match(/([a-z])/g);// 返回[\"a\", \"b\", \"c\"]var reg = /([a-z])/g;reg.exec('123abc456');// 返回数组[\"a\", \"a\", index: 3, input: \"123abc456\", groups: undefined]reg.exec('123abc456');// 返回数组[\"b\", \"b\", index: 4, input: \"123abc456\", groups: undefined]reg.exec('123abc456');// 返回数组[\"c\", \"c\", index: 5, input: \"123abc456\", groups: undefined] 如果match()方法传入的正则表达式不带标志g，表现与exec()方法一致，只会返回第一个匹配结果和分组捕获到的结果。 如果此时表达式中有圆括号分组，在match()的结果数组中也是可以获取到这些分组匹配的结果的，这一点在捕获组中也有提到。 123\"123abc456\".match(/([a-z])/);// 返回[\"a\", \"a\", index: 3, input: \"123abc456\", groups: undefined]RegExp.$1; // \"a\" String.prototype.replacereplace()是字符串替换方法，它不要求第一个参数必须是正则表达式。如果第一个参数是正则表达式，并且包含分组，那么在replace()的第二个参数中，可以通过&quot;$1&quot;，&quot;$2&quot;这种形式引用分组匹配结果。 1\"123456789hahaha\".replace(/(\\d*)([a-z]*)/, \"$1\") // \"123456789\" String.prototype.splitsplit()方法是字符串分割方法，也算平时用得很多的一个方法，但是很多人不知道它可以接受正则表达式作为参数。 假设我们得到这样一个不太规律的字符串&quot;1,2, 3 ,4, 5&quot;，然后需要分割这个字符串得到纯数字组成的数组，直接使用split(&quot;,&quot;)是不行的，而利用正则表达式作为分割条件就可以做到。 123var str = \"1,2, 3 ,4, 5\";str.split(/\\s*,\\s*/);// 返回 [\"1\", \"2\", \"3\", \"4\", \"5\"] 最后正则表达式是一个非常重要却容易被忽视的知识点，在面试中也是一个频繁的考点，所以必须给予它足够的重视。经过上面的知识点梳理，相信能在后续的实战中胸有成竹，不慌不忙。","link":"/初中级前端值得收藏的正则表达式知识点扫盲.html"},{"title":"利用gulp优化web页面加载速度","text":"利用hexo搭建好博客之后，发现博客页面加载速度特别慢，这一点在手机端比较明显。关闭了粒子动画效果后，页面加载的速度没有得到明显改善，于是想从其他方面来提升加载速度。而压缩代码则是一个最直接的方式。 压缩htmlgulp-htmlmin是一个用于压缩html文件的插件，安装方法如下： 1npm install --save-dev gulp-htmlmin 使用方法如下： 12345678910111213141516var gulp = require(&apos;gulp&apos;);var htmlmin = require(&apos;gulp-htmlmin&apos;); gulp.task(&apos;minifyHtml&apos;, function() { var minifyOptions = { collapseWhitespace: true, // 折叠html节点间的空白 minifyCSS: true, // 压缩css minifyJS: true, // 压缩js removeComments: true, // 去除注释 removeEmptyAttributes: true, // 去除空属性 removeRedundantAttributes: true // 去除与默认属性一致的属性值 }; return gulp.src(&apos;src/*.html&apos;) .pipe(htmlmin(minifyOptions)) .pipe(gulp.dest(&apos;dist&apos;));}); 这个插件还有很多的配置项，请参考Options Quick Reference。 ps：html文件中可以嵌入js以及css内容，因此该插件支持对html文件中js及css内容的压缩。 压缩css我之前用过一个gulp-minify-css插件来压缩css文件，不过最近发现它已经被废弃了，取而代之的是gulp-clean-css，安装方法如下： 1npm install gulp-clean-css --save-dev 使用方法如下： 12345678var gulp = require(&apos;gulp&apos;);var cleanCSS = require(&apos;gulp-clean-css&apos;); gulp.task(&apos;minifyCss&apos;, () =&gt; { return gulp.src(&apos;styles/*.css&apos;) .pipe(cleanCSS({compatibility: &apos;ie8&apos;})) .pipe(gulp.dest(&apos;dist&apos;));}); gulp-clean-css的配置项挺多的，感觉还是要遇到具体问题，具体分析了。配置项参考clean-CSS。 压缩js我们可以用gulp-uglify插件来进行js文件的压缩。首先，我们来安装它： 1npm install --save-dev gulp-uglify 使用方法如下： 1234567891011var gulp = require(&apos;gulp&apos;);var uglify = require(&apos;gulp-uglify&apos;);var pump = require(&apos;pump&apos;); gulp.task(&apos;compress&apos;, function (cb) { pump([ gulp.src(&apos;lib/*.js&apos;), uglify(), gulp.dest(&apos;dist&apos;) ], cb);}); 这里用到了一个pump插件，其实不需要它也是完全可以正常压缩js文件的。但是pump插件为我们提供了一个排错的能力，能够打印出压缩js文件过程的具体错误信息，让我们快速定位修改。ps：gulp-uglify支持一些配置项，请参考Minify options。 压缩图片资源压缩图片资源也是优化web页面的一个重要方法，而gulp-imagemin插件可以帮我们做到这一点。首先，我们来安装它： 1npm install --save-dev gulp-imagemin 经典的用法如下： 12345678var gulp = require(&apos;gulp&apos;);var imagemin = require(&apos;gulp-imagemin&apos;); gulp.task(&apos;default&apos;, () =&gt; gulp.src(&apos;src/images/*&apos;) .pipe(imagemin()) .pipe(gulp.dest(&apos;dist/images&apos;))); imagemin()也可以传入配置参数，主要的一些配置项如下所示： 12345678910111213….pipe(imagemin([ imagemin.gifsicle({interlaced: true}), //优化gif imagemin.jpegtran({progressive: true}), //优化jpg,jpeg imagemin.optipng({optimizationLevel: 5}), //优化png imagemin.svgo({ plugins: [ {removeViewBox: true}, {cleanupIDs: false} ] }) //优化svg]))… 这里有两个单词需要注意一下，interlaced和progressive，有一篇文章介绍了交错扫描和逐行扫描，请大家参考！ 我在利用上述插件来压缩博客public文件夹下的资源时，发现在进行html压缩和css压缩时，出现了一些页面bug，暂未得出原因，留待后续观察，于是暂时放弃了html和css插件压缩，仅使用了gulp-uglify和gulp-imagemin来压缩js文件和图片。经优化后，博客加载速度得到了显著提升，也算是做了一个不错的优化。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/利用gulp优化web页面加载速度.html"},{"title":"前端API层架构，也许你做得还不够","text":"上午好，今天为大家分享下个人对于前端API层架构的一点经验和看法。 架构设计是一条永远走不完的路，没有最好，只有更好。这个道理适用于软件设计的各个场景，前端API层的设计也不例外，如果您觉得在调用接口时还存在诸多槽点，那就说明您的接口层架构还待优化。今天我以vue + axios为例，为大家梳理下我的一些经历和设想。 石器时代，痛苦直接调用axios，真的痛苦，每个调用的地方都要进行响应状态的判断，冗余代码超级多。 1234567891011import axios from \"axios\"axios.get('/usercenter/user/page?pageNo=1&amp;pageSize=10').then(res =&gt; { const data = res.data // 判断请求状态，success字段为true代表成功，视前后端约束而定 if (data.success) { // 结果成功后的业务代码 } else { // 结果失败后的业务代码 }}) 看起来确实很难受，每调用一次接口，就有这么多重复的工作！ 青铜器时代，中规中矩为了解决直接调用axios的痛点，我们一般会利用Promise对axios二次封装，对接口响应状态进行集中判断，对外暴露get, post, put, delete等http方法。 axios二次封装1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import axios from \"axios\"import router from \"@/router\"import { BASE_URL } from \"@/router/base-url\"import { errorMsg } from \"@/utils/msg\";import { stringify } from \"@/utils/helper\";// 创建axios实例const v3api = axios.create({ baseURL: process.env.BASE_API, timeout: 10000});// axios实例默认配置v3api.defaults.headers.common['Content-Type'] = 'application/x-www-form-urlencoded';v3api.defaults.transformRequest = data =&gt; { return stringify(data)}// 返回状态拦截，进行状态的集中判断v3api.interceptors.response.use( response =&gt; { const res = response.data; if (res.success) { return Promise.resolve(res) } else { // 内部错误码处理 if (res.code === 1401) { errorMsg(res.message || '登录已过期，请重新登录！') router.replace({ path: `${BASE_URL}/login` }) } else { // 默认的错误提示 errorMsg(res.message || '网络异常，请稍后重试！') } return Promise.reject(res); } }, error =&gt; { if (/timeout\\sof\\s\\d+ms\\sexceeded/.test(error.message)) { // 超时 errorMsg('网络出了点问题，请稍后重试！') } if (error.response) { // http状态码判断 switch (error.response.status) { // http status handler case 404: errorMsg('请求的资源不存在！') break case 500: errorMsg('内部错误，请稍后重试！') break case 503: errorMsg('服务器正在维护，请稍等！') break } } return Promise.reject(error.response) })// 处理get请求const get = (url, params, config = {}) =&gt; v3api.get(url, { ...config, params })// 处理delete请求，为了防止和关键词delete冲突，方法名定义为deletesconst deletes = (url, params, config = {}) =&gt; v3api.delete(url, { ...config, params })// 处理post请求const post = (url, params, config = {}) =&gt; v3api.post(url, params, config)// 处理put请求const put = (url, params, config = {}) =&gt; v3api.put(url, params, config)export default { get, deletes, post, put} 调用者不再判断请求状态12345678910111213import api from \"@/api\";methods: { getUserPageData() { api.get('/usercenter/user/page?pageNo=1&amp;pageSize=10').then(res =&gt; { // 状态已经集中判断了，这里直接写成功的逻辑 // 业务代码...... const result = res.result; }).catch(res =&gt; { // 失败的情况写在catch中 }) }} async/await改造使用语义化的异步函数 1234567891011methods: { async getUserPageData() { try { const res = await api.get('/usercenter/user/page?pageNo=1&amp;pageSize=10') // 业务代码...... const { result } = res; } catch(error) { // 失败的情况写在catch中 } }} 存在的问题 语义化程度有限，调用接口还是需要查询接口url 前端api层难以维护，如后端接口发生改动，前端每处都需要大改。 如果UI组件的数据模型与后端接口要求的数据结构存在差异，每处调用接口前都需要进行数据处理，抹平差异，比如[1,2,3]转1,2,3这种（当然，这只是最简单的一个例子）。这样如果数据处理不慎，调用者出错几率太高！ 难以满足特殊化场景，举个例子，一个查询的场景，后端要求，如果输入了搜索关键词keyword，必须调用/user/search接口，如果没有输入关键词，只能调用/user/page接口。如果每个调用者都要判断是不是输入了关键词，再决定调用哪个接口，你觉得出错几率有多大，用起来烦不烦？ 产品说，这些场景需要优化，默认按创建时间降序排序。我擦，又一个个改一遍？ …… 那么怎么解决这些问题呢？请耐心接着看…… 铁器时代，it’s cool我想到的方案是在底层封装和调用者之间再增加一层API适配层（适配层，取量身定制之意），在适配层做统一处理，包括参数处理，请求头处理，特殊化处理等，提炼出更语义化的方法，让调用者“傻瓜式”调用，不再为了查找接口url和处理数据结构这些重复的工作而烦恼，把ViewModel层绑定的数据模型直接丢给适配层统一处理。 对齐微服务架构 首先，为了对齐后端微服务架构，在前端将API调用分为三个模块。 12345├─api index.js axios底层封装 ├─base 负责调用基础服务,basecenter ├─iot 负责调用物联网服务,iotcenter └─user 负责调用用户相关服务,usercenter 每个模块下都定义了统一的微服务命名空间，例如/src/api/user/index.js： 1export const namespace = 'usercenter'; 特性模块每个功能特性都有独立的js模块，以角色管理相关接口为例，模块是/src/api/user/role.js 123456789101112131415161718192021import api from '../index'import { paramsFilter } from \"@/utils/helper\";import { namespace } from \"./index\"const feature = 'role'// 添加角色export const addRole = params =&gt; api.post(`/${namespace}/${feature}/add`, paramsFilter(params));// 删除角色export const deleteRole = id =&gt; api.deletes(`/${namespace}/${feature}/delete`, { id });// 更新角色export const updateRole = params =&gt; api.put(`/${namespace}/${feature}/update`, paramsFilter(params));// 条件查询角色export const findRoles = params =&gt; api.get(`/${namespace}/${feature}/find`, paramsFilter(params));// 查询所有角色，不传参调用find接口代表查询所有角色export const getAllRoles = () =&gt; findRoles();// 获取角色详情export const getRoleDetail = id =&gt; api.get(`/${namespace}/${feature}/detail`, { id });// 分页查询角色export const getRolePage = params =&gt; api.get(`/${namespace}/${feature}/page`, paramsFilter(params));// 搜索角色export const searchRole = params =&gt; params.keyword ? api.get(`/${namespace}/${feature}/search`, paramsFilter(params)) : getRolePage(params); 每一条接口都根据RESTful风格，调用增（api.post）删（api.deletes）改（api.put）查（api.get）的底层方法，对外输出语义化方法。 调用的url由三部分组成，格式：/微服务命名空间/特性命名空间/方法 接口适配层函数命名规范： 新增：addXXX 删除：deleteXXX 更新：updateXXX 根据ID查询记录：getXXXDetail 条件查询一条记录：findOneXXX 条件查询：findXXXs 查询所有记录：getAllXXXs 分页查询：getXXXPage 搜索：searchXXX 其余个性化接口根据语义进行命名 解决问题 语义化程度更高，配合vscode的代码提示功能，用起来不要太爽！ 迅速响应接口改动，适配层统一处理 集中进行数据处理（对于公用的数据处理，我们用paramsFilter解决，对于特殊的情况，再另行处理），调用者安心做业务即可 满足特殊场景，佛系应对后端和产品朋友 针对上节提到的关键字查询场景，我们在适配层通过在入参中判断是否有keyword字段，决定调用search还是page接口。对外我们只需暴露searchRole方法，调用者只需要调用searchRole方法即可，无需做其他考虑。 1export const searchRole = params =&gt; params.keyword ? api.get(`/${namespace}/${feature}/search`, paramsFilter(params)) : getRolePage(params); 针对产品突然加的排序需求，我们可以在适配层去做默认入参的处理。 首先，我们新建一个专门管理默认参数的js，如src/api/default-options.js 123456// 默认按创建时间降序的参数对象export const SORT_BY_CREATETIME_OPTIONS = { sortField: 'createTime', // desc代表降序，asc是升序 sortType: 'desc'} 接着，我们在接口适配层做集中化处理 1234567import api from '../index'import { SORT_BY_CREATETIME_OPTIONS } from \"../default-options\"import { paramsFilter } from \"@/utils/helper\";import { namespace } from \"./index\"const feature = 'role'export const getRolePage = params =&gt; api.get(`/${namespace}/${feature}/page`, paramsFilter({ ...SORT_BY_CREATETIME_OPTIONS, ...params })); SORT_BY_CREATETIME_OPTIONS放在前面，是为了满足如果出现其他排序需求，调用者传入的排序字段能覆盖掉默认参数。 mock先行一个完善的API层设计，肯定是离不开mock的。在后端提供接口之前，前端必须通过模拟数据并行开发，否则进度无法保证。那么如何设计一个跟真实接口契合度高的mock系统呢？我这里简单做下分享。 首先，创建mock专用的axios实例 我们在src目录下新建mock目录，并在src/mock/index.js简单封装一个axios实例 12345678910111213141516// 仅限模拟数据使用import axios from \"axios\"const mock = axios.create({ baseURL: ''});// 返回状态拦截mock.interceptors.response.use( response =&gt; { return Promise.resolve(response.data) }, error =&gt; { return Promise.reject(error.response) })export default mock mock同样也要分模块，以usercenter微服务下的角色管理mock接口为例 12345├─mock index.js mock底层axios封装 ├─user 负责调用基础服务,usercenter ├─role ├─index.js 我们在src/mock/user/role/index.js中简单模拟一个获取所有角色的接口getAllRoles 123import mock from \"@/mock\";export const getAllRoles = () =&gt; mock.get('/static/mock/user/role/getAllRoles.json') 可以看到，我们是在mock接口中获取了static/mock目录下的json数据。因此我们需要根据接口文档或者约定好的数据结构准备好getAllRoles.json数据 12345678910111213141516171819202122232425262728293031323334{ \"success\": true, \"result\": { \"pageNo\": 1, \"pageSize\": 10, \"total\": 2, \"list\": [ { \"id\": 1, \"createTime\": \"2019-11-19 12:53:05\", \"updateTime\": \"2019-12-03 09:53:41\", \"name\": \"管理员\", \"code\": \"管理员\", \"description\": \"一个拥有部分权限的管理员角色\", \"sort\": 1, \"menuIds\": \"789,2,55,983,54\", \"menuNames\": \"数据字典, 后台, 账户信息, 修改密码, 账户中心\" }, { \"id\": 2, \"createTime\": \"2019-11-27 17:18:54\", \"updateTime\": \"2019-12-01 19:14:30\", \"name\": \"前台测试\", \"code\": \"前台测试\", \"description\": \"一个拥有部分权限的前台测试角色\", \"sort\": 2, \"menuIds\": \"15,4,1\", \"menuNames\": \"油耗统计, 车联网, 物联网监管系统\" } ] }, \"message\": \"请求成功\", \"code\": 0} 我们来看看mock是怎么做的 先看下真实接口的调用方式 1234567891011import { getAllRoles } from \"@/api/user/role\";created() { this.getAllRolesData()},methods: { async getAllRolesData() { const res = await getAllRoles() console.log(res) }} 那么mock时怎么做呢？非常简单，只要将mock中提供的方法替代掉api提供的方法即可。 12// import { getAllRoles } from \"@/api/user/role\";import { getAllRoles } from \"@/mock/user/role\"; 可以看到，这种mock方式与调用真实接口的契合度还是挺高的，正式调试接口时，只需将注释的代码调整即可，过渡非常平滑！ 注意，在生产环境下，为了防止打包时将static/mock目录下的内容copy到dist目录下，我们需要配置下CopyWebpackPlugin，以vue-cli@2为例，我们修改webpack.base.conf.js即可。 123456789const devMode = process.env.NODE_ENV === 'development';new CopyWebpackPlugin([ { from: path.resolve(__dirname, '../static'), to: devMode ? config.dev.assetsSubDirectory : config.build.assetsSubDirectory, ignore: devMode ? '' : 'mock/**/*' }]) 蒸汽时代，真香下一步的设想，使用类型安全的typescript，让前端API层真正做到面向接口文档编程，规范入参，出参，可选参数，等等，提高可维护性，在编码阶段就大大降低出错几率。虽然还在重构阶段，但是我想说，重拾typescript是真香，突然怀念使用Angular的那两年了，期待vue3.0能将typescript结合得更加完美…… 电气时代，更多畅想未来还有无限可能，面对日渐复杂和多样化的业务场景，我们会提炼出更好的架构和设计模式。目前有一个不成熟的设想，是否能在接口设计上做到更规范化，后端输出接口文档的同时，提炼出API json之类的数据结构？前端拿到API json，通过nodejs文件编程的能力，自动化生成前端接口层代码，解放双手。 结语当然，以上只是我的一点点经验和设想，是在我能力范围内能想到的东西，希望能帮助到一些有需要的同学。如果大佬们有更好的经验，可以指点一二。 首发链接 往期精彩： 用初中数学知识撸一个canvas环形进度条","link":"/前端API层架构，也许你做得还不够.html"},{"title":"前端利器SASS之入门篇","text":"前端开发过程中，我们会给各个元素指定样式，甚至有很多重复的样式，在后期维护过程中，如果我们要改动一些页面样式，可能得一个个css文件去修改，这样非常麻烦。好在有SASS这样一个神器来帮我们完成CSS的拓展和管理。那么什么是SASS? Sass（Syntactically Awesome StyleSheets，非常棒的语法结构化层叠样式表，我瞎翻译的） 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。 想要真正掌握SASS语法，就得一条一条学啊。 SASS对CSS的拓展支持嵌套12345#main { #home { background: red; }} 支持父选择器&amp;1234a { font-weight: normal; &amp;:hover { font-weight: bold; }} 支持属性嵌套12345678910111213.home { font: { family: fantasy; size: 30px; weight: normal; }}// 上述代码相当于css的如下代码.home { font-family: fantasy; font-size: 30px; font-weight: normal; } SassScriptSass支持一些类似js的语法，为我们提供了很多强大的功能。 变量（1）声明变量 1$nav-bgc: rgba(0, 0, 0, .2); （2）引用变量 1background: $nav-bgc; （3）!default可以在变量的结尾添加 !default 给一个未通过 !default 声明赋值的变量赋值，此时，如果变量已经被赋值，不会再被重新赋值，但是如果变量还没有被赋值，则会被赋予新的值。 12345678$content: \"First content\";$content: \"Second content?\" !default;$new_content: \"First time reference\" !default;#main { content: $content; // \"First content\" new-content: $new_content; // \"First time reference\"} ps：变量是 null 空值时将视为未被 !default 赋值。如果第一个$content的值是null，那么将会取$content: “Second content?” !default的值。 数据类型SASS支持的数据类型主要有以下几种： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) 支持运算符 运算规则与js类似，但有一些特别的地方，具体请参考SASS教程。 插值语法#{}通过 #{} 插值语句可以在选择器或属性名或属性值中使用变量。使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。比如下面用到的font写法。 12345678$name: foo;$attr: border;$font-size: 12px;$line-height: 30px;p.#{$name} { #{$attr}-color: blue; font: #{$font-size}/#{$line-height};} @extend@extend可以实现继承，适用于一个元素使用的样式与另一个元素完全相同，但又添加了额外的样式。在不使用@extend时，我们完全可以定义两个class来实现，如： 1234567891011// css部分.error { border: 1px #f00; background-color: #fdd;}.seriousError { border-width: 3px;}// html部分&lt;div class=&quot;error seriousError&quot;&gt;&lt;/div&gt; 但是使用@extend能为我们带来更多的好处，简洁易维护。 12345.seriousError { border-width: 3px; @extend .error;}&lt;div class=\"seriousError\"&gt;&lt;/div&gt; 控制指令（1）@if当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码 123p { @if true { border: 1px solid; }} @if后面可以接@else if和@else语句（2）@for这个指令包含两种格式： 12@for $var from &lt;start&gt; through &lt;end&gt;@for $var from &lt;start&gt; to &lt;end&gt; 区别在于 through 与 to 的含义：当使用 through 时，条件范围包含 &lt;start&gt; 与 &lt;end&gt;的值，而使用 to 时条件范围只包含 &lt;start&gt; 的值不包含 &lt;end&gt; 的值。（3）@each 12345678910111213141516171819// @each 遍历值数组中的每一项，然后输出结果$var in &lt;list&gt; {}// @each 可遍历多维数组，如下所示// $animal接收来自(puma, black, default)的数据，$color接收来自(red, blue, green)的数据，依次类推。@each $animal, $color, $cursor in (puma, black, default), (red, blue, green), (pointer, default, move) { .#{$animal}-icon { background-image: url('/images/#{$animal}.png'); border: 2px solid $color; cursor: $cursor; }}// @each 除了可以遍历数组，还可以遍历maps，如下所示@each $header, $size in (h1: 2em, h2: 1.5em, h3: 1.2em) { #{$header} { font-size: $size; }} （3）@while与js的while循环类似 12345$i: 6;@while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2;} @mixin混合器@mixin是sass中一个非常重要的概念，用于定义可重复使用的样式。 @mixin的定义12345678@mixin large-text { font: { family: Arial; size: 20px; weight: bold; } color: #ff0000;} @mixin的使用123456// 使用 @include 指令引用混合样式.page-title { @include large-text; padding: 4px; margin-top: 10px;} ps：@mixin中也可以@include其他混合器。 带参数的混合器12345678910111213141516171819@mixin sexy-border($color, $width) { border: { color: $color; width: $width; style: dashed; }}p { @include sexy-border(blue, 1in); }// 可以设置默认参数，如：@mixin sexy-border($color, $width: 2px) {// 有时候我们不知道会传入几个参数，比如不知道要设置几个box-shadow，所以可以这样使用。@mixin box-shadow($shadows...) { -moz-box-shadow: $shadows; -webkit-box-shadow: $shadows; box-shadow: $shadows;}.shadows { @include box-shadow(0px 4px 5px #666, 2px 6px 10px #999);} 允许向@mixin中插入内容在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，额外导入的部分将出现在 @content 标志的地方： 1234567891011121314@mixin apply-to-ie6-only { * html { @content; }}@include apply-to-ie6-only { #logo { background-image: url(/logo.gif); }}// 上述代码会编译成：* html #logo { background-image: url(/logo.gif);} 函数@functionSASS拥有一些内置函数，也支持自定义函数。 12345678$parent-width: 40px;$self-width: 10px;@function get-left($n) { @return (parent-width - self-width) / 2;}#somediv { left: get-left(5); } ps：函数的语法类似于mixin，但是函数返回的是一个值，而不是一段css。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/前端利器SASS之入门篇.html"},{"title":"前端小微团队的gitlab实践","text":"疫情期间我感觉整个人懒散了不少，慢慢有意识要振作起来了，恢复到正常的节奏。最近团队代码库从Gerrit迁移到了Gitlab，为了让前端团队日常开发工作有条不紊，高效运转，开发历史可追溯，我也查阅和学习了不少资料。参考业界主流的Git工作流，结合公司业务特质，我也梳理了一套适合自己团队的Git工作流，在这里做下分享。 分支管理首先要说的是分支管理，分支管理是git工作流的基础，好的分支设计有助于规范开发流程，也是CI/CD的基础。 分支策略业界主流的git工作流，一般会分为develop, release, master, hotfix/xxx, feature/xxx等分支。各个分支各司其职，贯穿了整个开发，测试，部署流程。我这里也基于主流的分支策略做了一些定制，下面用一张表格简单概括下： 分支名 分支定位 描述 权限控制 develop 开发分支 不可以在develop分支push代码，应新建feature/xxx进行需求开发。迭代功能开发完成后的代码都会merge到develop分支。 Develper不可直接push，可发起merge request feature/xxx 特性分支 针对每一项需求，新建feature分支，如feature/user_login，用于开发用户登录功能。 Develper可直接push release 提测分支 由develop分支合入release分支。ps: 应配置此分支触发CI/CD，部署至测试环境。 Maintainer可发起merge request bug/xxx 缺陷分支 提测后发现的bug，应基于develop分支创建bug/xxx分支修复缺陷，修改完毕后应合入develop分支等待回归测试。 master 发布分支 master应处于随时可发布的状态，用于对外发布正式版本。ps: 应配置此分支触发CI/CD，部署至生产环境。 Maintainer可发起merge request hotfix/xxx 热修复分支 处理线上最新版本出现的bug Develper可直接push fix/xxx 旧版本修复分支 处理线上旧版本的bug Develper可直接push 一般来说，develop, release, master分支是必备的。而feature/xxx, bug/xxx, hotfix/xxx, fix/xxx等分支纯属一种语义化的分支命名，如果要简单粗暴一点，这些分支可以不分类，都命名为issue/issue号，比如issue/1，但是要在issue中说明具体问题和待办事项，保证开发工作可追溯。 保护分支利用Protected Branches，我们可以防止开发人员错误地将代码push到某些分支。对于普通开发人员，我们仅对develop分支提供merge权限。 具体操作案例请前往下面的实战案例一节查看。 issue驱动工作我们团队采用的敏捷开发协作平台是腾讯的TAPD，日常迭代需求，缺陷等都会在TAPD上记录。为了让Gitlab代码库能与迭代日常事务关联上，我决定用Gitlab issues来做记录，方便追溯问题。 里程碑里程碑Milestone可以认为是一个阶段性的目标，比如是一轮迭代计划。里程碑可以设定时间范围，用来约束和提醒开发人员。 里程碑可以拆解为N个issue，新建issue时可以关联里程碑。比如这轮迭代一共5个需求，那么就可以新建5个issue。在约定的时间范围内，如果一个里程碑关联的所有issue都Closed掉了，就意味着目标顺利达成。 标签Gitlab提供了label来标识和分类issue，我觉得这是一个非常好的功能。我这里列举了几种label，用来标识issue的分类和紧急程度。 issue分类所有的开发工作应该通过issue记录，包括但不限于需求，缺陷，开发自测试，用户体验等范畴。 需求&amp;缺陷这里大概又分为两种情况，一种是TAPD记录在案的需求和缺陷，另一种是与产品或测试人员口头沟通时传达的简单需求或缺陷（小公司会有这种情况…）。 对于TAPD记录的需求和缺陷，创建issue时应附上链接，方便查阅（上文中已有提到）。 对于口头沟通的需求和缺陷，我定了个规则，要求提出人本人在Gitlab上创建issue，并将需求或缺陷简单描述清楚，否则口头沟通的开发工作我不接（也是为了避免事后扯皮）。 ps：其实要求产品或者测试提issue，还不如上Tapd记录。我定这么个规则，其实就是借Gitlab找个说辞，杜绝口头类需求或缺陷，哈哈。 开发自测试开发者自己发现了系统缺陷或问题，此时应该通过issue记录问题，并创建相应分支修改代码。 实战案例我前面也说了，我的原则是issue驱动开发工作。 下面用几个例子来简单说明基本的开发流程。小公司里整个流程比较简单，没有复杂的集成测试，多轮验收测试，灰度测试等。我甚至连单元测试都没做（捂脸…）。 公共库和公共组件其实是很有必要做单元测试的，这里立个flag，后面一定补上单元测试。 需求开发 feature/1，一个特性分支，对应issue 1 创建需求正常的需求当然来源于产品经理等需求提出方，由于是通过示例说明，这里我自己在TAPD上模拟着写一个需求。 创建issue创建Gitlab issue，链接到TAPD中的相关需求。 创建分支&amp;功能开发基于develop分支创建feature分支进行功能开发（要保证本地git仓库当前处于develop分支，且与远程仓库develop分支同步）。 1git checkout -b feature/1 或者直接以远程仓库的develop分支为基础创建分支。 1git checkout -b feature/1 origin/develop ps：我这里用的feature/1作为分支名，其实这里的1是用的issue号，并没有用诸如feature/login_verify之类的名字，是因为我觉得用issue号可以更方便地找到对应的issue，更容易追踪代码。 接着我们开始开发新功能…… commit &amp; push完成功能开发后，我们需要提交代码并同步到远程仓库。 123456789101112131415161718PS D:\\projects\\gitlab\\project_xxx&gt; git add .PS D:\\projects\\gitlab\\project_xxx&gt; git czcz-cli@4.0.3, cz-conventional-changelog@3.1.0? Select the type of change that you&apos;re committing: feat: A new feature? What is the scope of this change (e.g. component or file name): (press enter to skip)? Write a short, imperative tense description of the change (max 94 chars): (9) 登录校验功能? Provide a longer description of the change: (press enter to skip)? Are there any breaking changes? No? Does this change affect any open issues? Yes? If issues are closed, the commit requires a body. Please enter a longer description of the commit itself: -? Add issue references (e.g. &quot;fix #123&quot;, &quot;re #123&quot;.): fix #1git push origin HEAD git cz是利用了commitizen来替代git commit。详情请点击前端自动化部署的深度实践深入了解。 fix #1用于关闭issue 1。 git push origin HEAD则代表推送到远程仓库同名分支。 创建Merge Request开发人员发起Merge Request，请求将自己开发的功能特性合入develop分支。 接着Maintainer需要Review代码，确认无误后同意Merge。然后这部分代码就在远程Git仓库入库了，其他开发同学拉取develop分支就能看到了。 版本提测 issue/2，处理更新日志，版本号等内容，对应issue 2 每个团队的开发节奏都不同，有的团队会每日持续集成发版本提测，有的可能两天一次，这个就不深入讨论了…… 那么当我们准备提测时，应该怎么做呢？ 通过上节的了解，我们已经知道，迭代内的功能需求都会通过feature/xxx分支合入到develop分支。 提测前，一般来说，还是要更新下CHANGELOG.md和package.json的版本号，可以由Maintainer或其他负责该项事务的同学执行。 主要是执行npm version major/minor/patch -m ‘something done’，具体操作可以参考前端自动化部署的深度实践一文。 1234git checkout -b issue/2 origin/developnpm version minor -m &apos;迭代1第一次提测&apos;git push origin HEAD然后发起merge request合入develop分支 此时，应以最新的develop分支代码在开发环境跑一遍功能，保证版本自测通过。 提测时，由Maintainer发起Merge Request，将develop分支代码合入release分支，此时自动触发Gitlab CI/CD，自动构建并发布至测试环境。 版本提测后，各责任人应在TAPD上将相关需求和缺陷的状态变更为“测试中”。 修复测试环境bug bug/3，一个bug分支，对应issue 3 这里说的是在迭代周期内由测试工程师发现的测试环境中的系统bug，这些bug会被记录在敏捷开发协作平台TAPD上。修复测试环境bug的步骤与开发需求类似，这里简单说下步骤： 在Gitlab上创建issue 创建issue，并附上TAPD上的缺陷链接，方便追溯 创建分支&amp;修复缺陷 基于develop分支创建分支： 12// 3是issue号git checkout -b bug/3 origin/develop 接着改代码…… commit &amp; push 1234567891011121314151617PS D:\\projects\\gitlab\\project_xxx&gt; git czcz-cli@4.0.3, cz-conventional-changelog@3.1.0? Select the type of change that you&apos;re committing: fix: A bug fix? What is the scope of this change (e.g. component or file name): (press enter to skip)? Write a short, imperative tense description of the change (max 95 chars): (11) 修复一个测试环境bug? Provide a longer description of the change: (press enter to skip)? Are there any breaking changes? No? Does this change affect any open issues? Yes? If issues are closed, the commit requires a body. Please enter a longer description of the commit itself: -? Add issue references (e.g. &quot;fix #123&quot;, &quot;re #123&quot;.): fix #3 git push origin HEAD 发起Merge Request 开发人员发起Merge Request，请求将自己修复缺陷引入的代码合入develop分支。 然后Maintainer需要Review代码，同意本次Merge Request。 等待回归测试 该bug将在下一次CI/CD后，进入回归测试流程。 级别高的测试环境Bug 如果是级别很高的bug，比如影响了系统运行，导致测试人员无法正常测试的，应以release分支为基础创建bug分支，修改完毕后合入release分支，再发起cherry pick合入develop分支。 发布至生产环境经过几轮持续集成和回归测试后，一个迭代版本也慢慢趋于稳定，此时也迎来了激动人心的上线时间。我们要做的就是把通过了测试的release分支合入master分支。 这一步相对简单，但是要特别注意权限控制（防止生产环境事故），具体权限控制可以回头看第一章节分支管理。 与release分支类似，master分支自动触发Gitlab CI/CD，自动构建并发布至生产环境。 线上回滚 revert/4，一个回滚分支，对应issue 4 代码升级到线上，但是发现报错，系统无法正常运行。此时如果不能及时排查出问题，那么只能先进行版本回退操作。 先说说惯性思维下，我的版本回退做法。 首先还是创建issue记录下： 基于master分支创建revert/4分支 1git checkout -b revert/4 origin/master 假设当前版本是1.1.0，我们想回退到上个版本1.0.3。那么我们需要先查看下1.0.3版本的信息。 1234567891011121314151617181920PS D:\\tusi\\projects\\gitlab\\projectname&gt; git show 1.0.3commit 90c9170a499c2c5f8f8cf4e97fc49a91d714be50 (tag: 1.0.3, fix/1.0.2_has_bug)Author: tusi &lt;tusi@xxx.com.cn&gt;Date: Thu Feb 20 13:29:31 2020 +0800 fix:1.0.2diff --git a/README.md b/README.mdindex ac831d0..2ee623b 100644--- a/README.md+++ b/README.md@@ -10,6 +10,8 @@ 只想修改旧版本的bug，不改最新的master+1.0.2版本还是有个版本，再修复下+ 特性2提交 特性3提交 主要是取到1.0.3版本对应的commit id，其值为90c9170a499c2c5f8f8cf4e97fc49a91d714be50。 接着，我们根据commit id进行reset操作，再推送到远程同名分支。 12git reset --hard 90c9170a499c2c5f8f8cf4e97fc49a91d714be50git push origin HEAD 接着发起Merge Request把revert/4分支合入master分支。 一般来说，这波操作没什么问题，能解决常规的回滚问题。 临时变通由于master分支是保护分支，设置了不可push。如果不想通过merge的方式回滚，所以只能先临时设置Maintainer拥有push权限，然后由Maintainer进行回滚操作。 12345git checkout mastergit pullgit show 1.0.3git reset --hard 90c9170a499c2c5f8f8cf4e97fc49a91d714be50git push origin HEAD 完事后，还需要记得把master设置为不可push。 Q: 为什么不让Maintainer一直拥有master的push权限？ A: 主要还是为了防止出现生产环境事故，给予临时性权限更稳妥！ git reset –hard存在什么问题？如题，git reset --hard确实是存在问题的。git reset --hard属于霸道玩法，直接移动HEAD指针，会丢弃之后的提交记录，如果不慎误操作了也别慌，还是可以通过查询git reflog找到commitId抢救回来的；git reset后还存在一个隐性的问题，如果与旧的branch进行merge操作时，会把git reset回滚的代码重新引入。那么怎么解决这些问题呢？ 别慌，这个时候你必须掏出git revert了。 Q: git revert的优势在哪？ A: 首先，git revert是通过一次新的commit来进行回滚操作的，HEAD指针向前移动，这样就不会丢失记录；另外，git revert也不会引起merge旧分支时误引入回滚的代码。最重要的是，git revert在回滚的细节控制上更加优秀，可解决部分回滚的需求。 举个栗子，本轮迭代团队共完成需求2项，而上线后发现其中1项需求有致命性缺陷，需要回滚这个需求相关的代码，同时要保留另一个需求的代码。 首先我们查看下日志，找下这两个需求的commitId 12345PS D:\\tusi\\projects\\test\\git_test&gt; git log --oneline86252da (HEAD -&gt; master, origin/master, origin/HEAD) 解决冲突e3cef4e (origin/release, release) Merge branch 'develop' into 'release'f247f38 (origin/develop, develop) 需求289502c2 需求1 我们利用git revert回滚需求1相关的代码 1git revert -n 89502c2 这时可能要解决冲突，解决完冲突后就可以push到远程master分支了。 123git add .git commit -m '回滚需求1的相关代码，并解决冲突'git push origin master 感觉还是菜菜的，如果大佬们有更优雅的解决方案，求指导啊！ 修复线上bug hotfix/5，一个线上热修复分支，对应issue 5 比如线上出现了系统无法登录的bug，测试工程师也在TAPD提交了缺陷记录。那么修复线上bug的步骤是什么呢？ 创建issue，标题可以从TAPD中的Bug单中copy过来，而描述就贴上Bug单的链接即可。 基于master分支创建分支hotfix/5。 1git checkout -b hotfix/5 origin/master 撸代码，修复此bug…… 修复完此bug后，提交该分支代码到远程仓库同名分支 1git push origin HEAD 然后发起cherry pick合入到master和develop分支，并在master分支打上新的版本tag（假设当前最大的tag是1.0.0，那么新的版本tag应为1.0.1）。 修复线上旧版本bug fix/6，一个线上旧版本修复分支，对应issue 6 某些项目产品可能会有多个线上版本同时在运行，那么不可避免要解决旧版本的bug。针对线上旧版本出现的bug，修复步骤与上节类似。 创建issue，描述清楚问题 假设当前版本是1.0.0，而0.9.0版本出了一个bug，应基于tag 0.9.0创建fix分支。 1git checkout -b fix/6 0.9.0 修复缺陷后，应打上新的tag 0.9.1，并推送到远程。 12git tag 0.9.1git push origin tag 0.9.1 如果此bug也存在于最新的master分支，则需要git push origin HEAD提交该fix分支代码到远程仓库同名分支，然后发起cherry pick合入到master，此时很大可能存在冲突，需要解决冲突。 cherry pick在了解到cherry pick之前，我一直认为只有git merge可以合并代码，也好几次遇到合入了不想要的代码的问题。有了cherry pick，我们就可以合并单次提交记录，解决git merge时合并太多不想要的内容的烦恼，在解决bug时特别有用。 git rebase经过这段时间的使用，我发现使用git merge合并分支时，会让git log的Graph图看起来有点吃力。 1234567891011121314151617181920212223PS D:\\tusi\\projects\\gitlab\\projectname&gt; git log --pretty --oneline --graph* 7f513b0 (HEAD -&gt; develop) Merge branch &apos;issue/55&apos; into &apos;release&apos;|\\| * 1c94437 (origin/issue/55, issue/55) fix: 【bug】XXX1| * c84edd6 Merge branch &apos;release&apos; of host:project_repository into release| |\\| |/|/|* | 115a26c Merge branch &apos;develop&apos; into &apos;release&apos;|\\ \\| * \\ 60d7de6 Merge branch &apos;issue/30&apos; into &apos;develop&apos;| |\\ \\| | * | 27c59e8 (origin/issue/30, issue/30) fix: 【bug】XXX2| | | * ea17250 Merge branch &apos;release&apos; of host:project_repository into release| | | |\\| |_|_|/|/| | |* | | | 9fd704b Merge branch &apos;develop&apos; into &apos;release&apos;|\\ \\ \\ \\| |/ / /| * | | a774d26 Merge branch &apos;issue/30&apos; into &apos;develop&apos;| |\\ \\ \\| | |/ / 接着我就了解到了git rebase，变基，哈哈哈。由于对rebase了解不深，目前也不敢轻易改用rebase，毕竟rebase还是有很多隐藏的坑的，使用起来要慎重！在这里先挖个坑吧，后面搞懂了再填坑…… 注意事项 一般而言，自己发起的Merge Request必须由别的同事Review并同意合入，这样更有利于发现代码问题。 对了，TAPD还支持与Gitlab协同的。详情见源码关联指引。 结语实践证明，这套Git工作流目前能覆盖我项目开发过程中的绝大部分场景。不过要注意的是，适合自己的才是最好的，盲目采用别人的方案有时候是会水土不服的。 以上所述纯属前端小微团队内部的Gitlab实践，必然存在着很多不足之处，如有错误之处还请指正，欢迎交流。","link":"/前端小微团队的gitlab实践.html"},{"title":"前端攻城狮HTML5自查手册","text":"HTML5自2014年发布以来，已经有快5个年头了。但是很多人对H5有哪些新特性，兼容性如何仍然是一头雾水的。为了让自己以后方便查阅，本文整理一下H5的相关知识点，不做深入的探讨，错误之处还请指正！ HTML5标签上的改动HTML 5 参考手册 废弃或不支持的标签 &lt;acronym&gt; 定义首字母缩略词。HTML5 不支持 &lt;acronym&gt; 标签。请使用 &lt;abbr&gt; 标签代替它。 &lt;applet&gt; 可以嵌入Java语言编写的小应用程序。HTML5 不支持 &lt;applet&gt; 标签。请使用 &lt;object&gt; 标签代替它。在 HTML 4.01 中，&lt;applet&gt; 元素 已废弃。 &lt;basefont&gt; 只有 IE 9 和更早版本的 IE 浏览器支持 &lt;basefont&gt; 标签。应该避免使用该标签。在 HTML 4.01 中，&lt;basefont&gt; 元素 已废弃。 &lt;big&gt; 用来制作更大的文本。HTML5 不支持 &lt;big&gt; 标签。请用 CSS 代替。 &lt;center&gt; 对其所包括的文本进行水平居中。在 HTML 4.01 中，&lt;center&gt; 元素 已废弃 &lt;dir&gt; 被用来定义目录列表，类似ul，ol。在 HTML 4.01 中，&lt;dir&gt; 元素 已废弃。 &lt;font&gt; 规定文本的字体、字体尺寸、字体颜色。在 HTML 4.01 中，&lt;font&gt; 元素 已废弃。 &lt;frame&gt; 定义 中的子窗口（框架），必须放在&lt;frameset&gt;标签中，且不能与&lt;body&gt;共存。HTML5 不支持 &lt;frame&gt; 标签。 &lt;frameset&gt; 定义一个框架集，被用来组织一个或者多个&lt;frame&gt;元素。每个&lt;frame&gt;有各自独立的文档。HTML5 不支持&lt;frameset&gt;标签。 &lt;isindex&gt; 使浏览器显示一个对话框，提示用户输入单行文本，该特性已经从 Web 标准中删除。 &lt;noframes&gt; 可为那些不支持框架的浏览器显示文本。HTML5 不支持 &lt;noframes&gt;标签。 123456&lt;frameset cols=&quot;25%,50%,25%&quot;&gt; &lt;frame src=&quot;frame_a.htm&quot;&gt; &lt;frame src=&quot;frame_b.htm&quot;&gt; &lt;frame src=&quot;frame_c.htm&quot;&gt; &lt;noframes&gt;Sorry, your browser does not handle frames!&lt;/noframes&gt;&lt;/frameset&gt; &lt;strike&gt; 定义加删除线文本。在 HTML 4.01 中，&lt;strike&gt; 元素 已废弃。HTML5 不支持 &lt;strike&gt; 标签。请用 &lt;del&gt; 标签代替。 &lt;tt&gt; 定义打字机文本。HTML5 不支持&lt;tt&gt;标签。请用 CSS 代替。 新增的标签IE 9+、Firefox、Opera、Chrome 和 Safari 都支持新增的大部分 H5 标签。 结构标签 &lt;main&gt; 规定文档的主要内容。在一个文档中，不能出现一个以上的 &lt;main&gt; 元素。&lt;main&gt; 元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 或 &lt;nav&gt;。所有浏览器都支持&lt;main&gt;标签，除了 Internet Explorer。 &lt;article&gt; 定义独立的内容，内容本身必须是有意义的且必须是独立于文档的其余部分。比如：论坛帖子，博客文章，新闻故事，评论。 &lt;aside&gt; 常用作侧边栏。 &lt;section&gt; 定义了文档的某个区域。比如章节、头部、底部或者文档的其他区域。 &lt;header&gt; 定义文档或者文档的一部分区域的页眉。 &lt;hgroup&gt; 被用来对标题元素进行分组。 &lt;footer&gt; 定义文档或者文档的一部分区域的页脚。 &lt;nav&gt; 定义导航链接的部分。 媒体标签 &lt;audio&gt; 定义声音，比如音乐或其他音频流。支持的3种文件格式：MP3、Wav、Ogg。 &lt;video&gt; 定义视频，比如电影片段或其他视频流。支持三种视频格式：MP4、WebM、Ogg。 &lt;track&gt; 为媒体元素（比如 &lt;audio&gt; and &lt;video&gt;）规定外部文本轨道。IE 10、Opera 和 Chrome 浏览器支持 &lt;track&gt; 标签，其他浏览器不支持。 &lt;source&gt; 为媒体元素（比如 &lt;audio&gt; and &lt;video&gt;）定义媒体资源。 其他标签 &lt;canvas&gt; 画布，可以绘制丰富的图形，赋予了html更多想象的空间。 &lt;datalist&gt; 配合&lt;option&gt;标签制作下拉列表，与&lt;select&gt;不同的一点是，&lt;datalist&gt;支持输入，模糊匹配。 &lt;details&gt; 类似于折叠面板的一个控件，规定了用户可见的或者隐藏的需求的补充细节。&lt;summary&gt;标签可以为 &lt;details&gt; 定义标题。标题是可见的，用户点击标题时，会显示出 &lt;details&gt;。目前，只有 Chrome 和 Safari 6 支持 &lt;details&gt; 标签。 &lt;summary&gt; 与&lt;details&gt;标签配合使用。只有 Chrome 和 Safari 6 支持 &lt;summary&gt; 标签。 &lt;embed&gt; 定义了一个容器，用来嵌入外部应用或者互动程序（插件），例如flash等。 &lt;figure&gt; 规定独立的流内容（图像、图表、照片、代码等等）。 &lt;figcaption&gt; &lt;figcaption&gt;元素被用来为&lt;figure&gt;元素定义标题。 &lt;mark&gt; 定义带有记号的文本。请在需要突出显示文本时使用&lt;mark&gt; 标签。 &lt;meter&gt; 定义度量衡。仅用于已知最大和最小值的度量。不能作为一个进度条来使用。Firefox、Opera、Chrome 和 Safari 6 支持 &lt;meter&gt; 标签。IE不支持该标签。 &lt;progress&gt; 定义运行中的任务进度（进程）。有value和max属性。 &lt;output&gt; 作为计算结果输出显示(比如执行脚本的输出)。配合两个&lt;input&gt;使用，可实时求和。Internet Explorer 浏览器不支持 &lt;output&gt; 标签。 &lt;ruby&gt; 定义 ruby 注释（中文注音或字符）。 &lt;rp&gt; 在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容。 &lt;rt&gt; 定义字符（中文注音或字符）的解释或发音。 &lt;time&gt; 定义公历的时间（24 小时制）或日期，时间和时区偏移是可选的。用datetime属性对标签中的文字作时间解释。 &lt;bdi&gt; 允许您设置一段文本，使其脱离其父元素的文本方向设置。具体应用不详。 让IE8及以下版本也支持H5新标签我们经常会用到&lt;main&gt;、&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 、&lt;nav&gt;来进行页面布局，那么如何解决IE8及以下版本支持这些标签呢？只要利用createElement让浏览器识别这些标签，并在css中给他们设置一些属性即可，比如display:block。现成的解决方案就是htmlshiv.js。 123&lt;!--[if lt IE 9]&gt;&lt;script src=&quot;js/html5shiv.js&quot;&gt;&lt;/script&gt;&lt;![endif]--&gt; 如果有打印需求，则需要html5shiv-printshiv.js，它包含 html5shiv.js 的全部功能，并且额外支持 IE6-8 网页打印时 HTML5 元素样式化。 HTML5属性上的改动新增的属性IE 9+、Firefox、Opera、Chrome 和 Safari 都支持新增的大部分 H5 属性，特殊情况会在每一项处有说明。 HTML5标准属性 contenteditable 规定是否允许用户编辑内容。可用于制作富文本等功能。兼容性较好，见下图。 contextmenu 规定了元素的上下文菜单。当用户右击元素时将显示上下文菜单。contextmenu 属性的值是需要打开的&lt;menu&gt;元素的 id。兼容性不好，目前只有 Firefox 浏览器支持 contextmenu 属性。 data-* 管理自定义属性。自定义属性可通过元素的dataset进行访问。如ele.dataset.customAttr。 兼容性见下图，IE6~8也支持data-*，但是不能通过dataset访问，必须用getAttribute访问。 draggable 规定元素是否可拖动。链接和图像默认是可拖动的。 1&lt;element draggable=&quot;true|false|auto&quot;&gt; 主要关注的内容有属性draggable，事件ondragstart，事件ondragover，事件ondrop，数据属性dataTransfer，以及dataTransfer下的两个方法setData和getData。 简单demo可以参考HTML5拖放教程。 hidden hidden 属性规定对元素进行隐藏。IE兼容性不太好，避免使用，用css替代即可。 spellcheck 规定是否对元素内容进行拼写检查。启用后会对单词进行拼写检查，不正确的单词会有波浪线提示。Internet Explorer 10, Firefox, Opera, Chrome, 和 Safari 浏览器支持 spellcheck 属性。 1&lt;element spellcheck=&quot;true|false&quot;&gt; 更丰富的表单input支持更多type HTML5 中的新类型：color、date、datetime、datetime-local、month、week、time、email、number、range、search、tel 和 url。其实也是一种语义化的表现。 值 描述 color 定义拾色器。兼容性很差，对IE，Edge，Safari等浏览器不友好，详细情况见兼容性 date 定义 date 控件（包括年、月、日，不包括时间）。兼容性很差。 datetime 定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，基于 UTC 时区）。兼容性很差。 datetime-local 定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）。兼容性很差。 month 定义 month 和 year 控件（不带时区）。兼容性很差。 week 定义 week 和 year 控件（不带时区）。兼容性很差。 time 定义用于输入时间的控件（不带时区）。兼容性很差。 email 定义用于 e-mail 地址的字段。会对邮箱进行格式检查。支持IE10以上，详细情况见兼容性 number 定义用于输入数字的字段。在各个浏览器上有一些差异 range 定义滑块。支持IE10以上，详细情况见兼容性 search 定义用于输入搜索字符串的文本字段。支持IE10以上，但是在UI表现上与text没有差别。查看详情 tel 定义用于输入电话号码的字段。支持IE10以上，详细情况见兼容性 url 定义用于输入 URL 的字段。会对url进行格式检查。支持IE10以上，详细情况见兼容性 其他表单控件属性 属性 描述 placeholder 可描述输入字段预期值的简短的提示信息，支持IE10以上，适用于下面的 input 类型：text、search、url、tel、email 和 password。 autofocus 页面加载时自动获得焦点，支持IE10以上。 multiple 规定允许用户输入到 input 元素的多个值。适用于以下 input 类型：email 和 file。常见于上传文件时选择多个文件。 form 规定 input 元素所属的一个或多个表单的 id 列表，以空格分隔。可以实现将 input 放在 form 标签外部。但是不支持IE。 required 规定必需在提交表单之前填写输入字段，支持IE10以上。 maxlength 规定 input 元素中允许的最大字符数，适用于text类型。 minlength 规定 input 元素中允许的最小字符数，适用于text类型。 max 规定 input 元素的最大值，max 和 min 属性适用于以下 input 类型：number、range、date、datetime、datetime-local、month、time 和 week。支持IE10以上，不支持firefox，其中IE10不支持max用于date 和 time类型。 min 规定 input 元素的最小值。 pattern 规定 input 元素的正则表达式校验。适用于下面的 input 类型：text、search、url、tel、email 和 password。应该配合 title 属性提示用户。 HTML5其他新特性支持IE9+ 音视频 标签 描述 source 为媒体元素（比如 video 和 audio）定义媒体资源。主要定义其 src 属性和 type 属性，src 规定媒体文件的 URL，type 规定媒体资源的 MIME 类型。 audio 定义音频。对mp3文件的兼容性最好。 video 定义视频。对MP4文件的兼容性最好。 画布canvas可以说是前端高级部分了，这里一言难尽，慢慢学习吧。支持IE9+。与之相关的svg也是支持IE9+。 Web存储主要包括sessionStorage和localStorage，操作的API都类似，区别是sessionStorage是会话级存储，localStorage是持久化存储。兼容性挺好，支持IE8+。 地理定位geolocationnavigator下的一个属性，鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。支持IE9+。 HTML5 Application Cache实现网页离线访问的利器。支持IE10+。相关的最新技术还有PWA等。 Web Worker让js也能做多线程的事情，相关内容可以参考Web Worker 使用教程。MDN上也有比较详细的解释。 HTML 5 服务器发送事件 EventSourceEventSource 接口用于接收服务器发送的事件。它通过HTTP连接到一个服务器，以text/event-stream 格式接收事件, 不关闭连接(即长连接)。兼容性不是很好，IE和Edge直接废了。不过有一个兼容方案 event-source-polyfill。 HTML5 WebSocketWebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。对IE10+能较好兼容，对于不兼容的浏览器，也有很多优雅降级方案，一般是降级成ajax轮询等，像socket.io。 通知接口NotificationNotifications API 的通知接口用于向用户显示桌面通知。查看具体用法。兼容性不是很好，但是用起来网站的逼格高不少，如果是IE就直接放弃吧。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/前端攻城狮HTML5自查手册.html"},{"title":"前端自动化部署的深度实践","text":"年前我也在自动化部署这方面下了点功夫，将自己的学习所得在自动化部署的一小步，前端搬砖的一大步这篇博客中做了分享。感谢两位网友@_shanks和@TomCzHen的意见，让我有了继续优化部署流程的动力。本文主要是在自动化部署流程中，对版本管理和流程合理性等方面做了一些改进，配合规范的工作流，使用体验更佳！ 更新日志自动生成之前我都是手动修改CHANGELOG.md，用来记录更新日志，感觉操作起来有点心累，也不是很规范。好在已有前人种树，于是我就考虑利用conventional-changelog-cli自动生成和更新CHANGELOG.md，真的好用！ 什么是conventional-changelog Generate a changelog from git metadata 根据git元数据生成更新日志，而conventional-changelog-cli则是相关的命令行工具。 安装conventional-changelog-cli1npm install -g conventional-changelog-cli 初始化生成CHANGELOG.md12cd my-projectconventional-changelog -p angular -i CHANGELOG.md -s 以上命令是基于最后一次的Feature, Fix, Performance Improvement or Breaking Changes等类型的commit记录生成或更新CHANGELOG.md。如果你希望根据之前所有的commit记录生成完整的CHANGELOG.md，那么可以试试下面这条命令： 1conventional-changelog -p angular -i CHANGELOG.md -s -r 0 工作流代码添加到暂存区这一步没有什么特殊，日常撸代码，然后将工作区的内容添加到暂存区。 1git add . 规范commit message 一个规范的commit message一般分为三个部分Header，Body 和 Footer。Header包含type, scope, subject等部分，分别用于描述commit类型，影响范围，commit简述。Body则是详细描述，可以分多行写。Footer主要用于描述不兼容改动（Breaking Change）或者关闭issue（Closes #issue）。 格式如下： 12345&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;body&gt;&lt;footer&gt; 举个栗子： 123456feat(支持自动部署): 结合conventional-changelog，配合部署脚本完成部署任务conventional-changelog是一个很好的工具，用于自动生成changelog，再配上自定义的部署脚本，整个部署流程就显得更规范了Breaking Change: 比较大的更新Closes #315 其中，Header是必需的，Body和Footer可以省略。 大致了解规范后，就可以上工具了，这里我们用到的是commitizen。 1npm install -g commitizen 接着在项目根目录运行以下命令： 1commitizen init cz-conventional-changelog --save --save-exact 运行成功后，package.json会新增如下内容： 12345678\"devDependencies\": { \"cz-conventional-changelog\": \"^3.1.0\"},\"config\": { \"commitizen\": { \"path\": \"./node_modules/cz-conventional-changelog\" }} git commit这一步用git cz替代，cz就是指commitizen，通过交互式命令行完成commit操作。 12345678910111213PS D:\\robin\\frontend\\spa-blog-frontend&gt; git czcz-cli@4.0.3, cz-conventional-changelog@3.1.0? Select the type of change that you're committing: feat: A new feature? What is the scope of this change (e.g. component or file name): (press enter to skip) 支持自动部署? Write a short, imperative tense description of the change (max 86 chars): (37) 结合conventional-changelog，配合部署脚本完成部署任务? Provide a longer description of the change: (press enter to skip)? Are there any breaking changes? No? Does this change affect any open issues? No[master ee41f35] feat(支持自动部署): 结合conventional-changelog，配合部署脚本完成部署任务 3 files changed, 15 insertions(+), 3 deletions(-) 处理版本号，更新CHANGELOG接着我们要更新npm包的版本号，结合npm version和conventional-changelog使用，可以同时更新CHANGELOG.md。 好的，我们先准备好脚本： 1234567\"scripts\": { \"start\": \"vue-cli-service serve\", \"build\": \"vue-cli-service build\", \"deploy\": \"node deploy\", \"version\": \"conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md\", \"postversion\": \"npm run deploy\"} 根据实际版本情况选择更新patch/minor/major版本。假设我们更新的是minor版本号，那么操作命令如下： 1npm version minor -m '特性版本更新' 执行这条命令会更新package.json中的version字段， 同时会执行conventional-changelog -p angular -i CHANGELOG.md -s &amp;&amp; git add CHANGELOG.md，更新CHANGELOG.md。 执行完这条命令后，可以看到CHANGELOG.md已经被修改了。 npm钩子触发部署脚本通过postversion钩子触发部署脚本node deploy，开始进行部署工作。deploy.js文件内容如下： 12345678910const { execFile } = require('child_process');const version = process.env.npm_package_version;execFile('deploy.sh', [version], { shell: true }, (err, stdout, stderr) =&gt; { if (err) { throw err; } console.log(stdout);}); 这里利用了nodejs的 child_process模块执行子进程，调用了execFile执行了 deploy.sh，并将npm包版本号作为参数传递给了deploy.sh。 deploy.sh文件内容如下： 12345678910111213#!/bin/bashnpm run buildhtmldir=\"/usr/share/nginx/html\"uploadbasedir=\"${htmldir}/upgrade_blog_vue_ts\"appenddir=$1uploaddir=\"${uploadbasedir}/${appenddir}\"projectdir=\"/usr/share/nginx/html/blog_vue_ts\"scp -r ./dist/. txcloud:${uploaddir}ssh txcloud &gt; /dev/null 2&gt;&amp;1 &lt;&lt; eeooffln -snf ${uploaddir} ${projectdir}exiteeooffecho done 以上命令主要做的事情是： npm run build执行构建任务 将构建得到的dist文件夹中的内容通过scp传输到服务器，通过版本号区分各个版本。 nginx配置的是监听80端口，指向/usr/share/nginx/html/blog_vue_ts，而我通过软连接将blog_vue_ts再次指向到upgrade_blog_vue_ts下的版本目录，如upgrade_blog_vue_ts/0.5.4。每次发布版本时，以上脚本会修改软连接，指向目标版本，如upgrade_blog_vue_ts/0.6.0，完成版本过渡。 我这里使用了软连接改进了之前的部署脚本，既可以在服务器保留各个历史版本文件夹，也不用考虑处理index.html与静态资源分离的问题。 强烈建议结合自动化部署的一小步，前端搬砖的一大步这篇文章一起看。 1lrwxrwxrwx 1 root root 47 Feb 3 21:35 blog_vue_ts -&gt; /usr/share/nginx/html/upgrade_blog_vue_ts/0.6.0 如果要回退版本，也可以通过修改软连接的方式实现，还是比较方便的。 推送到remote最后别忘了把代码push到远程仓库。 1git push 更新日志changelog查看也变得很方便了，修改了什么内容一目了然，并且可以直接跳转到commit历史，issue等。 番外可以看到，我是通过deploy.js调用了deploy.sh。之前本想直接在npm scripts中调用deploy.sh并传入版本号参数的，但是试了几种写法都不行，这里也记录一下。 1\"deploy\": \"deploy.sh npm_package_version\" 1\"deploy\": \"deploy.sh $npm_package_version\" 看起来在npm scripts中调用sh脚本时，只能写字面量参数，传变量作为参数好像行不通。 下面这种字面量参数写法是可以的，但是就有点呆呆的感觉了，而且与自动化部署的主题不符。 1\"deploy\": \"deploy.sh 0.6.0\" 所以我目前还是选择通过deploy.js作为中间者来调用deploy.sh的。 结语需要承认的是，我以上所述的部署流程是以我的个人项目为例说明，可能不是很规范，但是也算是通过自己的理解和摸索，完整地搞了一套部署流程，并没有借用jenkins等工具。有了这段自动化部署的学习经历后，相信学习和使用jenkins会变得更轻松。接下来我会继续优化和规范自己的部署流程，jenkins理所当然会出现在我的计划表中。 我是Tusi，一个创业公司前端小leader，每天依然为写不完的业务代码烦恼，在打磨产品道路上沉淀技术，探索成长路线。如果你与我一样，正在思考自己的技术成长与价值，欢迎加我微信交流探讨，微信号laobaife。我会在公众号前端司南和小程序Tusi博客同步博客内容，快来撩我！","link":"/前端自动化部署的深度实践.html"},{"title":"前端面试题记录","text":"最近在找工作，面试过程中发现自己对一些概念的叙述不是特别清楚。唉，让我自己写代码可能没有毛病，但是好像就是说不出这些概念，这无疑让自己在面试中丢了分。所以还是做下笔记吧，预祝自己在后面的面试中愈战愈勇！ 一.spa和多页应用的区别1.spa由一个外壳和页面片段组成，通常用路由跳页面，局部刷新。非spa每个页面都是一个新页面，有一套独立的html，甚至css，js，页面跳转需要重新加载资源。2.spa数据传递方便，因为页面未销毁。非spa传递参数依赖url或者Cookie，SessionStorage，LocalStorage等。3.单页面不利于seo，多页面相反。4.单页面开发成本高，依赖框架。多页面开发简单，但是重复代码多。 二.同步和异步js是单线程的，但是可以实现异步。js有主线程，也有一个任务队列。主线程的任务是同步执行的，前一个任务完成后，才执行后一个任务，而放入任务队列的是异步任务，当任务队列告诉主线程该任务可以执行了，异步任务才进入主线程执行。 三.Event Loopjs有事件轮训机制，主线程中的任务结束后，会查询任务队列，把任务队列中的第一个可执行任务压入主线程执行。 四.多页面传递数据简单的数据可以放在url的search部分，用location.search获取，复杂的数据可以存在Storage，Cookie，或者请求后台接口实现。 五.location.reload()默认从浏览器缓存中重载页面，如果传参是true，则从服务器重载。 六.angular是双向绑定还是单向数据流？都有，一般的插值表达式就是单向数据流，数据改变才引起ui改变。[(ngModel)]是双向绑定。 七.angular组件之间通信父组件通过[]属性绑定向子组件传数据，子组件通过@Input接收数据。子组件通过@Output和EventEmitter发送事件给父组件，父组件模板中以()绑定事件回调函数。 八.如何理解RESTful？RESTful（Representational State Transfer）是一种思想，很难用一两句话来解释。可以理解为：所有的资源都可以抽象为一个url，通过http请求（包括POST，GET，PUT，PATCH，DELETE）来获取资源，完成操作后通过HTTP的状态码2xx/4xx来完成状态的转换。 九.http请求的几种类型1、GET请求主要是查询数据的请求，不会修改、增加数据，不会影响资源的内容，是幂等的，即无论进行多少次操作，结果都是一样的。GET请求的参数体现在url上，能够被浏览器缓存，保存历史记录，请求的长度有限制。 2、PUT请求是向服务器端发送数据的，就像数据库的update操作一样，用来修改数据的内容，也是幂等的。 3、POST请求同PUT请求类似，都是向服务器端发送数据的，但是该请求会改变数据的种类等资源，就像数据库的create或insert操作一样，会创建新的内容。POST请求不会被浏览器缓存，也不能创建书签。POST请求参数在请求体正文中，相比GET更加安全。 4、DELETE请求顾名思义，就是用来删除某一个资源的，该请求就像数据库的delete操作。 5、OPTIONS：这个也是常见的请求类型，但一般不是由开发者指定，当涉及跨域时，浏览器会自动发起预检，获取目的资源所支持的请求类型。 6、注：所有的增删改查几乎都能用GET、POST实现，因此很少会选择使用PUT和DELETE请求。 十.如何理解http请求的无状态？http响应是有状态码的，但是http请求却说是无状态的，这让人很是迷惑。其实http的无状态是指：每次的请求都是独立的，与之前和之后的请求无关联，服务器中没有保存客户端的状态。但是如果加上Cookie控制，则可以进行状态管理。 十一.如何理解闭包？js函数内部的变量是不能被函数外部所引用的，闭包就是能够读取其他函数内部变量的函数。通常的形式是在函数内定义一个内部函数，内部函数引用了外部函数作用域中的变量，然后又作为外部函数的返回值被上层作用域使用，这样就形成了闭包。 十二.如何理解原型和原型链？1.任何对象都有原型proto，对象的原型指向构造函数的prototype属性。构造函数的prototype属性上有一个construtor属性，指向构造函数本身。 1234var A = function () {};var a = new A();a.__proto__ === A.prototype; // 结果为trueA === A.prototype.constructor; // 结果为true 2.js查询对象属性时，会首先从对象本身查找，如果找不到，则会顺着原型链（proto，而不是prototype）查找。常见的原型链继承写法： 1234567var Father = function () {};Father.prototype.type = 'male';Father.prototype.age = '40';var Son = function () {};Son.prototype = Object.create(Father.prototype);Son.prototype.constructor = Son;console.log(new Son().type); 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/前端面试题记录.html"},{"title":"千万别小看这些运算符背后的逻辑","text":"前言最近回顾javascript的一些基础知识点时，引起的思考确实颠覆了我之前的一些认知。我清楚地记得曾多次在网上看到一些奇奇怪怪的表达式，它们的运算结果着实让人懵逼。就比如我在js数据类型很简单，却也不简单这一篇笔记中提到的[] == ![]这样一个表达式，它的运算结果是true。如果你不细致地去研究它背后的运算逻辑，你只会惊呼”这是什么鬼“？相反，当你静下心来看清楚它的运算逻辑后，你会感叹“妙哉妙哉”！没错，本文的主角就是这些容易让人小觑的运算符。 加法运算符+首先说的是加法运算符+，这是一个很容易被人忽视的运算符。我们知道，+可以用来做数字运算，也可以用作字符串拼接，但是还有一些细节可能是大家不知道的。如果+运算符的两个操作数类型不一致，或者说两个操作数既不是字符串也不是数字，那么它的运算规则是什么？ 先举几个例子，你可以先思考下这些运算结果分别是什么。 1234567var a = 1 + \"1\";var b = 1 + {};var c = 1 + [];var d = 1 + true;var e = { name: '飞白' } + [1, 2];var f = null + undefined;var g = true + null; 其实规则很简单，我们只要简单地列举出数据类型的可能性，就几乎得到了完整的答案。 如果操作数都是数字，进行数字的加法运算。 如果操作数都是字符串，进行字符串的拼接。 如果操作数是对象，会转换为原始值（一般是先调用valueOf()，日期对象比较特殊，会调用toString()），得到的原始值不再被强制转换为数字或字符串。在这种约束下，对象转为原始值基本都是字符串（如果你没有重写valuOf()或者toString()方法），根据下面的第四点，会执行字符串拼接操作。 如果其中一个操作数是字符串，另一个操作数也会被转为字符串，+运算符执行字符串拼接操作。 如果两个操作数都不是字符串或对象，则会进行算术加法运算（非数字的操作数会被强制转为数字）。 所以，不难得出上面列举的表达式的运算结果。 1234567var a = 1 + \"1\"; // \"11\"var b = 1 + {}; // \"1[object Object]\"var c = 1 + []; // \"1\"var d = 1 + true; // 2var e = { name: '飞白' } + [1, 2]; // \"[object Object]1,2\"var f = null + undefined; // NaNvar g = true + null; // 1 要记住这些规则并不简单，一个记忆技巧是：+运算符偏爱字符串拼接操作。 相等运算符==这个运算符的运算规则，在js数据类型很简单，却也不简单这篇笔记中已经简单地解释过了。其实只要记住一条规则：对于==运算符，如果两个操作数是null或undefined，运算结果是true；否则，不管操作数的类型如何转换，==运算符最后都是数字的比较。 举几个简单的例子说明下： 12345null == undefined; // true[1] == 1; // true1 == true; // true1 == \"1\" // truenew Date(2020, 0, 1, 0, 0, 0) == 1577808000000 // false 比较运算符大于&gt;，大于等于&gt;=，小于&lt;，小于等于&lt;=，用于比较数字的大小或字符在字母表中的排序。要注意的是，在ASCII中，大写字母排在小写字母前面。 这些比较运算符更偏爱数字的比较，除非两个操作数都是字符串。 对于字符串比较的情况，如果两个字符串的第一个字符是相同的，则会比较第二个字符，以此类推。 这里有一个比较特殊的NaN，它与任何值做比较都会返回false。 12NaN &lt; 1; // falseNaN &gt; 1; // false 位运算符位运算符很少用到，但是弄明白它们的运算逻辑是很有必要的。位运算符主要分为与&amp;、或|、非~、异或^以及左移&lt;&lt;、带符号右移&gt;&gt;、无符号右移&gt;&gt;&gt;等。 位运算符都是二进制的运算，并且是基于32位整数运算。所以十进制，十六进制的操作数都会先转为32位的二进制后再进行运算。这里以0x1234 &amp; 0x00FF = 0x0034为例说明下流程： 0x123转为二进制是0000 0000 0000 0000 0001 0010 0011 0100，0x00FF转为二进制是0000 0000 0000 0000 0000 0000 0011 0100。 进行按位与操作，结果是0000 0000 0000 0000 0000 0000 0011 0100，最后转为十六进制就是0x0034。 移位运算符在复习到移位运算符这块时，我不由得提出了一个疑问：“javascript中为什么没有无符号左移运算符？”要解答这样一个疑问，首先还是要看看左移和右移分别是怎么运算的。 摘取《计算机组成原理教程》书中的一段描述： 计算机中机器数的字长往往是固定的，当机器数左移n位或右移n位时，必然会使其n位低位或n位高位出现空位。那么，对空出的空位应该添补0还是1呢？这与机器数采用有符号数还是无符号数有关。对无符号数的移位称为逻辑移位，对有符号数的移位称为算术移位。 注意：在javascript中，移位运算符只支持移动0~31位，如果移动的位数超过了31位，位数会取模MOD 32。也就是说： 1231 &lt;&lt; 32// 等价于1 &lt;&lt; 0 带符号右移&gt;&gt;对于带符号右移（算术右移）运算而言，第一个操作数是有符号数，它的最高位代表符号位，在移位后的符号位不改变。简单总结就是“低位舍弃，高位补符号位”。 123var a = -1;a &gt;&gt; 2; // -1// 用负数的补码形式进行算术右移，高位补1 如果你自己写几个右移运算表达式做试验，你就会产生一个疑惑，为什么有的正数在带符号右移后却变成了负数，比如下面这个： 12147483648 &gt;&gt; 31 // -1 这是因为32位的最大带符号正整数是231 - 1，即2147483647，转换为二进制是0111 1111 1111 1111 1111 1111 1111 1111。正数的补码与原码相同，2147483648相当于在此基础上加1，就得到补码1000 0000 0000 0000 0000 0000 0000 0000，而这个补码是一个非常特殊的码，它没有对应的原码和补码，代表32位能表示的带符号数中最小的负数231 - 1，即-2147483648。而2147483648在32位带符号正数中是无法表示的，其值已经溢出了。 计算机只理解二进制，与人类所理解的十进制之间永远存在一个精度问题，需要足够的精度才能更加准确地表示十进制，而计算机的位数永远都是有限的，这就是矛盾存在的地方，所以会出现溢出这种现象。 就好比时钟一般，23时结束了又从0时开始。在带符号二进制表示法中，正数和负数首尾相连，形成一个环，在计算机可表示的范围内，溢出的那个数字在某种意义上能在另一个起点找到。 所以，下面的位运算表达式也是等价的： 122147483649 &gt;&gt; 1 // -1073741824-2147483647 &gt;&gt; 1 // 可以理解为：2147483649溢出的值为2，所以在位运算中，等价于第二小的负数-2147483647 无符号右移&gt;&gt;&gt;无符号右移也称为逻辑右移。无符号右移的移位过程中，符号位可能会改变。因此移位后，原来的负数可能变成正数。可以简单记忆为“低位舍弃，高位补0”。 123-1 &gt;&gt;&gt; 2; // 1073741823// 1000 0000 0000 0000 0000 0000 0000 0001 右移两位变成 0010 0000 0000 0000 0000 0000 0000 0000// 也就是2的30次方减去1，等于1073741823 左移&lt;&lt;翻阅《计算机组成原理教程》可以发现，书中有描述到算术左移和逻辑左移。也就是说，左移也分带符号左移和无符号左移。经测试，javascript中的左移运算符&lt;&lt;一般不会改变符号位，意味着它是算术左移（其实对比&lt;&lt;和&gt;&gt;也能知道，&lt;&lt;是带符号左移）。 但是左移也要注意溢出的情况，比如： 11 &lt;&lt; 31; // -2147483648 那么为什么javascript中却没有逻辑左移呢？我找了一些资料，比如es5规范和注解，还有一些javascript的书籍，都没有找到解释。所以这里也没有一个权威的答案（如果有大佬知道的话，请不吝赐教）。 我个人的想法是，应该是要回到移位运算的本质。 二进制表示的机器数在相对于小数点作n位左移或右移时，其实质就是该数乘以或除以2n（n=1,2, …, n）。 而在左移过程中，如果把符号位都丢了，就失去了乘以2n的意义了。所以不只是javascript，其他编程语言如java等也没有逻辑左移运算符。 最后不得不说，大学课程真的很重要。如果一直都保持对计算机基础课程的关注，相信理解这些编程语言背后的本质会变得轻松很多。","link":"/千万别小看这些运算符背后的逻辑.html"},{"title":"即将是史上最全的meta大全","text":"本文的目的是搜集当前主流的meta配置，方便开发者快速开发调试。在这里不会做各种meta的深入分析，只是简单的介绍，让大家知道有这个东西。 meta简述 meta用于描述 HTML 文档的元数据。通常用于指定网页的描述，关键词，作者及其他元数据。 元数据可以被使用浏览器（如何显示内容或加载页面），搜索引擎（关键词），或其他 Web 服务调用。 meta从一定程度上影响seo。 meta支持哪些属性 属性 值 描述 charset character_set 定义文档的字符编码。 content text 定义与 http-equiv 或 name 属性相关的元信息。 http-equiv content-typedefault-stylerefresh 把 content 属性关联到 HTTP 头部。 name application-nameauthordescriptiongeneratorkeywords 把 content 属性关联到一个名称。 scheme format/URI HTML5不支持。 定义用于翻译 content 属性值的格式。 http-equivmeta标签上的http-equiv属性与http头部信息相关，而且是响应头，因为html本质上是通过服务器响应得到的。http-equiv用于伪装 HTTP 响应头部信息。那么http-equiv有哪些类型呢？让我们一起看下。 值 描述 cache-control 控制文档的缓存机制。允许的值如下：public：所有内容都将被缓存(客户端和代理服务器都可缓存)private：内容只缓存到私有缓存中(仅客户端可以缓存，代理服务器不可缓存)no-cache：不缓存，前提是通过服务器的缓存验证机制，如过期，内容改变等校验规则no-store：所有内容都不会被缓存到缓存或 Internet 临时文件中（设置了貌似无效，还是说不会出现在响应头吗？哪位大神可以解释下） content-language 响应体的语言。如zh-CN, en-US等（设置了貌似无效） content-type 返回内容的MIME类型 date 原始服务器消息发出的时间，GMT时间格式 expires 响应过期的日期和时间，GMT时间格式&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 30 Dec 2011 12:00:00 GMT&quot;&gt;（设置了貌似无效） last-modified 请求资源的最后修改时间，GMT时间格式（设置了貌似无效） location 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源（设置了貌似无效） refresh 定义间隔多久后刷新页面。单位是秒。 set-cookie 创建一个 cookie ，包含 cookie 名，cookie 值，过期时间。（设置了貌似无效） window-target 用来防止别人在框架里调用自己的页面。&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt;（设置了貌似无效） Pragma 向后兼容只支持 HTTP/1.0 协议的缓存服务器，那时候 HTTP/1.1 协议中的 Cache-Control 还没有出来。&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;（设置了貌似无效） 注意：以上都是在chrome浏览器最新版本， vue dev环境下测试的，不代表所有浏览器和服务器表现。 常见meta 指定字符编码 1&lt;meta charset=\"UTF-8\"&gt; IE杀手，推荐所有前端工程师采用，让我们干掉IE的市场份额。 1234567891011&lt;!-- renderer适用于国产双内核浏览器 --&gt;&lt;!-- 使用Blink（Webkit） --&gt;&lt;meta name=\"renderer\" content=\"webkit\"&gt;&lt;!-- IE兼容模式，使用ie低版本兼容 --&gt;&lt;meta name=\"renderer\" content=\"ie-comp\"&gt;&lt;!-- IE标准模式，使用ie高版本兼容 --&gt;&lt;meta name=\"renderer\" content=\"ie-stand\"&gt;&lt;!-- force-rendering适用于其他双内核浏览器 --&gt;&lt;meta name=\"force-rendering\" content=\"webkit\"&gt;&lt;!-- 强化对IE的兼容性，强制IE使用最新版标准模式渲染或者使用Chrome Frame渲染 --&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; viewport常见设置，一般适用于移动端。视口宽度设为理想宽度，禁止缩放。 1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"/&gt; meta三剑客 123&lt;meta name=\"description\" content=\"Tusi博客,专注大前端技术架构与分享,关注用户体验\"&gt;&lt;meta name=\"keyword\" content=\"Tusi博客,web前端,nodejs全栈,响应式,用户体验\"&gt;&lt;meta name=\"author\" content=\"Tusi\"&gt; UC浏览器私有meta 12345678910111213141516&lt;!-- 横屏/竖屏 --&gt;&lt;meta name=\"screen-orientation\" content=\"landscape|portrait\"&gt;&lt;!-- 全屏 --&gt;&lt;meta name=\"full-screen\" content=\"yes\"&gt;&lt;!-- 缩放不出滚动条 --&gt;&lt;meta name=\"viewport\" content=\"uc-fitscreen=yes|no\"&gt;&lt;!-- 排版，fitscreen简化页面，适合阅读省流量，standard模式和标准浏览器一致 --&gt;&lt;meta name=\"layoutmode\" content=\"fitscreen|standard\" &lt;!-- 夜间模式的启用和禁用 --&gt;&lt;meta name=\"nightmode\" content=\"enable|disable\"/&gt;&lt;!-- 强制图片显示 --&gt;&lt;meta name=\"imagemode\" content=\"force\"/&gt;&lt;!-- 强制图片显示，只作用于单图 --&gt;&lt;img src=\"...\" show=\"force\"&gt;&lt;!-- 应用模式,默认全屏，禁止长按菜单，禁止手势，标准排版，以及强制图片显示。 --&gt;&lt;meta name=\"browsermode\" content=\"application\"&gt; QQ浏览器X5内核私有meta（现在微信内置浏览器的内核也是X5哦） 123456&lt;!-- 横屏/竖屏 --&gt;&lt;meta name=\"x5-orientation\" content=\"landscape|portrait\"&gt;&lt;!-- 全屏 --&gt;&lt;meta name=\"x5-fullscreen\" content=\"true\"&gt;&lt;!-- 应用模式 --&gt;&lt;meta name=\"x5-page-mode\" content=\"app\"&gt; 苹果机适配 12345678&lt;!-- \"添加到主屏幕“后，全屏显示 --&gt;&lt;meta name=\"apple-touch-fullscreen\" content=\"yes\"&gt;&lt;!-- 隐藏菜单栏和状态栏，类似于应用模式 --&gt;&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes|no\"&gt;&lt;!-- 设置状态栏颜色，貌似只有default白色，black黑色，black-translucent灰色半透明 --&gt;&lt;meta name=”apple-mobile-web-app-status-bar-style” content=black”&gt;&lt;!-- 取消电话号码识别，防止误触拨号 --&gt;&lt;meta name=\"format-detection\" content=\"telephone=no\"&gt; 其他优化和适配手段 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name=\"HandheldFriendly\" content=\"true\"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name=\"MobileOptimized\" content=\"320\"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt;&lt;!-- robots 用来告诉搜索机器人哪些页面需要被检索 --&gt;&lt;!-- index 搜索引擎抓取这个页面 --&gt;&lt;!-- noindex 搜索引擎不抓取这个页面 --&gt;&lt;!-- follow 抓取外链 --&gt;&lt;!-- nofollow 不抓取外链 --&gt;&lt;meta name=\"robots\" content=\"index,follow\"&gt;&lt;meta name=\"robots\" content=\"index,nofollow\"&gt;&lt;meta name=\"robots\" content=\"noindex,follow\"&gt;&lt;meta name=\"robots\" content=\"noindex,nofollow\"&gt;&lt;!-- referrer 控制http请求头的referer，暂时没想到什么实际应用场景 --&gt;&lt;!-- no-referrer 不发referer --&gt;&lt;!-- origin 只发送origin部分 --&gt;&lt;!-- no-referrer-when-downgrade 默认值，当目的地是先验安全的(https-&gt;https)则发送origin作为 referrer，但是当目的地是较不安全的(https-&gt;http)时则不发送referrer --&gt;。&lt;!-- origin-when-crossorigin 在同源请求下，发送完整的URL(不含查询参数)，其他情况下则仅发送当前文档的origin --&gt;&lt;!-- unsafe-URL 在同源请求下，发送完整的URL(不含查询参数) --&gt;origin-when-crossorigin&lt;meta name=\"referrer\" content=\"no-referrer\"&gt;&lt;!-- og: Open Graph Protocol，一种友好的配置，让自己的网站在社交网络分享中更得心应手，更多的配置可以去自行搜索 --&gt;&lt;!-- og:type 告诉SNS，我这是一个什么类型的网站 --&gt;&lt;meta property=”og:type” content=”article”/&gt;&lt;!-- og:title 告诉SNS，分享时告诉用户我这个网站的标题是什么，别自己瞎搞个标题 --&gt;&lt;meta property=”og:title” content=”Tusi博客”/&gt;&lt;meta property=”og:url” content=”https://blog.wbjiang.cn”/&gt;&lt;!-- og:image 缩略图 --&gt;&lt;meta property=”og:image” content=”/static/imgs/thumbnail.png”/&gt;&lt;meta property=”og:description” content=”专注于大前端技术架构与分享，关注用户体验”/&gt; 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/即将是史上最全的meta大全.html"},{"title":"发布一个简单的npm包","text":"本文简单地记录了发布一个简单npm包的过程，以便后续参考使用。 初始化npm init通过npm init创建一个package.json文件 12345678910111213141516171819202122232425262728293031323334353637D:\\robin\\lib\\weapp-utils&gt;npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt;` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.package name: (weapp-utils)version: (1.0.0)description: some foundmental utils for weappentry point: (lib/index.js)test command:git repository:keywords: weapp,utilsauthor: tusi666license: (ISC) MITAbout to write to D:\\robin\\lib\\weapp-utils\\package.json:{ &quot;name&quot;: &quot;weapp-utils&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;some foundmental utils for weapp&quot;, &quot;main&quot;: &quot;lib/index.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; }, &quot;keywords&quot;: [ &quot;weapp&quot;, &quot;utils&quot; ], &quot;author&quot;: &quot;tusi666&quot;, &quot;license&quot;: &quot;MIT&quot;} 其中main字段是入口文件 写好README一个完备的README文件是必要的，以便别人了解你的包是做什么用途。 确认registry一般我们开发时会修改npm registry为https://registry.npm.taobao.org。 但是发布npm包时，我们需要将其改回来，不然是会报错的。 1npm config set registry http://registry.npmjs.org/ npm注册账号打开npm官网，开始注册账号。 ps：记得要验证邮箱哦！ 添加npm账户使用npm adduser添加账户，别名npm login 12345D:\\robin\\lib\\weapp-utils&gt;npm adduserUsername: tusi666Password:Email: (this IS public) cumtrobin@163.comLogged in as tusi666 on https://registry.npm.taobao.org/. 添加github仓库在package.json添加配置项，不加也没事，看自己需求。 1234\"repository\": { \"type\": \"git\", \"url\": \"https://github.com/xxx/zqh_test2.git\"} 发布1npm publish 如果发布时报这样的错， 123The operation was rejected by your operating system.npm ERR! It's possible that the file was already in use (by a text editor or antivirus),npm ERR! or that you lack permissions to access it. 建议还是检查下registry，或者npm adduser是不是成功了。 发布成功，会有这样的提示， 1234567891011121314151617npm noticenpm notice package: weapp-utils@1.0.0npm notice === Tarball Contents ===npm notice 397B package.jsonnpm notice 1.1kB LICENSEnpm notice 2.7kB README.mdnpm notice 12.9kB lib/index.jsnpm notice === Tarball Details ===npm notice name: weapp-utilsnpm notice version: 1.0.0npm notice package size: 5.1 kBnpm notice unpacked size: 17.1 kBnpm notice shasum: a7f2f428d9334dd1dd749d2a492dbc4df7195d0dnpm notice integrity: sha512-Cp8jPhOMq73y6[...]bfofe7X+4cLeg==npm notice total files: 4npm notice+ weapp-utils@1.0.0 上npm搜索weapp-utils，发现有了！ 调用发布成功了，也要验证下，是否可正常使用。 123import { merge } from \"weapp-utils\"let mergedOptions = merge(DEFAULT_OPTIONS, options) 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/发布一个简单的npm包.html"},{"title":"可能是最详细的UMD模块入门指南","text":"学习UMD介绍这个仓库记录了一些关于javascript UMD模块规范的demo，对我学习UMD规范有了很大帮助，希望也能帮助到你。 回顾之前也写了几篇关于javascript模块的博客，链接如下： 回头再看JS模块化编程 回头再看JS模块化编程之AMD sea.js的同步魔法 近几天准备总结一下javascript模块的知识点，所以建了这个Git仓库，如果能帮助到您，麻烦点个star哦，非常感谢！ 这篇博客主要说下自己关于UMD的一点认知和思考，从实现一个简单的UMD模块，再到实现一个有依赖关系的UMD模块，整个过程加深了我对UMD模块的理解。 什么是UMD所谓UMD (Universal Module Definition)，就是一种javascript通用模块定义规范，让你的模块能在javascript所有运行环境中发挥作用。 简单UMD模块的实现实现一个UMD模块，就要考虑现有的主流javascript模块规范了，如CommonJS, AMD, CMD等。那么如何才能同时满足这几种规范呢？ 首先要想到，模块最终是要导出一个对象，函数，或者变量。 而不同的模块规范，关于模块导出这部分的定义是完全不一样的。 因此，我们需要一种过渡机制。 首先，我们需要一个factory，也就是工厂函数，它只负责返回你需要导出的内容（对象，函数，变量等）。 我们从导出一个简单的对象开始。 12345function factory() { return { name: '我是一个umd模块' }} 全局对象挂载属性假设不考虑CommonJS, AMD, CMD，仅仅将这个模块作为全局对象的一个属性应该怎么写呢？ 12345678(function(root, factory) { console.log('没有模块环境，直接挂载在全局对象上') root.umdModule = factory();}(this, function() { return { name: '我是一个umd模块' }})) 我们把factory写成一个匿名函数，利用IIFE（立即执行函数）去执行工厂函数，返回的对象赋值给root.umdModule，这里的root就是指向全局对象this，其值可能是window或者global，视运行环境而定。 打开效果页面链接（要看源码的话，点开Git仓库），观察Network的文件加载顺序，可以看到，原则就是依赖先行。 再进一步，兼容AMD规范要兼容AMD也简单，判断一下环境，是否满足AMD规范。如果满足，则使用require.js提供的define函数定义模块。 1234567891011121314(function(root, factory) { if (typeof define === 'function' &amp;&amp; define.amd) { // 如果环境中有define函数，并且define函数具备amd属性，则可以判断当前环境满足AMD规范 console.log('是AMD模块规范，如require.js') define(factory) } else { console.log('没有模块环境，直接挂载在全局对象上') root.umdModule = factory(); }}(this, function() { return { name: '我是一个umd模块' }})) 打开效果页面链接，可以看到，原则是调用者先加载，所依赖的模块后加载。 起飞，直接UMD同理，接着判断当前环境是否满足CommonJS或CMD规范，分别使用相应的模块定义方法进行模块定义。 123456789101112131415161718192021(function(root, factory) { if (typeof module === 'object' &amp;&amp; typeof module.exports === 'object') { console.log('是commonjs模块规范，nodejs环境') module.exports = factory(); } else if (typeof define === 'function' &amp;&amp; define.amd) { console.log('是AMD模块规范，如require.js') define(factory()) } else if (typeof define === 'function' &amp;&amp; define.cmd) { console.log('是CMD模块规范，如sea.js') define(function(require, exports, module) { module.exports = factory() }) } else { console.log('没有模块环境，直接挂载在全局对象上') root.umdModule = factory(); }}(this, function() { return { name: '我是一个umd模块' }})) 最终，使用require.js, sea.js, nodejs或全局对象挂载属性等方式都能完美地使用umd-module.js这个模块，实现了大一统。 给个sea.js调用UMD的效果页面链接，sea.js调用UMD模块 而nodejs调用UMD模块需要执行node命令， 1node umd-simple-used-by-nodejs 效果如下： 有依赖关系的UMD模块当然，我们不能止步于此，模块会被调用，当然也会调用其他模块。因此我们还需要实现一个有依赖关系的UMD模块，来验证UMD规范的可行性。 全局对象挂载属性这个简单，在html中你的模块前引入所依赖的模块即可。umd-module-depended和umd-module都是UMD模块，后者依赖前者。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Test UMD&lt;/title&gt; &lt;!-- 依赖放前面 --&gt; &lt;script src=\"assets/js/umd-dep/umd-module-depended.js\"&gt;&lt;/script&gt; &lt;script src=\"assets/js/umd-dep/umd-module.js\"&gt;&lt;/script&gt; &lt;script src=\"assets/js/umd-dep/umd-global.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;测试UMD模块&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; &lt;p id=\"content\"&gt;&lt;/p&gt; &lt;p id=\"content2\"&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 点开效果页面链接，看得更清楚明白！ 兼容AMD规范我们先在入口文件umd-main-requirejs.js中，定义好模块路径，方便调用。 1234567require.config({ baseUrl: \"./assets/js/umd-dep/\", paths: { umd: \"umd-module\", depModule: \"umd-module-depended\" }}); 被依赖的模块umd-module-depended，只需要简单实现UMD规范即可。 而调用者umd-module，则需要做一些处理。按照require.js的规范来即可， define时，指定依赖的模块depModule，而匿名工厂函数需要在参数上接收依赖的模块depModule。 123456789101112131415(function(root, factory) { if (typeof define === 'function' &amp;&amp; define.amd) { console.log('是AMD模块规范，如require.js') define(['depModule'], factory) } else { console.log('没有模块环境，直接挂载在全局对象上') root.umdModule = factory(root.depModule); }}(this, function(depModule) { console.log('我调用了依赖模块', depModule) // ...省略了一些代码，去代码仓库看吧 return { name: '我自己是一个umd模块' }})) 打开效果页面链接，看得更清楚明白！ UMD依赖写法同理，各种规范要求你怎么写模块依赖，你就怎么写就行。 12345678910111213141516171819202122232425(function(root, factory) { if (typeof module === 'object' &amp;&amp; typeof module.exports === 'object') { console.log('是commonjs模块规范，nodejs环境') var depModule = require('./umd-module-depended') module.exports = factory(depModule); } else if (typeof define === 'function' &amp;&amp; define.amd) { console.log('是AMD模块规范，如require.js') define(['depModule'], factory) } else if (typeof define === 'function' &amp;&amp; define.cmd) { console.log('是CMD模块规范，如sea.js') define(function(require, exports, module) { var depModule = require('depModule') module.exports = factory(depModule) }) } else { console.log('没有模块环境，直接挂载在全局对象上') root.umdModule = factory(root.depModule); }}(this, function(depModule) { console.log('我调用了依赖模块', depModule) // ...省略了一些代码，去代码仓库看吧 return { name: '我自己是一个umd模块' }})) 给个sea.js调用的示例链接。 而nodejs调用也是通过命令行测试， 1node umd-dep-used-by-nodejs 效果如下： 总结以上实现了简单的UMD模块，也验证了UMD模块间存在依赖关系时的可行性。虽然本文是以简单对象导出为例，但足以作为我们深入UMD规范的起点，加油！ 最后厚着脸皮求个star，点亮我吧 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/可能是最详细的UMD模块入门指南.html"},{"title":"呼吸灯特效","text":"今天无意间发现了一个不错的特效，就是呼吸灯效果，感觉用来放在海报周围很炫酷，用在其他地方也是不错的。 原理就是before伪元素 + animation动画 + box-shadow盒子阴影。进入demo按F12查看Elements基本能知道是怎么实现了。 呼吸灯demo 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/呼吸灯特效.html"},{"title":"回头再看JS模块化编程","text":"什么是模块？我们可能要从需求上出发进行理解，当web应用的规模变得越来越大，业务变得越来越复杂时，我们需要将一些函数分门别类，在分类的基础上对函数进行封装，这就形成了模块。下面看一下js模块的一些形式。 对象模块假如我们有多个函数，想作为一个模块使用，最原始的做法就是把这几个函数全部放在一个js文件，通过文件的形式来对js进行划分模块。 12345678// my_module.jsfunction add(a, b) { return a + b;}function multiply(a, b) { return a * b;} 然而这样的做法会污染全局环境，引用这个js后，window对象就会多了两个方法。那么如何减少这种对全局环境的污染呢？想到的最简单的一个办法就是，把这几个函数都放在一个对象中，只暴露一个对象。 12345678910// my_module.jsvar MyModule = { add: function (a, b) { return a + b; }, multiply: function (a, b) { return a * b; }} IIFEIIFE（immediately invoked function expression），也就是立即执行函数表达式。假设有这样一个场景，你的模块需要定义默认参数，而你又希望这个默认参数不被外界所改变，那么使用对象模块的方式就没有办法做到了，因为这个对象已经暴露在全局环境中。那么如何能隔离作用域呢？聪明的你已经想到了函数，对的，函数可以做到。我们通过IIFE为window挂载了setColor方法。 12345678(function(global) { var default_option = { color: 'blue' } global.setColor = function(id, colorValue) { document.getElementById(id).style.color = colorValue || default_option.color }})(this) 这里的default_option就不会暴露在全局环境中，你可以尝试一下在控制台console.log(window.default_option)，得到的就是undefined。 CommonJS引用百度给出的定义 CommonJS API定义很多普通应用程序（主要指非浏览器的应用）使用的API，从而填补了这个空白。它的终极目标是提供一个类似Python，Ruby和Java标准库。 CommonJS提供的模块方案认为，一个js就是一个模块，我们经常用到的变量和函数有global，module，exports，require。global是nodejs环境的全局对象，类似与浏览器环境的window，也是根对象，任何在全局环境下定义的变量或函数都是global的属性或方法，global涉及很多东西，这里不再赘述。而module是模块对象，exports包含该模块要导出的变量或函数，require是导入模块的方法。我们首先写两个简单的js来认识它们。 12345678910// a.jsmodule.exports.add = function (a, b) { return a + b;}// b.jsvar a = require('./a.js');var result = a.add(1, 2);console.log(result); // 输出3 这是最简单的模块写法，a.js通过exports导出add函数，而b.js通过require导入a模块，便可以调用a模块的add函数。 module那么我们先来看看module这个对象。在b.js中我们console.log(module)，则会打印出模块b的信息。 可以看到，模块b的children里有模块a，说明模块b引用了模块a。我们再观察一下模块a，修改a.js的代码如下，再运行b.js 12345console.log(module)module.exports.add = function (a, b) { return a + b;} 可以看到，模块a的parent指向模块b，是因为执行的是b.js，而b.js引用了模块a。注意此时模块a的loaded属性值仍是false，因为此时模块还没加载完成。如果我们在add方法中打日志，而b.js调用a.js的add函数，则会发现此时模块a的loaded已经变成了true 从上面可以了解到，module对象下面有以下属性 id：模块id，一般默认是模块的路径 exports：模块对外导出对象，包含了对外导出的函数和属性 parent：指向首次加载本模块的模块（为什么说是首次呢？假设b.js引用了模块a，c.js引用了模块a和模块b，此时运行c.js，模块a的parent指向的是模块b） filename：模块的绝对路径 loaded：模块是否已经加载完成 children：当前模块引用的其他模块 paths：对于加载模块时没给出./ ../ /…/时，加载模块的搜索路径。依次从第一个路径搜索到最后一个路径。 exports接下来我们说说exports，在这里要了解module.exports与exports的区别。Node.js 在初始化时执行了 exports = module.exports , 所以 exports 与 module.exports 指向了相同的内存。当不改变两者的指向时，两者还是全等的。因此，我前面的写法 exports.add 只是给 exports 指向的对象上添加了add方法，并未改变其指向。这之后exports与module.exports仍是一致的。到这里大家应该明白了什么情况两者会不相等了。 123456// 如果采用这种改变指向的写法，那么之后exports与module.exports就不一样了。module.exports = { add: function (a, b) { return a + b }} 通过exports导出的函数和属性可以被其他模块调用，这一点想必大家都清楚了。 require这里先说一下模块的分类，NodeJS中模块分为核心模块和文件模块。核心模块是被编译成二进制代码，引用的时候只需require表示符即可，如require(‘fs’)，不需要加路径的。而引用文件模块时需要加上路径，表示对文件的引用。假如你加载一个自定义的test.js模块时，没有指定路径，那么它会首先从当前目录的node_modules子目录下寻找test.js，如果没有，则查找上一级目录的node_modules子目录，一直查到盘符的根目录为止。也就是前面提到的module.paths的查找顺序。 说到这里，我们再来回顾一下我们在开发时，npm install 安装的一些依赖包。它们的package.json一般都包含了main字段，用来标识入口js文件。 如果没有指定main字段，那么nodejs会默认去加载index.js或者index.node文件。例如： 看到这里，是不是突然有点懂了node_modules哪些依赖包的写法了。好的，接着往下看。 我们在c.js中打出日志，观察require方法的结构。 1console.log(require) 可以知道，require函数包含了以下属性和方法。 require.resolve()：将模块名解析，得到该模块的绝对路径 require.main：指向当前执行的主模块 require.cache：指向所有缓存的模块 require.extensions：根据文件的后缀名，调用不同的执行函数 我们再细致看一下，主要看看resolve和extensions 123456789101112var a = require('./a.js');var b = require('./b.js');console.log('resolve测试')console.log(require.resolve('./a.js'))console.log('extensions测试')console.log(require.extensions['.js'].toString())console.log(require.extensions['.json'].toString())console.log(require.extensions['.node'].toString()) 得到的结果如下图所示： 缓存使用require()加载模块是有缓存的，如果要清理缓存，则需要调用delete require.cache，示例如下： 1delete require.cache[require.resolve('./json/damei_admin.json')]; 写到这里，算是对模块有一点初步的认识。接下来我们还需要了解AMD，CMD，UMD的概念。由于篇幅太长，接下来我将分篇叙述这些概念，请阅读后续系列文章！以上观点源于自己的一些理解，如有描述不对的地方，请您指正！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/回头再看JS模块化编程.html"},{"title":"回头再看JS模块化编程之AMD","text":"由于CommonJS采用适合服务器端的同步加载方式，这种方式不适合天生异步的浏览器端。在这种形势下，AMD（Asynchronous Module Definition，异步模块定义）应运而生。而require.js正是AMD规范下的产物，因此，我们可以直观地从require.js入手分析AMD。 require.js这是RequireJS官方下载链接，我本次测试使用的是2.3.5版本。 加载require.js使用RequireJS后，我们不用在html中手动添加蛮蛮多的script标签了，通过模块依赖的方式，RequireJS会自动创建script标签，也使得模块间依赖关系的管理变得更加方便。首先，需要在html中引入require.js，并通过data-main属性指定入口js文件 1&lt;script src=\"./js/amd/require-2.3.5.js\" data-main=\"./js/amd/main\" defer async&gt;&lt;/script&gt; 定义模块我们先不关注main.js的实现，先来看看在RequireJS中怎么定义模块。 12// name和deps都是非必选的参数，而callback可以是一个对象，或者是具有返回值的函数define([name], [deps], callback) 简单模块如果一个模块只包含一些键值对，没有任何依赖，则在define()中定义这些键值对就好了 12345678// 定义模块时，推荐不显示传入name参数，这样方便优化工具去生成。define({ name: 'simpleModule', version: '1.0.0', add: function(a, b) { return a + b; }}) 函数式模块跟上篇文章说到的IIFE是一样的道理，加入我们需要对模块做一些初始化的工作，那么就不能使用简单模块的定义方式了。函数式模块的定义方式如下： 1234567891011define(function() { // ... // 这之前可以做一些初始化的变量赋值等等... function add(a, b) { return a + b } // 最终return一个对象，暴露给调用者使用 return { add: add }}) 存在依赖的模块假设你要写一个依赖jquery的模块，那么你需要在define方法中声明依赖。 12345678define(['jquery'], function($) { function setColor(select, color) { $(select).css('color', color) } return { setColor: setColor }}) 在官网上还发现一种类似sea.js的依赖写法。 123456789define(function(require, exports, module) { var $ = require('jquery') function setColor(select, color) { $(select).css('color', color) } return { setColor: setColor }}) 我的猜想：这种写法的代码在运行时，当前模块不知道所依赖的外部模块有哪些，需要遍历所有的require关键字，找出后面的依赖。这显然是一种更牺牲性能的方法。虽然可以用var $ = require('jquery')这种“同步”的形式写代码，但终究不是一个最优的选择。 使用模块在使用模块之前，我们可以通过require.config先配置每个js的路径，方便后续代码的书写。 123456789// main.js的顶部，我定义了四个模块的pathrequire.config({ paths: { simple: './simple', jquery: '../jquery-3.3.1', funcModule: './func-module', depModule: './dep-module', }}); RequireJS调用模块的方式如下 12// callback参数列表的顺序与deps中模块的顺序一致require(deps, callback) 123456789101112require(['simple', 'jquery', 'funcModule', 'depModule'], function(simple, $, funcModule, depModule) { console.log(simple) console.log($) $('.word').css({ fontSize: '24px', color: 'blue' }) var result = funcModule.add(1,2) console.log(result) depModule.setColor('.word', 'yellow')}) 到这里我们已经掌握了RequireJS的最基本的用法了。 配置项除了paths外，RequireJS还支持很多的配置项，便于我们快速开发。完整配置可以参考RequireJS 中文网 比较常用的有baseUrl，指定了js文件的查找基路径；还有shim，用来作为垫片支持那些不符合AMD规范的js。 baseUrl经过本人测试，baseUrl的路径参考了引用require.js的入口html文件。我们看一下两种不同的文件路径配置就明白了。 首先看第一种 接着我们看一下第二种，我把requirejs.html移动到了一个html文件夹内。 这两种不同的文件路径下，baseUrl都必须参考requirejs.html的路径，否则就会发生引用404报错了。 shim有些早期的js库并不支持AMD写法，所以需要在requirejs中配置shim才可以使用它们，shim写法如下： 12345678910require.config({ shim: { &quot;underscore&quot; : { exports : &quot;_&quot;; }, &quot;jquery&quot; : { exports : &quot;$&quot;; } }}) 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/回头再看JS模块化编程之AMD.html"},{"title":"回文数的两种解法","text":"我最近也开始看看leetcode了，有时间也刷个一两题，不得不说，现在这个行业对前端工程师的要求是越来越高了，除了写业务代码，还要懂框架原理，工程化，服务端，服务器部署，就连算法也逃不了。 其实也没办法抱怨，现在高校计算机相关专业出来的毕业生中，越来越大比例的同学会选择从事前端开发，这些同学在学校或多或少都接触过数据结构和算法（鸭梨山大）。除此之外，前端开发过程中确实也有越来越多的场景会涉及到算法，简单的可能有数组转二叉树，各种排序算法，甚至有贪心算法，动态规划等…… 为了让自己学习(保持)更多知识(竞争力)，我想还是冲击下leetcode青铜五吧。 回文数打开leetcode第一天，系统给我推荐了一题回文数。 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 看了下题干，我感觉还挺简单的啊，不愧是简单难度。 字符串反转我假装思考了一会儿，心想，好像只要把数字转为字符串，然后再反转一波就基本搞定了啊。 对了，还要先判断一下负数的情况，显得我考虑比较周全。 123456789101112131415/** * @param {number} x * @return {boolean} */var isPalindrome = function(x) { if (x &lt; 0) { return false; } else { var strNum = String(x); if (strNum.split('').reverse().join('') === strNum) { return true; } return false; }}; split('')用于将字符串各个字符分割出来得到一个字符串数组，而reverse()是数组反转方法，join('')则是将数组重新拼接为字符串。这样就实现了一个基于字符串反转得到的回文数解决方法。 不出所料，测试用例执行通过。 数字反转正当我准备提交解题代码时，我发现题目中还有这么一句话： 进阶: 你能不将整数转为字符串来解决这个问题吗？ 果然，问题没有这么简单，还剩最后一点倔强的我，必须要试试。 我的思路是利用取模运算符%依次获得最后一位数字，这样就能把数字反转过来得到一个数组。最后求值的时候只需要遍历数组，乘以对应的10次幂即可。 123456789101112131415161718/** * @param {number} x * @return {boolean} */var isPalindrome = function(x) { var reverseNumList = []; var tempNum = x; while(tempNum &gt; 0) { var lastNum = tempNum % 10; reverseNumList.push(lastNum); tempNum = Math.floor(tempNum / 10); } var reversedValue = 0; for (var i = 0, len = reverseNumList.length; i &lt; len; i++) { reversedValue += reverseNumList[i] * Math.pow(10, len - 1 - i) } return reversedValue === x;}; 最后leetcode并没有限制你的解法，不管性能优劣如何，自己能把思路用代码写出来就是成功的。最后可以再看看一些排名靠前的解法，你也许能打开新世界的大门（当然，也许你会自暴自弃，哈哈…）。","link":"/回文数的两种解法.html"},{"title":"在Linux和Windows系统中输出目录结构","text":"一直以来就想在写文章时，能以文本形式（而不是截图）附上项目的目录结构，今天终于知道怎么操作了，在这分享一下。 Linux首先说下Linux上输出目录结构的方法。 yum安装tree需要支持tree命令，首先是要安装tree包的。 1yum -y install tree 然后在你的项目目录下执行tree命令即可 还可以输出带颜色的结构 1tree -C Windows不需要特意安装什么，直接输入命令： 1tree /f 更多参数请参考Windows Commands / tree 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/在Linux和Windows系统中输出目录结构.html"},{"title":"块级元素和行内元素","text":"最近给自己定了一个小目标，一周温习一个基础知识点，并输出一篇手记。看自己是否能坚持下去。^_^ 块级元素块级元素占据独立的空间，有以下特点： 独占一行或多行 宽度，高度，内外边距可以设置，且有效 宽度默认是父容器的100% 可以作为其他块级元素和行内元素的父容器（文本类块级元素不建议作为其他块级元素的容器，如p, h1~h6） 常见的块级元素有：div, h1~h6, hgroup, p, table, form, ul, ol, hr, header, main, footer, aside, article, section, video, audio, canvas, pre, option 行内元素行内元素不占据独立空间，依靠自身内容撑开宽高，与同属一个父容器的其他行内元素在同一行上依次排列，根据white-space属性值来决定是否换行。它们具备以下特征： 不独占一行，但内容过长时会根据white-space控制换行。 宽度，高度的设置是无效的。内外边距只能设置左右方向（设置padding-top, padding-bottom, margin-top, margin-bottom是无效的）。但是有一点要注意，padding-top和padding-bottom对自身有表现效果，但是不影响周围元素的布局，看图说话： 宽度由自身内容决定。 行内元素不建议作为块级元素的容器（a标签例外） 常见的行内元素有：span, i, code, strong, a, br, sub, sup, label 对于不确定的元素，可以设置width来测试下，如果width不生效，说明是行内元素啦。 行内块级元素行内块级元素也不会独占一行，但是可设置宽高，内外边距等。 常见的行内块级元素有：input， button, img, select, textarea CSS显示转换display: block;让元素表现为块级元素 display: inline;让元素表现为行内元素 display: inline-block;让元素表现为行内块级元素 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/块级元素和行内元素.html"},{"title":"如何判断IE OCX插件正常安装？","text":"项目中用到了一个第三方的ie ocx控件，而经常遇到客户和测试小伙伴反馈相关功能无法正常使用，也没有友好提示。考虑到这个问题，必须要有一个ie ocx控件的检查机制。 检查原理创建ActiveXObject对象去检查ocx控件 1let newObj = new ActiveXObject(servername, typename[, location]) 参数问题看起来很简单的，但是用起来我懵逼了，应用程序对象名称servername这个参数怎么填呢？ 插件供应商只提供了控件安装包，示例程序，clsid 1&lt;object id=\"NetVideo\" classid=\"clsid:27E1A157-6A29-48AE-86C2-14591D90B4D4\"&gt;&lt;/object&gt; 于是我想应该可以从clsid入手研究。 什么是clsid class identifier（类标识符）也称为CLASSID或CLSID，是与某一个类对象相联系的唯一标记(UUID)。一个准备创建多个对象的类对象应将其CLSID注册到系统注册数据库的任务表中，以使客户能够定位并装载与该对象有关的可执行代码。 以上摘自百度百科，可以看到clsid跟uuid是类似的原理，用来进行插件的唯一标识。 根据clsid怎么查到servername在MDN上搜索ActiveXObject词条，可以看到这么一句： 您可以在HKEY_CLASSES_ROOT注册注册表项中识别主机PC上的servername.typename的值。 哦，可以看到是从注册表中去查的。于是我运行regedit打开注册表查看，虽然知道是在HKEY_CLASSES_ROOT目录下，但是这也太多了吧，怎么找得到？ 当然还是要靠搜索功能，于是我根据clsid的值27E1A157-6A29-48AE-86C2-14591D90B4D4进行查找 搜索时间有点长，但是最终还是查到了，位置如下： 计算机\\HKEY_CLASSES_ROOT\\SDS_CMSCtrl.SDS_CMSCtrlCtrl.1 于是我猜想，servername应该就是SDS_CMSCtrl.SDS_CMSCtrlCtrl.1。经测试，果不其然。检查代码如下： 123456try { const ocx = new ActiveXObject('SDS_CMSCtrl.SDS_CMSCtrlCtrl.1') console.log(ocx)} catch (error) { this.$alert('您还未安装视频插件！', '提示')} 这样一来，如果用户没有安装插件，马上能够得到提示，perfect！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/如何判断IE OCX插件正常安装？.html"},{"title":"妙用数组fill处理每日温度","text":"在老家过完粽子节，回到工作地又可以一脸开(无)心(奈)地刷leetcode了。今天的题目是每日温度，给定一个温度数组，求解的目标是算出某一天需要等待几天才能超过该天的温度。 每日温度请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用0来代替。 例如，给定一个列表temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是[1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温列表长度的范围是[1, 30000]。每个气温的值的均为华氏度，都是在[30, 100]范围内的整数。 两层循环判断整体思路是，利用两层for循环，判断每个温度之后是否有更高的温度。要注意，第一层for循环到最后一个元素时，是不会进入第二层for循环的。此时直接通过push方法把0塞入数组。 1234567891011121314151617181920212223/** * @param {number[]} T * @return {number[]} */var dailyTemperatures = function(T) { var result = []; for(var i = 0, len = T.length; i &lt; len; i++) { if (i == len - 1) { result.push(0); } else { var currValue = T[i]; var waitDay = 0; inner: for (var j = i + 1, len = T.length; j &lt; len; j++) { if (T[j] &gt; currValue) { waitDay = j - i; break inner; } } result.push(waitDay) } } return result;}; 执行结果是： 内存占用45.8M，超过100%用户？ 执行时间924ms，竟然只超过了20.19%的用户。 考虑边界考虑温度的边界，如果当前温度是100，那肯定就不用进第二层循环了。 123456789101112131415161718192021var dailyTemperatures = function(T) { var result = []; for(var i = 0, len = T.length; i &lt; len; i++) { var currValue = T[i]; if (currValue === 100) { result.push(0); } else if (i == len - 1) { result.push(0); } else { var waitDay = 0; inner: for (var j = i + 1, len = T.length; j &lt; len; j++) { if (T[j] &gt; currValue) { waitDay = j - i; break inner; } } result.push(waitDay) } } return result;}; new Array &amp; fill提交解法后，我看了一下第一名的解法，还是学到了一点东西。 主要有两个地方不太一样： 一个是使用new Array预先声明好数组空间，在大数组时性能表现更佳； 第二个是使用了Array.prototype.fill预填充0，所以也不需要判断是否需要进第二层循环。 123456789101112var dailyTemperatures = function(T) { const res = new Array(T.length).fill(0); for (let i = 0; i &lt; T.length; i++) { for (let j = i + 1; j &lt; T.length; j++) { if (T[j] &gt; T[i]) { res[i] = j - i; break; } } } return res;}; 特意对比了一下fill和push的执行时间，原来fill的性能挺好的。 123456789101112console.time('fill计时');var a = new Array(100).fill(0);console.timeEnd('fill计时');// fill计时: 0.009033203125msconsole.time('push计时');a.push(0);a.push(0);a.push(0);// 此处省略97行a.push(0);特意没有用for循环，毕竟循环也是要开销的。console.timeEnd('push计时');// push计时: 0.02001953125ms 如果给数组初始化1000个值为0的元素呢？不得不说，数据量越大，fill性能越好。 12// fill计时: 0.01220703125ms// push计时: 0.136962890625ms 再看了看fill的兼容性，我只想说，在LeetCode中别怕，给我用最新的特性，IE不兼容的fill都可以用上。 最后再把第一名的代码放上去提交一遍，尼玛，啪啪打脸。 同样的代码人家执行耗时132ms，我这里提交就是执行耗时872ms。我只想问，LeetCode执行用时是怎么算出来的？ 不过有一说一，第一名的解法确实性能更好，写法也很优雅，值得学习。","link":"/妙用数组fill处理每日温度.html"},{"title":"实用网站记录（持续更新中...）","text":"有时候突然想找一个网站的网址，怎么也想不起来，也找不到，所以今天在这里记录一下一些常用的实用网站，保持持续更新，方便后续使用。 兼容性查询网站https://www.caniuse.com/ 在线cubic-bezier(贝塞尔曲线)调测网站http://cubic-bezier.com RGB颜色值与十六进制颜色码转换工具http://www.sioe.cn/yingyong/yanse-rgb-16/ 在线配色网站https://www.canva.com/colors MySQL安装教程https://jingyan.baidu.com/article/e3c78d64412ae83c4c85f5fd.html MySQL菜鸟教程http://www.runoob.com/mysql/mysql-tutorial.html GIT中文教程https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 SVG参考手册https://developer.mozilla.org/zh-CN/docs/Web/SVG/Element SVG在线编辑器http://www.86y.org/demo/svg/ HTTP Content-Type 查询http://tool.oschina.net/commons/ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/实用网站记录（持续更新中...）.html"},{"title":"小白的Linux入门篇","text":"什么是linux?大部分人应该脑海里有linux这个词的印象，但是具体是什么好像又说不出来。如果最开始你要问我，什么是linux？我会回答，linux，跟windows差不多啊，都是操作系统。其实这样说没错，Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。但是作为一名开发者而言，我们需要了解更多的信息。有两个概念需要我们来梳理一下。 linux内核版本Linux内核版本就是linux的核心版本，Linux内核的主要模块（或组件）分以下几个部分：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信，以及系统的初始化（引导）、系统调用等。其实，比较简单的说法就是，linux内核版本是最官方、最核心的版本。内核版本由官网进行发布。 linux发行版本一些组织或企业，基于linux内核做了一些上层应用和工具的定制开发，形成了各种各样的发行版本。现在比较流行的发行版本主要分为两大派系redhat和debian。redhat, CentOS, fedora, SuSE, gentoo是redhat分支，debian, ubuntu等是debian分支。比较公认的说法是，服务器领域尽量选Redhat，非服务器领域还是要选debian分支如ubuntu。服务器的要求是安全，稳定，因此越少的图形界面相对来说是更优的选择。 linux应用领域服务器领域linux具备良好的稳定性，可靠的安全性，完善的网络功能，跨平台的硬件支持，多用户多任务管理，丰富的生态支持，是服务器领域的不二之选。 嵌入式领域Linux在嵌入式领域可谓是大展身手，如移动设备、嵌入式板卡、物联网、智能家居、消费级设备、无人机、机器人、可穿戴设备和汽车等，都有涉及到linux系统。 linux虚拟机安装看到这一点，很多人会感到疑惑，为什么不直接装linux系统，却要装虚拟机？虚拟机可以让你在windows下使用linux环境，非常适合新手学习使用。VMware是一款功能强大的桌面虚拟计算机软件，提供用户可在桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的解决方案。在VMware的版本选择上，推荐使用VMware8，因为作为初学来说，太高的版本我们用不上，还可能会让自己的电脑变得很卡。在百度搜索，就可以下载到VMware8。 安装完成可以选择汉化工具，做一下汉化，便于我们使用。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/小白的Linux入门篇.html"},{"title":"干货！Git 如何使用多个托管平台管理代码","text":"考虑到github不能免费创建私有仓库原因，最近开始在使用码云托管项目，这样避免了连接数据库的用户密码等信息直接暴露在公共仓库中。今天突然想到一个点，就是能不能同时把代码推送到github和码云上呢？答案是可以的。 首先，我们在开始一个项目时，在本地写了一些代码，需要同时托管到github和码云（gitee）上。这个时候我们要怎么办呢？请接着看。 实现方法添加密钥对在C:\\Users\\robin.ssh目录下运行git bash 1234// 这个是给github生成的ssh-keygen -t rsa -C \"1148121254@qq.com\"// 这个是给码云生成的ssh-keygen -t rsa -C \"cumtrobin@163.com\" 生成后自行命名管理，这里不再赘述。接着把公钥分别放在github和码云上。私钥可以用config文件管理 12345678910111213# 配置github.comHost github.com HostName github.com IdentityFile C:\\\\Users\\\\robin\\\\.ssh\\\\id_rsa_github PreferredAuthentications publickey User cumtRobin# 配置gitee.comHost gitee.com HostName gitee.com IdentityFile C:\\\\Users\\\\robin\\\\.ssh\\\\id_rsa_gitee PreferredAuthentications publickey User Tusi 接着我们测试一下 12ssh -T git@github.comssh -T git@gitee.com 成功则会得到这样的反馈 创建仓库首先是在github和码云上分别创建一个仓库。这个玩过github的都知道，不细说。 接着在本地项目根目录创建git仓库 1git init 本地与remote关联要把两个remote仓库与本地git仓库关联起来，我们直接来运行 1234// 添加github的远程库git remote add origin git@github.com:cumtRobin/BlogFrontEnd.git// 添加码云的远程库git remote add gitee git@gitee.com:tusi/BlogFrontEnd.git 然后我们运行git remote查看添加的远程库列表 1234git remote// 得到以下值origingitee 说明已经添加成功，接着我们分别查看git status，会看到本地有很多文件待提交，接着git add, git commit，最后git push的时候要注意分开push 1234// push到github主分支git push origin master// push到gitee主分支git push gitee master 虽然麻烦了一点，需要push两次，但是目的是初步达成了。如果想要一次性push解决，那也不是没有办法。 一次性push为了避免引起歧义，这里先将origin，gitee的remote库删除 12git remote rm origingit remote rm gitee 重新添加remote 1git remote add all git@github.com:cumtRobin/BlogFrontEnd.git 可以看到，我其实是添加的github的远程库，只不过把它的名字叫做all。接着我们把码云上的remote库也关联起来。 1git remote set-url --add all git@gitee.com:tusi/BlogFrontEnd.git 这样操作以后，就可以运行一条push命令了 1git push all --all 有人说可以改.git/config文件实现。其实刚才上面的命令修改的就是config文件，但是本人建议，多练练命令行，这样也会加深对git的理解。这时候我们再查看一下.git/config文件。可以看到remote all下面是有两个url的。 12345678910[core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true[remote &quot;all&quot;] url = git@github.com:cumtRobin/BlogFrontEnd.git url = git@gitee.com:tusi/BlogFrontEnd.git 学会了两个托管平台的配置，那使用更多的托管平台也就不难实现了。 ps：再分享一个小技巧，由于我在生成ssh密钥时，加了passphrase，导致我每次push都要输入密码，很烦人。 其实，只要重置一下这个passphrase就可以了。 12345// 进入到.ssh目录，运行git bashssh-keygen -p// 再输入密钥名，如id_rsa_github，先输入旧密码，然后一路回车即可，多个密钥重复此操作即可。 2019-04-18 补充 git pull 的细节 因为都是从本地 push 代码到远程仓库，很久没有从远程仓库拉取代码了，今天不小心在 github 上改了仓库中的 readme 文件，导致和 gitee 不同步。使用 git pull 报错，慌的一批。 12345678910$ git pullThere is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=all/&lt;branch&gt; master 原来是要使用下面这条命令才行。 1234$ git pull all masterFrom github.com:cumtRobin/BlogFrontEnd * branch master -&gt; FETCH_HEADAlready up to date. 上面的 all 是指 remote ，即远程仓库，master 是指分支名，master 即主干分支。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/干货！Git-如何使用多个托管平台管理代码.html"},{"title":"微信小程序的摸索之路--从demo入手揭开神秘面纱","text":"微信小程序推出已久，除了普通开发版本，如今已经支持云开发版本。框架上的选择也有很多，比较火的应该属 mpvue 和 wepy 和 taro 吧。但是我还是选择先从普通开发版本和原生语言开始入手微信小程序，然后再考虑框架的事情。 项目结构 刚接触小程序的我，一看到也是有点懵逼的。但是细心看下来，发现和其他前端框架组织的项目也是大同小异的。我们且不关注项目配置文件 project.config.json 和辅助js模块 util.js，小程序基本上由App和Page两部分组成，我们暂且称这两者都为组件吧。小程序的组件基本上由四个文件组成。 wxml 对应 html，负责模板视图；wxss 对应 css，负责样式表现；js就不用说了，负责逻辑操作；json则是负责组件相关的配置。 Demo分析小程序 demo 主要包含两个页面，首页有请求用户授权的按钮，授权后点击用户头像进入日志页面，查看登录日志。 获取用户信息该 demo 获取用户信息的思路是： 首先需要检查用户是否已经对小程序进行了个人信息授权，需要调用 12345678wx.getSetting({ success: res =&gt; { if (res.authSetting[&apos;scope.userInfo&apos;]) { // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框 ...... } }}) 如果用户第一次进入或从未授权个人信息，则不做任何默认操作，此时需要用户手动点击按钮进行授权； 根据小程序官方解释：注意：wx.authorize({scope: “scope.userInfo”})，无法弹出授权窗口，请使用 123456789101112// wxml&lt;button open-type=&quot;getUserInfo&quot; bindgetuserinfo=&quot;getUserInfo&quot;&gt;&lt;/button&gt;// jsgetUserInfo: function(e) { console.log(e) app.globalData.userInfo = e.detail.userInfo this.setData({ userInfo: e.detail.userInfo, hasUserInfo: true }) } 用户点击该按钮时，会返回获取到的用户信息，回调的detail数据与wx.getUserInfo返回的一致。 如果已经授权过，则在 App 的 onLaunch 钩子函数中调用 getUserInfo 去获取用户信息，并在 index 页面进行显示。 这里存在一个潜在的 bug ，App 的 onLaunch 执行后，Index 页面的 onLoad 方法也会随之执行，如果此时 wx.getUserInfo 接口尚未响应完成，则 Index 不能显示出用户信息。解决的方法是在 Index 页面获取 app 实例，并在 app 实例上挂载一个回调函数，然后在 wx.getUserInfo 接口得到响应后，执行该回调函数。 12345678910111213141516171819202122232425262728// index.js// 获取应用实例const app = getApp()app.userInfoReadyCallback = res =&gt; { this.setData({ userInfo: res.userInfo, hasUserInfo: true })}// app.jswx.getSetting({ success: res =&gt; { if (res.authSetting[&apos;scope.userInfo&apos;]) { wx.getUserInfo({ success: res =&gt; { this.globalData.userInfo = res.userInfo // 如果有 index 页面指定的回调函数，则执行 if (this.userInfoReadyCallback) { this.userInfoReadyCallback(res) } } }) } }}) 存储数据和路由本地缓存该 demo 中存储日志用到了 setStorageSync ，这是一个同步存储本地缓存的方法。与之对应的同步获取本地缓存的方法是 getStorageSync 。说到同步，就不得不提到异步。本地缓存存取的异步方法分别是 getStorage 和 setStorage。小程序的本地缓存与 WebStorage 有异曲同工之妙。 123var logs = wx.getStorageSync(&apos;logs&apos;) || []logs.unshift(Date.now())wx.setStorageSync(&apos;logs&apos;, logs) 路由小程序提供的路由方法主要有以下几个： wx.redirectTo(Object object)：关闭当前页面，跳转到应用内的某个页面，但是不允许跳转到 tabbar 页面。传入的 object 包含 url (跳转的页面的路径)，success (成功回调函数)，fail (失败回调函数），complete (接口调用结束的回调函数，无论成功或失败) 等几个属性及方法。相当于没有当前页的历史记录。 wx.navigateTo(Object object)：保留当前页面，跳转到应用内的某个页面，但是不能跳到 tabbar 页面。使用 wx.navigateBack 可以返回到原页面。相当于保留了当前页的历史记录。 wx.navigateBack(Object object)：关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。传入的 object 不再包含 url，而是 delta，表示后退 delta 页。 wx.reLaunch(Object object)：关闭所有页面，打开到应用内的某个页面。相当于销毁所有路由历史记录再打开新页面。 wx.switchTab(Object object)：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/微信小程序的摸索之路-从demo入手揭开神秘面纱.html"},{"title":"微信小程序自定义tabBar","text":"本文分享一下微信小程序自定义tabBar的几种实现方式。 模拟的tabBar页面（不推荐）使用策略 app.json不配置tabBar，用普通page来代替tabbar页面，暂且称之为模拟的tabbar页面。 每个模拟的tabbar页面都需要引入自定义tabbar组件。 自定义的tabbar组件写法如下： /components/index-tabbar/index.json 1234567{ &quot;component&quot;: true, &quot;usingComponents&quot;: { &quot;van-tabbar&quot;: &quot;vant-weapp/tabbar/index&quot;, &quot;van-tabbar-item&quot;: &quot;vant-weapp/tabbar-item/index&quot; }} /components/index-tabbar/index.wxml 12345678&lt;cover-view class=\"container\"&gt; &lt;van-tabbar active=\"{{ active }}\" bind:change=\"onChange\"&gt; &lt;van-tabbar-item name=\"index\" icon=\"home-o\"&gt;首页&lt;/van-tabbar-item&gt; &lt;van-tabbar-item name=\"category\" icon=\"label-o\"&gt;分类&lt;/van-tabbar-item&gt; &lt;van-tabbar-item name=\"msgs\" icon=\"comment-o\"&gt;留言&lt;/van-tabbar-item&gt; &lt;van-tabbar-item name=\"my\" icon=\"user-o\"&gt;我的&lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt;&lt;/cover-view&gt; /components/index-tabbar/index.js 123456789101112131415Component({ properties: { active: { type: String, value: 'index' }, }, methods: { onChange(event) { wx.redirectTo({ url: `/pages/${event.detail}/index`, }) } }}) 模拟的tabbar页面写法如下： /pages/home/index.json 12345{ &quot;usingComponents&quot;: { &quot;index-tabbar&quot;: &quot;/components/index-tabbar/index&quot; }} /pages/home/index.wxml 1234&lt;view class=\"container\"&gt; &lt;text&gt;首页&lt;/text&gt; &lt;index-tabbar active=\"index\"&gt;&lt;/index-tabbar&gt;&lt;/view&gt; 跳转页面使用wx.redirectTo 总结由于wx.redirectTo跳转页面是跳转的普通页面，页面渲染也自然会导致自定义的tabbar组件重新渲染，所以会出现底部tabbar闪一下的视觉体验，很尴尬。 Component伪装Page（还不错）使用策略将上述4个模拟的tabBar页面换成组件写法，然后根据条件进行wx:if控制。 改造首页，分类，留言，我的，将其由页面改为组件 /pages/home/index.json 123{ &quot;component&quot;: true} /pages/home/index.wxml 123&lt;view&gt; &lt;text&gt;首页&lt;/text&gt;&lt;/view&gt; /pages/home/index.js 1Component({}) index-tabbar组件改造 /components/index-tabbar/index.wxml 1234567891011121314&lt;cover-view class=\"container\"&gt; &lt;van-tabbar active=\"{{ active }}\" bind:change=\"onChange\"&gt; &lt;van-tabbar-item wx:for=\"{{panels}}\" wx:for-index=\"index\" wx:for-item=\"item\" wx:key=\"{{index}}\" name=\"{{item.name}}\" icon=\"{{item.icon}}\" info=\"{{item.badge}}\"&gt; {{item.label}} &lt;/van-tabbar-item&gt; &lt;/van-tabbar&gt;&lt;/cover-view&gt; /components/index-tabbar/index.js 1234567891011121314151617Component({ properties: { active: { type: String, value: 'home' }, panels: { type: Array, value: [] }, }, methods: { onChange(event) { this.triggerEvent('changeTab', event.detail) } }}) 入口页index改写成如下 /pages/index/index.json 123456789{ &quot;usingComponents&quot;: { &quot;index-tabbar&quot;: &quot;/components/index-tabbar/index&quot;, &quot;home-panel&quot;: &quot;../home/index&quot;, &quot;category-panel&quot;: &quot;../category/index&quot;, &quot;msgs-panel&quot;: &quot;../msgs/index&quot;, &quot;my-panel&quot;: &quot;../my/index&quot; }} /pages/index/index.wxml 1234567&lt;view class=\"container\"&gt; &lt;home-panel wx:if=\"{{activeTab == 'home'}}\"&gt;首页&lt;/home-panel&gt; &lt;category-panel wx:if=\"{{activeTab == 'category'}}\"&gt;分类&lt;/category-panel&gt; &lt;msgs-panel wx:if=\"{{activeTab == 'msgs'}}\"&gt;留言&lt;/msgs-panel&gt; &lt;my-panel wx:if=\"{{activeTab == 'my'}}\"&gt;我的&lt;/my-panel&gt; &lt;index-tabbar active=\"{{activeTab}}\" panels=\"{{panels}}\" bind:changeTab=\"onTabChange\"&gt;&lt;/index-tabbar&gt;&lt;/view&gt; /pages/index/index.js 12345678910111213141516Page({ data: { activeTab: 'home', panels: [ { name: 'home', icon: 'home-o', label: '首页' }, { name: 'category', icon: 'label-o', badge: '5', label: '分类' }, { name: 'msgs', icon: 'comment-o', badge: '99+', label: '留言' }, { name: 'my', icon: 'user-o', label: '我的' } ] }, onTabChange(event) { this.setData({ activeTab: event.detail }) }}) 效果如下： 总结由于是通过wx:if控制组件的创建和销毁，是局部更新，所以不会导致底部tabbar的重新渲染，所以底部闪一下的问题就解决了。缺点我想是如果频繁切换tab可能导致wx:if的渲染开销大吧。 官方自定义tabBar官方也提供了自定义tabbar的方法，见自定义 tabBar。 基础库 2.5.0 开始支持，低版本需做兼容处理。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/微信小程序自定义tabBar.html"},{"title":"撸一遍vue的基础特性","text":"Vue.js无疑是最近最火的一套渐进式前端框架。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。其轻量级，渐进式的优点对开发者的吸引力毋庸置疑。我使用过两年的Angular，对Vue也充满了好奇，于是也想认识一下Vue。 Vue.js安装主流的安装方式当然是使用vue-cli工具，这跟angular挺像的。但是作为刚入门的开发者，官方比较推荐的安装方式是直接引入script。vue脚本也分为开发版vue.js和生产版vue.min.js，开发环境下推荐使用vue.js，可以在开发过程中看到常见错误相关的警告。你可以选择使用CDN服务，直接引入这个脚本即可进行开发。 1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.14/dist/vue.js\"&gt;&lt;/script&gt; 我还是习惯直接把脚本下载到项目文件夹中。 1&lt;script src=\"./lib/vue.js\"&gt;&lt;/script&gt; 学习Vue学习Vue.js最好的方法当然是把代码都撸一遍，这样印象会比较深刻。 v-if这个指令类似于angular的*ngIf，作为一个结构性指令，用来控制元素的插入和移除。当v-if=”true”时，元素正常显示；反之元素则被移除。 v-show这个指令达到的效果看起来与v-if是一样的，但是从本质上来讲是不同的。v-show其实仅仅从样式上来控制显示和隐藏，改变的是display属性。与jQuery的show()和hide()方法有异曲同工之妙。 插值表达式1&lt;span&gt;{{ content }}&lt;/span&gt; 这个是数据绑定的标准写法，与angular是一样的。content变量的值改变时，页面渲染也随之变化。插值表达式中支持js表达式。 v-html从字面意思能看出来，该指令绑定的值会输出html内容，类似于jQuery的html()方法。在angular中好像没有看到这个指令，我是自定义了一个directive来实现的。 属性绑定v-bind这个指令用来绑定元素属性，通常用于向子组件传递props。比如子组件studentList内部需要属性id来做逻辑判断，这个id可以由父组件来传递，这里就可以使用到v-bind。 1&lt;student-list v-bind:id=\"somevalue\"&gt;&lt;/student-list&gt; v-bind:可以缩写为: 1&lt;student-list :id=\"somevalue\"&gt;&lt;/student-list&gt; 事件绑定v-on用来绑定事件，比如鼠标点击事件，可以这样写： 1&lt;button v-on:click=\"toggleVueIf\"&gt;Toggle VUE IF&lt;/button&gt; v-bind:可以缩写为@： 1&lt;button @click=\"toggleVueIf\"&gt;Toggle VUE IF&lt;/button&gt; v-forv-for用来遍历数组或对象（1）数组，接收的参数上可以是两个，顺序是value, index 123&lt;ul v-for=\"(value, index) in vueForArray\"&gt; &lt;li&gt;{{ index }}: {{ value }}&lt;/li&gt;&lt;/ul&gt; （2）对象，接收的参数上可以是三个，顺序是value, key, index 123&lt;ul v-for=\"(value, key, index) in vueForObject\"&gt; &lt;li&gt;{{ index }}. {{ key }} : {{ value }}&lt;/li&gt;&lt;/ul&gt; 计算属性computed对于插值表达式中涉及到的复杂计算，建议用计算属性computed来替代。在new Vue时可以使用computed属性。 12345678// html中{{ reversedMessage }}// vue实例中computed: { reversedMessage: function() { return this.testMessage.split('').reverse().join(''); }} 这里只是一个倒序的算法，不算很复杂，只是举例说明。 watch属性我们可以使用watch来进行侦听，来响应数据的变化。上面计算属性的应用，我们也可以改用watch来写： 12345watch: { testMessage: function() { this.reversedMessage = this.testMessage.split('').reverse().join(''); }} 这里，我们通过侦听testMessage的变化来做出响应，用于改变reversedMessage的值。 ps：那么computed和watch的应用场景怎么区分？个人认为，computed更适合做一些数据值的计算，而涉及到侦听某变量需要做一些业务处理时，建议使用watch。 class绑定12&lt;!-- 类似这种形式，与属性绑定大同小异。class的绑定值可以是键值对，也可以是数组。 --&gt;&lt;div :class=\"{ category: isCategory, red: isRed }\"&gt;&lt;/div&gt; style绑定与class绑定类似，支持键值对语法（css键值对），也支持数组（多个样式对象同时作用）。 1&lt;div :style=\"{ color: activeColor, fontSize: fontSize + 'px' }\"&gt;&lt;/div&gt; 双向绑定v-model这一特性与angular的[(ngModel)]是一致的。通常用于表单元素。 12&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: {{ message }}&lt;/p&gt; 不过v-model还支持很多修饰符，如（1）.lazy 12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=\"msg\" &gt; （2）.number自动将用户的输入值转为数值类型（3）.trim自动过滤用户输入的首尾空白字符 .sync看名字就知道了，同步的意思，如果绑定的属性加上这个修饰符，就实现了双向绑定。.sync破坏了单向数据流，于2.0 中移除，但又在 2.3.0 版本后以语法糖形式重新引入。 1&lt;comp :foo.sync=\"bar\"&gt;&lt;/comp&gt; 父子组件通信父组件通过属性传递数据给子组件props，而子组件以this.$emit(eventname, data)的方式发事件给父组件，父组件模板中需要绑定对应事件。 12345678910111213// 父组件模板，通过绑定greet传递数据给子组件，@replay接收来自子组件的事件。&lt;child :greet=\"greetMsg\" @reply=\"showReply\"&gt;&lt;/child&gt;// 子组件props属性接收props: ['greet']// 子组件模板&lt;p&gt;Greet from Father Component: {{greet}}&lt;/p&gt;&lt;button @click=\"replyToFather\"&gt;Reply&lt;/button&gt;// 点击button时调用replyToFather方法，通过$emit发送事件给父组件。methods: { replyToFather: function() { this.$emit('reply', this.replyInfo); }} slot类似angular的ng-content。父组件可以将想要的内容插在子组件的插槽中。子组件slot标签通过name属性区分插槽，如name=”slot1”，不写name属性的就是默认插槽了；而父组件要在传递给插槽的标签中加上slot属性来区分插在哪个槽中，如slot=”slot1”，如果不加slot属性，则自动插在默认插槽中。slot标签中的内容都被视为备用内容，如果父组件不给子组件传入内容，则会显示子组件slot标签中的备用内容。使用如下： 1234567891011121314151617&lt;!-- 父组件模板 --&gt;&lt;child&gt; &lt;!-- 没有指定slot属性，所以插在子组件中没有name属性的slot位置 --&gt; &lt;p&gt;Message From Father&lt;/p&gt; &lt;!-- 指定了slot属性的值为head，所以插在子组件中name属性值为head的slot位置 --&gt; &lt;p slot=\"head\"&gt;For Head&lt;/p&gt; &lt;!-- 指定了slot属性的值为foot，所以插在子组件中name属性值为foot的slot位置 --&gt; &lt;p slot=\"foot\"&gt;For Foot&lt;/p&gt; &lt;!-- 没有指定slot属性，所以插在子组件中没有name属性的slot位置 --&gt; &lt;p&gt;Other information...&lt;/p&gt;&lt;child&gt;&lt;!-- 子组件模板 --&gt;&lt;div&gt; &lt;slot name=\"head\"&gt;head content...&lt;/slot&gt; &lt;slot&gt;Backup content...&lt;/slot&gt; &lt;slot name=\"foot\"&gt;foot content...&lt;/slot&gt;&lt;/div&gt; 作用域插槽官方提供的说明我不太看得懂，根据我个人的理解，一个很重要的应用场景就是用来抽象列表式组件。比如一个展示性的列表组件，但是具体展示图文，还是其他的，需要由其父组件来指定。我这里写了一个demo。 123456789101112131415&lt;!-- 父组件模板 --&gt;&lt;my-list :items=\"movies\"&gt; &lt;template slot-scope=\"props\"&gt; &lt;li&gt; &lt;img class=\"poster\" :src=\"props.item.posterUrl\"/&gt; &lt;div&gt;{{ props.item.moviename }}&lt;/div&gt; &lt;/li&gt; &lt;!-- 我可以在这里调用各种组件，来适应各种需要，比如我可以做海报展示，那么我只要一个&lt;img&gt;;比如我只要电影名称的列表，那么就只要用到电影名称 --&gt; &lt;/template&gt;&lt;/my-list&gt;&lt;!-- 子组件模板，模板中的items是由props接收的 --&gt;&lt;ul&gt; &lt;span class=\"hot-movie\"&gt;近期热映&lt;/span&gt; &lt;slot name=\"slot-item\" v-for=\"item in items\" :item=\"item\"&gt;&lt;/slot&gt;&lt;/ul&gt; 使用要点：（1）父组件通过属性绑定将数据（一般是数组，毕竟是用于列表展示嘛）传递给子组件。 1&lt;my-list :items=\"movies\"&gt;&lt;/my-list&gt; （2）父组件传递给子组件的内容用template标签包裹，template标签具备slot-scope=”props”，props来源于子组件slot标签绑定的属性集，而本例中slot标签绑定了item属性，所以template中的内容可以调用props.item下的属性。 动态组件利用component标签及其is属性可以动态切换组件。curComponent的值为组件名。 1&lt;component :is=\"curComponent\"&gt;&lt;/component&gt; keep-alive标签利用keep-alive标签包裹component标签可以让切换组件保留在内存中，可以保留它的状态，避免重新渲染。 123&lt;keep-alive&gt; &lt;component :is=\"curComponent\"&gt;&lt;/component&gt;&lt;/keep-alive&gt; ref属性ref属性实现了组件的引用，不过应当避免使用ref。 123&lt;ref-comp ref=\"refComp\"&gt;&lt;/ref-comp&gt;&lt;!-- 我们可以在父组件中直接改变子组件中的refValue属性 --&gt;this.$refs.refComp.refValue += 'a'; transition过渡在组件外包裹一层transition标签，name标识transition，即可为组件加上过渡效果。如： 123&lt;transition name=\"fade\"&gt; &lt;p v-show=\"showFade\"&gt;Fade&lt;/p&gt;&lt;/transition&gt; 在进入/离开的过渡中，会有 6 个 class 切换，默认 class 名称格式如下。 fade-enter // 进入过渡开始，一般在这个class下定义-过渡开始时的css状态 fade-enter-active // 进入过渡活跃状态，一般在这个-class下定义进入过渡过程中的动画 fade-enter-to // 进入过渡结束，一般在这个class下定义过渡结束时的css状态。ps：离开过渡不再说明，类似开始过渡。 fade-leave // 离开过渡开始 fade-leave-active // 离开过渡活跃状态 fade-leave-to // 离开过渡结束 我们也可以自定义过渡类名，需要增加transition标签的属性，这样就可以使用第三方的动画库了。用法如下： 123&lt;transition name=\"fade\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\"&gt; &lt;p v-show=\"showFade\"&gt;Fade&lt;/p&gt;&lt;/transition&gt; 过渡效果主要的应用场景有： v-if v-show 动态组件 transition有着一系列javascript钩子函数，从字面意思可以与过渡的class对应起来，如下所示： 1234567891011121314&lt;transition :css=\"false\" @before-enter=\"beforeEnter\" @enter=\"enter\" @after-enter=\"afterEnter\" @enter-cancelled=\"enterCancelled\" @before-leave=\"beforeLeave\" @leave=\"leave\" @after-leave=\"afterLeave\" @leave-cancelled=\"leaveCancelled\"&gt;......&lt;/transition&gt; 钩子函数都有参数el，用于引用添加了transition包裹的元素。enter和leave钩子函数中额外有一个参数done，done是一个回调函数，是必须在最后调用的。否则，它们会被同步调用，过渡会立即完成。 1234enter: function (el, done) { // ... done();} 有了js钩子函数，那么我就可以不使用class来定义过渡的效果了，我可以使用js动画库，如velocity.js，这个时候最好添加v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 我们可以给元素设置初始渲染的过渡效果。 123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; appear拥有相同的class钩子和js钩子，也可以自定义类名。 多个元素的过渡transition中多个元素过渡时，可以这样写，给每个元素加上key属性来作为唯一标识： 12345678&lt;transition&gt; &lt;button v-if=\"isEditing\" key=\"save\"&gt; Save &lt;/button&gt; &lt;button v-else key=\"edit\"&gt; Edit &lt;/button&gt;&lt;/transition&gt; 上述代码也可以简写为绑定key的形式，而不再需要if，else： 12345&lt;transition&gt; &lt;button :key=\"isEditing\"&gt; {{ isEditing ? 'Save' : 'Edit' }} &lt;/button&gt;&lt;/transition&gt; 其中的isEditing ? ‘Save’ : ‘Edit’也可以抽象为一个computed属性。 除了多个元素的过渡，类似的还有动态组件的过渡。 123&lt;transition name=\"fade-dynamic\" mode=\"out-in\"&gt; &lt;component :is=\"curComponent\"&gt;&lt;/component&gt;&lt;/transition&gt; mode属性定义了过渡模式，防止当前元素的离开与下一个元素的进入产生重叠现象： in-out：新元素先进行过渡，完成之后当前元素过渡离开。 out-in：当前元素先进行过渡，完成之后新元素过渡进入。 列表过渡列表过渡用到的组件是transition-group。transition-group会以真实的元素存在于html文档中，而transition是不存在于html文档中的。transition-group存在的形式由tag属性指定，如 12345&lt;transition-group name=\"group-list\" tag=\"div\"&gt; &lt;div v-for=\"item in groups\" :key=\"item.id\" class=\"group-item\"&gt; &lt;img class=\"group-item-img\" :src=\"item.picUrl\"/&gt; &lt;/div&gt;&lt;/transition-group&gt; 为了让group-list的过渡效果平滑，有一个v-move属性，也是通过绑定class实现 123.group-list-move { transition: transform 1s;} 另一种实现方式如下： 1234567891011121314151617181920212223242526272829.group-item { margin: 10px; display: inline-block; width: 100px; height: 60px; transition: all 1s;}.group-item-img { width: 100%; height: 100%;}/* 这个作用是让元素在离开的过程中不占位，使过渡看起来十分平滑 */.group-list-leave-active { position: absolute;}/* .group-list-enter-active, .group-list-leave-active { transition: all 1s;} */.group-list-enter, .group-list-leave-to { opacity: 0; transform: translateY(30px);}/* move属性作用于元素的改变定位的过程中，这里会让transform有一个过渡效果；如果需要让列表整体有一个整体性过渡，那么可以在group-item类中加上transition属性，那么也就不需要group-list-enter-active和group-list-leave-active类中有transition属性了。*//* .group-list-move { transition: transform 1s;} */ mixinmixin是一种提高编写效率的写法，详情请参考mixin。 vue自定义指令一个指令定义对象可以提供如下几个钩子函数。 bind：只调用一次，指令第一次绑定到元素时调用。 inserted：被绑定元素插入父节点时调用 update componentUpdated unbind 目前未对指令进行深究，只写了一个简单的指令。 1234567directives: { autoClick: { inserted: function(el) { el.click(); } }} vue组件生命周期参考：（1）Vue2.0 探索之路——生命周期和钩子函数的一些理解（2）API 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/撸一遍vue的基础特性.html"},{"title":"我以为我很懂Promise，直到我开始实现Promise/A+规范","text":"我一度以为自己很懂Promise，直到前段时间尝试去实现Promise/A+规范时，才发现自己对Promise的理解还过于浅薄。在我按照Promise/A+规范去写具体代码实现的过程中，我经历了从“很懂”到“陌生”，再到“领会”的过山车式的认知转变，对Promise有了更深刻的认识！ TL;DR：鉴于很多人不想看长文，这里直接给出我写的Promise/A+规范的Javascript实现。 github仓库：promises-aplus-robin（顺手点个star就更好了） 源码 源码注释版 promises-tests测试用例是全部通过的。 Promise源于现实世界Promise直译过来就是承诺，最新的红宝书已经将其翻译为期约。当然，这都不重要，程序员之间只要一个眼神就懂了。 许下承诺作为打工人，我们不可避免地会接到各种饼，比如口头吹捧的饼、升值加薪的饼、股权激励的饼…… 有些饼马上就兑现了，比如口头褒奖，因为它本身没有给企业带来什么成本；有些饼却关乎企业实际利益，它们可能未来可期，也可能猴年马月，或是无疾而终，又或者直接宣告画饼失败。 画饼这个动作，于Javascript而言，就是创建一个Promise实例： 12345678const bing = new Promise((resolve, reject) =&gt; { // 祝各位的饼都能圆满成功 if (&apos;画饼成功&apos;) { resolve(&apos;大家happy&apos;) } else { reject(&apos;有难同当&apos;) }}) Promise跟这些饼很像，分为三种状态： pending: 饼已画好，坐等实现。 fulfilled: 饼真的实现了，走上人生巅峰。 rejected: 不好意思，画饼失败，emmm… 订阅承诺有人画饼，自然有人接饼。所谓“接饼”，就是对于这张饼的可能性做下设想。如果饼真的实现了，鄙人将别墅靠海；如果饼失败了，本打工仔以泪洗面。 转换成Promise中的概念，这是一种订阅的模式，成功和失败的情况我们都要订阅，并作出反应。订阅是通过then，catch等方法实现的。 1234567891011// 通过then方法进行订阅bing.then( // 对画饼成功的情况作出反应 success =&gt; { console.log(&apos;别墅靠海&apos;) }, // 对画饼失败的情况作出反应 fail =&gt; { console.log(&apos;以泪洗面...&apos;) }) 链式传播众所周知，老板可以给高层或领导们画饼，而领导们拿着老板画的饼，也必须给底下员工继续画饼，让打工人们鸡血不停，这样大家的饼才都有可能兑现。 这种自上而下发饼的行为与Promise的链式调用在思路上不谋而合。 12345678910111213bossBing.then( success =&gt; { // leader接过boss的饼，继续往下面发饼 return leaderBing }).then( success =&gt; { console.log(&apos;leader画的饼真的实现了，别墅靠海&apos;) }, fail =&gt; { console.log(&apos;leader画的饼炸了，以泪洗面...&apos;) }) 总体来说，Promise与现实世界的承诺还是挺相似的。 而Promise在具体实现上还有很多细节，比如异步处理的细节，Resolution算法，等等，这些在后面都会讲到。下面我会从自己对Promise的第一印象讲起，继而过渡到对宏任务与微任务的认识，最终揭开Promise/A+规范的神秘面纱。 初识Promise还记得最早接触Promise的时候，我感觉能把ajax过程封装起来就挺“厉害”了。那个时候对Promise的印象大概就是：优雅的异步封装，不再需要写高耦合的callback。 这里临时手撸一个简单的ajax封装作为示例说明： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667function isObject(val) { return Object.prototype.toString.call(val) === '[object Object]';}function serialize(params) { let result = ''; if (isObject(params)) { Object.keys(params).forEach((key) =&gt; { let val = encodeURIComponent(params[key]); result += `${key}=${val}&amp;`; }); } return result;}const defaultHeaders = { \"Content-Type\": \"application/x-www-form-urlencoded\"}// ajax简单封装function request(options) { return new Promise((resolve, reject) =&gt; { const { method, url, params, headers } = options const xhr = new XMLHttpRequest(); if (method === 'GET' || method === 'DELETE') { // GET和DELETE一般用querystring传参 const requestURL = url + '?' + serialize(params) xhr.open(method, requestURL, true); } else { xhr.open(method, url, true); } // 设置请求头 const mergedHeaders = Object.assign({}, defaultHeaders, headers) Object.keys(mergedHeaders).forEach(key =&gt; { xhr.setRequestHeader(key, mergedHeaders[key]); }) // 状态监听 xhr.onreadystatechange = function () { if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) { resolve(xhr.response) } else { reject(xhr.status) } } xhr.onerror = function(e) { reject(e) } // 处理body数据，发送请求 const data = method === 'POST' || method === 'PUT' ? serialize(params) : null xhr.send(data); })}const options = { method: 'GET', url: '/user/page', params: { pageNo: 1, pageSize: 10 }}// 通过Promise的形式调用接口request(options).then(res =&gt; { // 请求成功}, fail =&gt; { // 请求失败}) 以上代码封装了ajax的主要过程，而其他很多细节和各种场景覆盖就不是几十行代码能说完的。不过我们可以看到，Promise封装的核心就是： 封装一个函数，将包含异步过程的代码包裹在构造Promise的executor中，所封装的函数最后需要return这个Promise实例。 Promise有三种状态，Pending, Fulfilled, Rejected。而resolve(), reject()是状态转移的触发器。 确定状态转移的条件，在本例中，我们认为ajax响应且状态码为200时，请求成功（执行resolve()），否则请求失败（执行reject()）。 ps: 实际业务中，除了判断HTTP状态码，我们还会另外判断内部错误码（业务系统中前后端约定的状态code）。 实际上现在有了axios这类的解决方案，我们也不会轻易选择自行封装ajax，不鼓励重复造这种基础且重要的轮子，更别说有些场景我们往往难以考虑周全。当然，在时间允许的情况下，可以学习其源码实现。 宏任务与微任务要理解Promise/A+规范，必须先溯本求源，Promise与微任务息息相关，所以我们有必要先对宏任务和微任务有个基本认识。 在很长一段时间里，我都没有太多去关注宏任务（Task）与微任务（Microtask）。甚至有一段时间，我觉得setTimeout(fn, 0)在操作动态生成的DOM元素时非常好用，然而并不知道其背后的原理，实质上这跟Task联系紧密。 1234567891011var button = document.createElement('button');button.innerText = '新增输入框'document.body.append(button)button.onmousedown = function() { var input = document.createElement('input'); document.body.appendChild(input); setTimeout(function() { input.focus(); }, 0)} 如果不使用setTimeout 0，focus()会没有效果。 那么，什么是宏任务和微任务呢？我们慢慢来揭开答案。 现代浏览器采用多进程架构，这一点可以参考Inside look at modern web browser。而和我们前端关系最紧密的就是其中的Renderer Process，Javascript便是运行在Renderer Process的Main Thread中。 Renderer: Controls anything inside of the tab where a website is displayed. 渲染进程控制了展示在Tab页中的网页的一切事情。可以理解为渲染进程就是专门为具体的某个网页服务的。 我们知道，Javascript可以直接与界面交互。假想一下，如果Javascript采用多线程策略，各个线程都能操作DOM，那最终的界面呈现到底以谁为准呢？这显然是存在矛盾的。因此，Javascript选择使用单线程模型的一个重要原因就是：为了保证用户界面的强一致性。 为了保证界面交互的连贯性和平滑度，Main Thread中，Javascript的执行和页面的渲染会交替执行（出于性能考虑，某些情况下，浏览器判断不需要执行界面渲染，会略过渲染的步骤）。目前大多数设备的屏幕刷新率为60次/秒，1帧大约是16.67ms，在这1帧的周期内，既要完成Javascript的执行，还要完成界面的渲染（if necessary），利用人眼的残影效应，让用户觉得界面交互是非常流畅的。 用一张图看看1帧的基本过程，引用自https://aerotwist.com/blog/the-anatomy-of-a-frame/ PS：requestIdleCallback是空闲回调，在1帧的末尾，如果还有时间富余，就会调用requestIdleCallback。注意不要在requestIdleCallback中修改DOM，或者读取布局信息导致触发Forced Synchronized Layout，否则会引发性能和体验问题。具体见Using requestIdleCallback。 我们知道，一个网页中的Render Process只有一个Main Thread，本质上来说，Javascript的任务在执行阶段都是按顺序执行，但是JS引擎在解析Javascript代码时，会把代码分为同步任务和异步任务。同步任务直接进入Main Thread执行；异步任务进入任务队列，并关联着一个异步回调。 在一个web app中，我们会写一些Javascript代码或者引用一些脚本，用作应用的初始化工作。在这些初始代码中，会按照顺序执行其中的同步代码。而在这些同步代码执行的过程中，会陆陆续续监听一些事件或者注册一些异步API（网络相关，IO相关，等等…）的回调，这些事件处理程序和回调就是异步任务，异步任务会进入任务队列，并且在接下来的Event Loop中被处理。 异步任务又分为Task和Microtask，各自有单独的数据结构和内存来维护。 用一个简单的例子来感受下： 123456789101112131415var a = 1;console.log('a:', a)var b = 2;console.log('b:', b)setTimeout(function task1(){ console.log('task1:', 5) Promise.resolve(6).then(function microtask2(res){ console.log('microtask2:', res) })}, 0)Promise.resolve(4).then(function microtask1(res){ console.log('microtask1:', res)})var b = 3;console.log('c:', c) 以上代码执行后，依次在控制台输出： 123456a: 1b: 2c: 3microtask1: 4task1: 5microtask2: 6 仔细一看也没什么难的，但是这背后发生的细节，还是有必要探究下。我们不妨先问自己几个问题，一起来看下吧。 Task和Microtask都有哪些？ Tasks： setTimeout setInterval MessageChannel I/0（文件，网络）相关API DOM事件监听：浏览器环境 setImmediate：Node环境，IE好像也支持（见caniuse数据） Microtasks: requestAnimationFrame：浏览器环境 MutationObserver：浏览器环境 Promise.prototype.then, Promise.prototype.catch, Promise.prototype.finally process.nextTick：Node环境 queueMicrotask requestAnimationFrame是不是微任务？requestAnimationFrame简称rAF，经常被我们用来做动画效果，因为其回调函数执行频率与浏览器屏幕刷新频率保持一致，也就是我们通常说的它能实现60FPS的效果。在rAF被大范围应用前，我们经常使用setTimeout来处理动画。但是setTimeout在主线程繁忙时，不一定能及时地被调度，从而出现卡顿现象。 那么rAF属于宏任务或者微任务吗？其实很多网站都没有给出定义，包括MDN上也描述得非常简单。 我们不妨自己问问自己，rAF是宏任务吗？我想了一下，显然不是，rAF可以用来代替定时器动画，怎么能和定时器任务一样被Event Loop调度呢？ 我又问了问自己，rAF是微任务吗？rAF的调用时机是在下一次浏览器重绘之前，这看起来和微任务的调用时机差不多，曾让我一度认为rAF是微任务，而实际上rAF也不是微任务。为什么这么说呢？请运行下这段代码。 1234567function recursionRaf() { requestAnimationFrame(() =&gt; { console.log('raf回调') recursionRaf() })}recursionRaf(); 你会发现，在无限递归的情况下，rAF回调正常执行，浏览器也可正常交互，没有出现阻塞的现象。 而如果rAF是微任务的话，则不会有这种待遇。不信你可以翻到后面一节内容「如果Microtask执行时又创建了Microtask，怎么处理？」。 所以，rAF的任务级别是很高的，拥有单独的队列维护。在浏览器1帧的周期内，rAF与Javascript执行，浏览器重绘是同一个Level的。（其实，大家在前面那张「解剖1帧」的图中也能看出来了。） Task和Microtask各有1个队列？最初，我认为既然浏览器区分了Task和Microtask，那就只要各自安排一个队列存储任务即可。事实上，Task根据task source的不同，安排了独立的队列。比如Dom事件属于Task，但是Dom事件有很多种类型，为了方便user agent细分Task并精细化地安排各种不同类型Task的处理优先级，甚至做一些优化工作，必须有一个task source来区分。同理，Microtask也有自己的microtask task source。 具体解释见HTML标准中的一段话： Essentially, task sources are used within standards to separate logically-different types of tasks, which a user agent might wish to distinguish between. Task queues *are used by user agents to coalesce task sources within a given event loop。 Task和Microtask的消费机制是怎样的？ An event loop has one or more task queues. A task queue is a set of tasks. javascript是事件驱动的，所以Event Loop是异步任务调度的核心。虽然我们一直说任务队列，但是Tasks在数据结构上不是队列（Queue），而是集合（Set）。在每一轮Event Loop中，会取出第一个runnable的Task（第一个可执行的Task，并不一定是顺序上的第一个Task）进入Main Thread执行，然后再检查Microtask队列并执行队列中所有Microtask。 说再多，都不如一张图直观，请看！ Task和Microtask什么时候进入相应队列?回过头来看，我们一直在提这个概念“异步任务进入队列”，那么就有个疑问，Task和Microtask到底是什么时候进入相应的队列？我们重新来捋捋。异步任务有注册，进队列，回调被执行这三个关键行为。注册很好理解，代表这个任务被创建了；而回调被执行则代表着这个任务已经被主线程捞起并执行了。但是，在进队列这一行为上，宏任务和微任务的表现是不一样的。 宏任务进队列对于Task而言，任务注册时就会进入队列，只是任务的状态还不是runnable，不具备被Event Loop捞起的条件。 我们先用Dom事件为例举个例子。 123document.body.addEventListener('click', function(e) { console.log('被点击了', e)}) 当addEventListener这行代码被执行时，任务就注册了，代表有一个用户点击事件相关的Task进入任务队列。那么这个宏任务什么时候才变成runnable呢？当然是用户点击发生并且信号传递到浏览器Render Process的Main Thread后，此时宏任务变成runnable状态，才可以被Event Loop捞起，进入Main Thread执行。 这里再举个例子，顺便解释下为什么setTimeout 0会有延迟。 123setTimeout(function() { console.log(&apos;我是setTimeout注册的宏任务&apos;)}, 0) 执行setTimeout这行代码时，相应的宏任务就被注册了，并且Main Thread会告知定时器线程，“你定时0毫秒后给我一个消息”。定时器线程收到消息，发现只要等待0毫秒，立马就给Main Thread一个消息，“我这边已经过了0毫秒了”。Main Thread收到这个回复消息后，就把相应宏任务的状态置为runnable，这个宏任务就可以被Event Loop捞起了。 可以看到，经过这样一个线程间通信的过程，即便是延时0毫秒的定时器，其回调也并不是在真正意义上的0毫秒之后执行，因为通信过程就需要耗费时间。网上有个观点说setTimeout 0的响应时间最少是4ms，其实也是有依据的，不过也是有条件的。 HTML Living Standard: If nesting level is greater than 5, and timeout is less than 4, then set timeout to 4. 对于这种说法，我觉得自己有个概念就行，不同浏览器在实现规范的细节上肯定不一样，具体通信过程也不详，是不是4ms也不好说，关键是你有没有搞清楚这背后经历了什么。 微任务进队列前面我们提到一个观点，执行完一个Task后，如果Microtask队列不为空，会把Microtask队列中所有的Microtask都取出来执行。我认为，Microtask不是在注册时就进入Microtask队列，因为Event Loop处理Microtask队列时，并不会判断Microtask的状态。反过来想，如果Microtask在注册时就进入Microtask队列，就会存在Microtask还未变为runnable状态就被执行的情况，这显然是不合理的。我的观点是，Microtask在变为runnable状态时才进入Microtask队列。 那么我们来分析下Microtask什么时候变成runnable状态，首先来看看Promise。 123456var promise1 = new Promise((resolve, reject) =&gt; { resolve(1);})promise1.then(res =&gt; { console.log('promise1微任务被执行了')}) 读者们，我的第一个问题是，Promise的微任务什么时候被注册？new Promise的时候？还是什么时候？不妨来猜一猜！ 答案是.then被执行的时候。（当然，还有.catch的情况，这里只是就这个例子说）。 那么Promise微任务的状态什么时候变成runnable呢？相信不少读者已经有了头绪了，没错，就是Promise状态发生转移的时候，在本例中也就是resolve(1)被执行的时候，Promise状态由pending转移为fulfilled。在resolve(1)执行后，这个Promise微任务就进入Microtask队列了，并且将在本次Event Loop中被执行。 基于这个例子，我们再来加深下难度。 12345678var promise1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 0);});promise1.then(res =&gt; { console.log('promise1微任务被执行了');}); 在这个例子中，Promise微任务的注册和进队列并不在同一次Event Loop。怎么说呢？在第一个Event Loop中，通过.then注册了微任务，但是我们可以发现，new Promise时，执行了一个setTimeout，这是相当于注册了一个宏任务。而resolve(1)必须在宏任务被执行时才会执行。很明显，两者中间隔了至少一次Event Loop。 如果能分析Promise微任务的过程，你自然就知道怎么分析ObserverMutation微任务的过程了，这里不再赘述。 如果Microtask执行时又创建了Microtask，怎么处理？我们知道，一次Event Loop最多只执行一个runnable的Task，但是会执行Microtask队列中的所有Microtask。如果在执行Microtask时，又创建了新的Microtask，这个新的Microtask是在下次Event Loop中被执行吗？答案是否定的。微任务可以添加新的微任务到队列中，并在下一个任务开始执行之前且当前Event Loop结束之前执行完所有的微任务。请注意不要递归地创建微任务，否则会陷入死循环。 下面就是一个糟糕的示例。 1234567// bad casefunction recursionMicrotask() { Promise.resolve().then(() =&gt; { recursionMicrotask() })}recursionMicrotask(); 请不要轻易尝试，否则页面会卡死哦！（因为Microtask占着Main Thread不释放，浏览器渲染都没办法进行了） 为什么要区分Task和Microtask？这是一个非常重要的问题。为什么不在执行完Task后，直接进行浏览器渲染这一步骤，而要再加上执行Microtask这一步呢？其实在前面的问题中已经解答过了。一次Event Loop只会消费一个宏任务，而微任务队列在被消费时有“继续上车”的机制，这就让开发者有了更多的想象力，对代码的控制力会更强。 做几道题热热身？在冲击Promise/A+规范前，不妨先用几个习题来测试下自己对Promise的理解程度。 基本操作1234567891011121314151617181920function mutationCallback(mutationRecords, observer) { console.log('mt1')}const observer = new MutationObserver(mutationCallback)observer.observe(document.body, { attributes: true })Promise.resolve().then(() =&gt; { console.log('mt2') setTimeout(() =&gt; { console.log('t1') }, 0) document.body.setAttribute('test', \"a\")}).then(() =&gt; { console.log('mt3')})setTimeout(() =&gt; { console.log('t2')}, 0) 这道题就不分析了，答案：mt2 mt1 mt3 t2 t1 浏览器不讲武德？123456789101112131415161718Promise.resolve().then(() =&gt; { console.log(0); return Promise.resolve(4);}).then((res) =&gt; { console.log(res)})Promise.resolve().then(() =&gt; { console.log(1);}).then(() =&gt; { console.log(2);}).then(() =&gt; { console.log(3);}).then(() =&gt; { console.log(5);}).then(() =&gt;{ console.log(6);}) 这道题据说是字节内部流出的一道题，说实话我刚看到的时候也是一头雾水。经过我在Chrome测试，得到的答案确实很有规律，就是：0 1 2 3 4 5 6。 先输出0，再输出1，我还能理解，为什么输出2和3后又突然跳到4呢，浏览器你不讲武德啊！ emm…我被戴上了痛苦面具！ 那么这背后的执行顺序到底是怎样的呢？仔细分析下，你会发现还是有迹可循的。 老规矩，第一个问题，这道题的代码执行过程中，产生了多少个微任务？可能很多人认为是7个，但实际上应该是8个。 编号 注册时机 异步回调 mt1 .then() console.log(0);return Promise.resolve(4); mt2 .then(res) console.log(res) mt3 .then() console.log(1); mt4 .then() console.log(2); mt5 .then() console.log(3); mt6 .then() console.log(5); mt7 .then() console.log(6); mt8 return Promise.resolve(4)执行并且execution context stack清空后，隐式注册 隐式回调（未体现在代码中），目的是让mt2变成runnable状态 同步任务执行，注册mt1~mt7七个微任务，此时execution context stack为空，并且mt1和mt3的状态变为runnable。JS引擎安排mt1和mt3进入Microtask队列（通过HostEnqueuePromiseJob实现）。 Perform a microtask checkpoint，由于mt1和mt3是在同一次JS call中变为runnable的，所以mt1和mt3的回调先后进入execution context stack执行。 mt1回调进入execution context stack执行，输出0，返回Promise.resolve(4)。mt1出队列。由于mt1回调返回的是一个状态为fulfilled的Promise，所以之后JS引擎会安排一个job（job是ecma中的概念，等同于微任务的概念，这里先给它编号mt8），其回调目的是让mt2的状态变为fulfilled（前提是当前execution context stack is empty）。所以紧接着还是先执行mt3的回调。 mt3回调进入execution context stack执行，输出1，mt4变为runnable状态，execution context stack is empty，mt3出队列。 由于此时mt4已经是runnable状态，JS引擎安排mt4进队列，接着JS引擎会安排mt8进队列。 接着，mt4回调进入execution context stack执行，输出2，mt5变为runnable，mt4出队列。JS引擎安排mt5进入Microtask队列。 mt8回调执行，目的是让mt2变成runnable状态，mt8出队列。mt2进队列。 mt5回调执行，输出3，mt6变为runnable，mt5出队列。mt6进队列。 mt2回调执行，输出4，mt2出队列。 mt6回调执行，输出5，mt7变为runnable，mt6出队列。mt7进队列。 mt7回调执行，输出6，mt7出队列。执行完毕！总体来看，输出结果依次为：0 1 2 3 4 5 6。 对这块执行过程尚有疑问的朋友，可以先往下看看Promise/A+规范和ECMAScript262规范中关于Promise的约定，再回过头来思考，也欢迎留言与我交流！ 经过我在Edge浏览器测试，结果是：0 1 2 4 3 5 6。可以看到，不同浏览器在实现Promise的主流程上是吻合的，但是在一些细枝末节上还有不一致的地方。实际应用中，我们只要注意规避这种问题即可。 实现Promise/A+热身完毕，接下来就是直面大boss Promise/A+规范。Promise/A+规范列举了大大小小三十余条细则，一眼看过去还是挺晕的。 仔细阅读多遍规范之后，我有了一个基本认识，要实现Promise/A+规范，关键是要理清其中几个核心点。 关系链路本来写了大几千字有点觉得疲倦了，于是想着最后这部分就用文字讲解快速收尾，但是最后这节写到一半时，我觉得我写不下去了，纯文字的东西太干了，干得没法吸收，这对那些对Promise掌握程度不够的读者来说是相当不友好的。所以，我觉得还是先用一张图来描述一下Promise的关系链路。 首先，Promise它是一个对象，而Promise/A+规范则是围绕着Promise的原型方法.then()展开的。 .then()的特殊性在于，它会返回一个新的Promise实例，在这种连续调用.then()的情况下，就会串起一个Promise链，这与原型链又有一些相似之处。“恬不知耻”地再推荐一篇「思维导图学前端 」6k字一文搞懂Javascript对象，原型，继承，哈哈哈。 另一个灵活的地方在于，p1.then(onFulfilled, onRejected)返回的新Promise实例p2，其状态转移的发生是在p1的状态转移发生之后（这里的之后指的是异步的之后）。并且，p2的状态转移为Fulfilled还是Rejected，这一点取决于onFulfilled或onRejected的返回值，这里有一个较为复杂的分析过程，也就是后面所述的Promise Resolution Procedure算法。 我这里画了一个简单的时序图，画图水平很差，只是为了让读者们先有个基本印象。 其中还有很多细节是没提到的（因为细节真的太多了，全部画出来就相当复杂，具体过程请看我文末附的源码）。 nextTick看了前面内容，相信大家都有一个概念，微任务是一个异步任务，而我们要实现Promise的整套异步机制，必然要具备模拟微任务异步回调的能力。在规范中也提到了这么一条信息： This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. 我这里选择的是用微任务来实现异步回调，如果用宏任务来实现异步回调，那么在Promise微任务队列执行过程中就可能会穿插宏任务，这就不太符合微任务队列的调度逻辑了。这里还对Node环境和浏览器环境做了兼容，Node环境中可以使用process.nextTick回调来模拟微任务的执行，而在浏览器环境中我们可以选择MutationObserver。 123456789101112function nextTick(callback) { if (typeof process !== 'undefined' &amp;&amp; typeof process.nextTick === 'function') { process.nextTick(callback) } else { const observer = new MutationObserver(callback) const textNode = document.createTextNode('1') observer.observe(textNode, { characterData: true }) textNode.data = '2' }} 状态转移 Promise实例一共有三种状态，分别是Pending, Fulfilled, Rejected，初始状态是Pending。 123456789101112const PROMISE_STATES = { PENDING: 'pending', FULFILLED: 'fulfilled', REJECTED: 'rejected'}class MyPromise { constructor(executor) { this.state = PROMISE_STATES.PENDING; } // ...其他代码} 一旦Promise的状态发生转移，就不可再转移为其他状态。 123456789101112131415161718/** * 封装Promise状态转移的过程 * @param {MyPromise} promise 发生状态转移的Promise实例 * @param {*} targetState 目标状态 * @param {*} value 伴随状态转移的值，可能是fulfilled的值，也可能是rejected的原因 */function transition(promise, targetState, value) { if (promise.state === PROMISE_STATES.PENDING &amp;&amp; targetState !== PROMISE_STATES.PENDING) { // 2.1: state只能由pending转为其他态，状态转移后，state和value的值不再变化 Object.defineProperty(promise, 'state', { configurable: false, writable: false, enumerable: true, value: targetState }) // ...其他代码 }} 触发状态转移是靠调用resolve()或reject()实现的。当resolve()被调用时，当前Promise也不一定会立即变为Fulfilled状态，因为传入resolve(value)方法的value有可能也是一个Promise，这个时候，当前Promise必须追踪传入的这个Promise的状态，整个确定Promise状态的过程是通过Promise Resolution Procedure算法实现的，具体细节封装到了下面代码中的resolvePromiseWithValue函数中。当reject()被调用时，当前Promise的状态就是确定的，一定是Rejected，此时可以通过transition函数（封装了状态转移的细节）将Promise的状态进行转移，并执行后续动作。 123456789101112131415161718// resolve的执行，是一个触发信号，基于此进行下一步的操作function resolve(value) { resolvePromiseWithValue(this, value)}// reject的执行，是状态可以变为Rejected的信号function reject(reason) { transition(this, PROMISE_STATES.REJECTED, reason)}class MyPromise { constructor(executor) { this.state = PROMISE_STATES.PENDING; this.fulfillQueue = []; this.rejectQueue = []; // 构造Promise实例后，立刻调用executor executor(resolve.bind(this), reject.bind(this)) }} 链式追踪假设现在有一个Promise实例，我们称之为p1。由于promise1.then(onFulfilled, onRejected)会返回一个新的Promise（我们称之为p2），与此同时，也会注册一个微任务mt1，这个新的p2会追踪其关联的p1的状态变化。 当p1的状态发生转移时，微任务mt1回调会在接下来被执行，如果状态是Fulfilled，则onFulfilled会被执行，否则onRejected会被执行。微任务mt回调1执行的结果将作为决定p2状态的依据。以下是Fulfilled情况下的部分关键代码，其中promise指的是p1，而chainedPromise指的是p2。 123456789101112131415161718192021// 回调应异步执行，所以用到了nextTicknextTick(() =&gt; { // then可能会被调用多次，所以异步回调应该用数组来维护 promise.fulfillQueue.forEach(({ handler, chainedPromise }) =&gt; { try { if (typeof handler === 'function') { const adoptedValue = handler(value) // 异步回调返回的值将决定衍生的Promise的状态 resolvePromiseWithValue(chainedPromise, adoptedValue) } else { // 存在调用了then，但是没传回调作为参数的可能，此时衍生的Promise的状态直接采纳其关联的Promise的状态。 transition(chainedPromise, PROMISE_STATES.FULFILLED, promise.value) } } catch (error) { // 如果回调抛出了异常，此时直接将衍生的Promise的状态转移为rejected，并用异常error作为reason transition(chainedPromise, PROMISE_STATES.REJECTED, error) } }) // 最后清空该Promise关联的回调队列 promise.fulfillQueue = [];}） Promise Resolution Procedure算法Promise Resolution Procedure算法是一种抽象的执行过程，它的语法形式是[[Resolve]](promise, x &quot;[Resolve]&quot;)，接受的参数是一个Promise实例和一个值x，通过值x的可能性，来决定这个Promise实例的状态走向。如果直接硬看规范，会有点吃力，这里直接说人话解释一些细节。 2.3.1如果promise和值x引用同一个对象，应该直接将promise的状态置为Rejected，并且用一个TypeError作为reject的原因。 If promise and x refer to the same object, reject promise with a TypeError as the reason. 【说人话】举个例子，老板说只要今年业绩超过10亿，业绩就超过10亿。这显然是个病句，你不能拿预期本身作为条件。正确的玩法是，老板说只要今年业绩超过10亿，就发1000万奖金（嘿嘿，这种事期待一下就好了）。 代码实现： 1234if (promise === x) { // 2.3.1 由于Promise采纳状态的机制，这里必须进行全等判断，防止出现死循环 transition(promise, PROMISE_STATES.REJECTED, new TypeError('promise and x cannot refer to a same object.'))} 2.3.2如果x是一个Promise实例，promise应该采纳x的状态。 2.3.2 If x is a promise, adopt its state [3.4]: 2.3.2.1 If `x` is pending, `promise` must remain pending until `x` is fulfilled or rejected. 2.3.2.2 If/when `x` is fulfilled, fulfill `promise` with the same value. 2.3.2.3 If/when `x` is rejected, reject `promise` with the same reason. 【说人话】小王问领导：“今年会发年终奖吗？发多少？”领导听了心里想，“这个事我之前也在打听，不过还没定下来，得看老板的意思。”，于是领导对小王说：“会发的，不过要等消息！”。 注意，这个时候，领导对小王许下了承诺，但是这个承诺p2的状态还是pending，需要看老板给的承诺p1的状态。 可能性1：过了几天，老板对领导说：“今年业务做得可以，年终奖发1000万”。这里相当于p1已经是fulfilled状态了，value是1000万。领导拿了这个准信了，自然可以跟小王兑现承诺p2了，于是对小王说：“年终奖可以下来了，是1000万！”。这时，承诺p2的状态就是fulfilled了，value也是1000万。小王这个时候就“别墅靠海”了。 可能性2：过了几天，老板有点发愁，对领导说：“今年业绩不太行啊，年终奖就不发了吧，明年，咱们明年多发点。”显然，这里p1就是rejected了，领导一看这情况不对啊，但也没办法，只能对小王说：“小王啊，今年公司情况特殊，年终奖就不发了。”这p2也随之rejected了，小王内心有点炸裂…… 注意，Promise /A+规范2.3.2小节这里有两个大的方向，一个是x的状态未定，一个是x的状态已定。在代码实现上，这里有个技巧，对于状态未定的情况，必须用订阅的方式来实现，而.then就是订阅的绝佳途径。 123456789101112131415161718else if (isPromise(x)) { // 2.3.2 如果x是一个Promise实例，则追踪并采纳其状态 if (x.state !== PROMISE_STATES.PENDING) { // 假设x的状态已经发生转移，则直接采纳其状态 transition(promise, x.state, x.state === PROMISE_STATES.FULFILLED ? x.value : x.reason) } else { // 假设x的状态还是pending，则只需等待x状态确定后再进行promise的状态转移 // 而x的状态转移结果是不定的，所以两种情况我们都需要进行订阅 // 这里用一个.then很巧妙地完成了订阅动作 x.then(value =&gt; { // x状态转移为fulfilled，由于callback传过来的value是不确定的类型，所以需要继续应用Promise Resolution Procedure算法 resolvePromiseWithValue(promise, value, thenableValues) }, reason =&gt; { // x状态转移为rejected transition(promise, PROMISE_STATES.REJECTED, reason) }) }} 多的细节咱这篇文章就不一一分析了，写着写着快1万字了，就先结束掉吧，感兴趣的读者可以直接打开源码看（往下看）。 这是跑测试用例的效果图，可以看到，872个case是全部通过的。 完整代码这里直接给出我写的Promise/A+规范的Javascript实现，供大家参考。后面如果有时间，会考虑详细分析下。 github仓库：promises-aplus-robin（顺手点个star就更好了） 源码 源码注释版 缺陷我这个版本的Promise/A+规范实现，不具备检测execution context stack为空的能力，所以在细节上会有一点问题（execution context stack还未清空就插入了微任务），无法适配上面那道「浏览器不讲武德？」的题目所述场景。 方法论不管是手写实现Promise/A+规范，还是实现其他Native Code，其本质上绕不开以下几点： 准确理解Native Code实现的能力，就像你理解一个需求要实现哪些功能点一样，并确定实现上的优先级。 针对每个功能点或者功能描述，逐一用代码实现，优先打通主干流程。 设计足够丰富的测试用例，回归测试，不断迭代，保证场景的覆盖率，最终打造一段优质的代码。 总结看到结尾，相信大家也累了，感谢各位读者的阅读！希望本文对宏任务和微任务的解读能给各位读者带来一点启发。Promise/A+规范总体来说还是比较晦涩难懂的，这对新手来说是不太友好的，因此我建议有一定程度的Promise实际使用经验后再深入学习Promise/A+规范。通过学习和理解Promise/A+规范的实现机制，你会更懂Promise的一些内部细节，对于设计一些复杂的异步过程会有极大的帮助，再不济也能提升你的异步调试和排错能力。 这里还有一些规范和文章可以参考： Promises/A+规范 Event Loop Processing Model tasks-microtasks-queues-and-schedules Jobs and Host Operations to Enqueue Jobs","link":"/我以为我很懂Promise.html"},{"title":"理解css中的px, em, rem","text":"px px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。 em em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。 任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。 ps：em会继承父级元素的字体大小。 rem rem是CSS3新增的一个相对单位。这个单位与em有什么区别呢？区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。 这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。目前，除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小。 12// 兼容写法p {font-size:14px; font-size:.875rem;} 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/理解css中的px, em, rem.html"},{"title":"理解html中script标签的defer与async属性","text":"经常会在一些地方看到一些&lt;script&gt;标签带上了defer和async，总是搞不清楚两者的具体区别，于是想记录下来。 从单词语义上来，defer代表延迟，async代表异步。那么我们就有一个基本的概念了。然后我们慢慢分析。 如果没有defer和async&lt;script&gt;标签如果没有带上defer或async属性的话，浏览器会立即加载并执行标签内的脚本，意思大概是不等待后续载入的文档元素，读到这个&lt;script&gt;标签就加载并执行。 如果有deferdefer的意思是延迟，也就是说延迟执行，除了这一点，加载的过程是异步的。那么就很好解释了，当遇到 1&lt;script defer&gt; 这种标签时，会开始加载script标签内容，但是不会阻塞后续文档元素的渲染，待所有页面元素解析完成后，DOMContentLoaded 事件触发之前执行这个script标签的代码。 如果有asyncasync就是sync的反义词，代表异步，也就是说异步加载和执行。所以，当遇到 1&lt;script async&gt; 这种标签时，加载和执行脚本的同时不会阻塞其他文档元素的渲染。 多个标签的情况还有一点要注意的就是，多个async标签是不会相互影响的，谁先加载完，谁就先执行了。而多个defer标签是异步加载，但是最后执行的顺序是根据其在页面上的顺序来决定的。 现在是不是觉得豁然开朗了呢？ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/理解html中script标签的defer与async属性.html"},{"title":"用初中数学知识撸一个canvas环形进度条","text":"周末好，今天给大家带来一款接地气的环形进度条组件vue-awesome-progress。近日被设计小姐姐要求实现这么一个环形进度条效果，大体由四部分组成，分别是底色圆环，进度弧，环内文字，进度圆点。设计稿截图如下： 我的第一反应还是找现成的组件，市面上很多组件都实现了前3点，独独没找到能画进度圆点的组件，不然稍加定制也能复用。既然没有现成的组件，只有自己用vue + canvas撸一个了。 效果图先放个效果图，然后再说下具体实现过程，各位看官且听我慢慢道来。 安装与使用源码地址，欢迎star和提issue。 安装1npm install --save vue-awesome-progress 使用全局注册123import Vue from 'vue'import VueAwesomeProgress from \"vue-awesome-progress\"Vue.use(VueAwesomeProgress) 局部使用12345678import VueAwesomeProgress from &quot;vue-awesome-progress&quot;export default { components: { VueAwesomeProgress }, // 其他代码} script标签引入组件同时也支持直接使用script标签引入哦，满足有这部分需求的朋友。 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.6.10/vue.min.js\"&gt;&lt;/script&gt; &lt;script src=\"path-to/vue-awesome-progress.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt; &lt;script&gt; new Vue({ el: \"#app\", template: '&lt;vue-awesome-progress :percentage=\"40\"&gt;&lt;/vue-awesome-progress&gt;' }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 静态展示任何事都不是一蹴而就的，我们首先来实现一个静态的效果，然后再实现动画效果，甚至是复杂的控制逻辑。 确定画布大小第一步是确定画布大小。从设计稿我们可以直观地看到，整个环形进度条的最外围是由进度圆点确定的，而进度圆点的圆心在圆环圆周上。 因此我们得出伪代码如下： 12345// canvasSize: canvas宽度/高度// outerRadius: 外围半径// pointRadius: 圆点半径// pointRadius: 圆环半径canvasSize = 2 * outerRadius = 2 * (pointRadius + circleRadius) 据此我们可以定义如下组件属性： 1234567891011121314151617181920props: { circleRadius: { type: Number, default: 40 }, pointRadius: { type: Number, default: 6 }},computed: { // 外围半径 outerRadius() { return this.circleRadius + this.pointRadius }, // canvas宽/高 canvasSize() { return 2 * this.outerRadius + 'px' }} 那么canvas大小也可以先进行绑定了 123&lt;template&gt; &lt;canvas ref=\"canvasDemo\" :width=\"canvasSize\" :height=\"canvasSize\" /&gt;&lt;/template&gt; 获取绘图上下文getContext('2d')方法返回一个用于在canvas上绘图的环境，支持一系列2d绘图API。 123456789101112mounted() { // 在$nextTick初始化画布，不然dom还未渲染好 this.$nextTick(() =&gt; { this.initCanvas() })},methods: { initCanvas() { var canvas = this.$refs.canvasDemo; var ctx = canvas.getContext('2d'); }} 画底色圆环完成了上述步骤后，我们就可以着手画各个元素了。我们先画圆环，这时我们还要定义两个属性，分别是圆环线宽circleWidth和圆环颜色circleColor。 12345678circleWidth: { type: Number, default: 2},circleColor: { type: String, default: '#3B77E3'} canvas提供的画圆弧的方法是ctx.arc()，需要提供圆心坐标，半径，起止弧度，是否逆时针等参数。 1ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise); 我们知道，Web网页中的坐标系是这样的，从绝对定位的设置上其实就能看出来（top，left设置正负值会发生什么变化），而且原点(0, 0)是在盒子（比如说canvas）的左上角哦。 对于角度而言，0°是x轴正向，默认是顺时针方向旋转。 圆环的圆心就是canvas的中心，所以x, y 取outerRadius的值就可以了。 12345ctx.strokeStyle = this.circleColor;ctx.lineWidth = this.circleWidth;ctx.beginPath();ctx.arc(this.outerRadius, this.outerRadius, this.circleRadius, 0, this.deg2Arc(360));ctx.stroke(); 注意arc传的是弧度参数，而不是我们常理解的360°这种概念，因此我们需要将我们理解的360°转为弧度。 1234// deg转弧度deg2Arc(deg) { return deg / 180 * Math.PI} 画文字调用fillText绘制文字，利用canvas.clientWidth / 2和canvas.clientWidth / 2取得中点坐标，结合控制文字对齐的两个属性textAlign和textBaseline，我们可以将文字绘制在画布中央。文字的值由label属性接收，字体大小由fontSize属性接收，颜色则取的fontColor。 1234567if (this.label) { ctx.font = `${this.fontSize}px Arial,\"Microsoft YaHei\"` ctx.fillStyle = this.fontColor; ctx.textAlign = 'center' ctx.textBaseline = 'middle' ctx.fillText(this.label, canvas.clientWidth / 2, canvas.clientWidth / 2);} 画进度弧支持普通颜色和渐变色，withGradient默认为true，代表使用渐变色绘制进度弧，渐变方向我默认给的从上到下。如果希望使用普通颜色，withGradient传false即可，并可以通过lineColor自定义颜色。 123456if (this.withGradient) { this.gradient = ctx.createLinearGradient(this.circleRadius, 0, this.circleRadius, this.circleRadius * 2); this.lineColorStops.forEach(item =&gt; { this.gradient.addColorStop(item.percent, item.color); });} 其中lineColorStops是渐变色的颜色偏移断点，由父组件传入，可传入任意个颜色断点，格式如下： 1234colorStops2: [ { percent: 0, color: '#FF9933' }, { percent: 1, color: '#FF4949' }] 画一条从上到下的进度弧，即270°到90° 12345ctx.strokeStyle = this.withGradient ? this.gradient : this.lineColor;ctx.lineWidth = this.lineWidth;ctx.beginPath();ctx.arc(this.outerRadius, this.outerRadius, this.circleRadius, this.deg2Arc(270), this.deg2Arc(90));ctx.stroke(); 其中lineWidth是弧线的宽度，由父组件传入 1234lineWidth: { type: Number, default: 8} 画进度圆点最后我们需要把进度圆点补上，我们先写死一个角度90°，显而易见，圆点坐标为(this.outerRadius, this.outerRadius + this.circleRadius) 画圆点的代码如下： 1234ctx.fillStyle = this.pointColor;ctx.beginPath();ctx.arc(this.outerRadius, this.outerRadius + this.circleRadius, this.pointRadius, 0, this.deg2Arc(360));ctx.fill(); 其中pointRadius是圆点的半径，由父组件传入： 1234pointRadius: { type: Number, default: 6} 角度自定义当然，进度条的角度是灵活定义的，包括开始角度，结束角度，都应该由调用者随意给出。因此我们再定义一个属性angleRange，用于接收起止角度。 123456angleRange: { type: Array, default: function() { return [270, 90] }} 有了这个属性，我们就可以随意地画进度弧和圆点了，哈哈哈哈。 老哥，这种圆点坐标怎么求？ 噗……看来高兴过早了，最重要的是根据不同角度求得圆点的圆心坐标，这让我顿时犯了难。 经过冷静思考，我脑子里闪过了一个利用正余弦公式求坐标的思路，但前提是坐标系原点如果在圆环外接矩形的左上角才好算。仔细想想，冇问题啦，我先给坐标系平移一下，最后求出来结果，再补个平移差值不就行了嘛。 画图工具不是很熟练，这里图没画好，线歪了，请忽略细节。 好的，我们先给坐标系向右下方平移pointRadius，最后求得结果再加上pointRadius就好了。伪代码如下： 1234567// realx：真实的x坐标// realy：真实的y坐标// resultx：平移后求取的x坐标// resultx：平移后求取的y坐标// pointRadius 圆点半径realx = resultx + pointRadiusrealy = resulty + pointRadius 求解坐标的思路大概如下，分四个范围判断，得出求解公式，应该还可以化简，不过我数学太菜了，先这样吧。 12345678910111213141516171819202122getPositionsByDeg(deg) { let x = 0; let y = 0; if (deg &gt;= 0 &amp;&amp; deg &lt;= 90) { // 0~90度 x = this.circleRadius * (1 + Math.cos(this.deg2Arc(deg))) y = this.circleRadius * (1 + Math.sin(this.deg2Arc(deg))) } else if (deg &gt; 90 &amp;&amp; deg &lt;= 180) { // 90~180度 x = this.circleRadius * (1 - Math.cos(this.deg2Arc(180 - deg))) y = this.circleRadius * (1 + Math.sin(this.deg2Arc(180 - deg))) } else if (deg &gt; 180 &amp;&amp; deg &lt;= 270) { // 180~270度 x = this.circleRadius * (1 - Math.sin(this.deg2Arc(270 - deg))) y = this.circleRadius * (1 - Math.cos(this.deg2Arc(270 - deg))) } else { // 270~360度 x = this.circleRadius * (1 + Math.cos(this.deg2Arc(360 - deg))) y = this.circleRadius * (1 - Math.sin(this.deg2Arc(360 - deg))) } return { x, y }} 最后再补上偏移值即可。 12const pointPosition = this.getPositionsByDeg(nextDeg);ctx.arc(pointPosition.x + this.pointRadius, pointPosition.y + this.pointRadius, this.pointRadius, 0, this.deg2Arc(360)); 这样，一个基本的canvas环形进度条就成型了。 动画展示静态的东西逼格自然是不够的，因此我们需要再搞点动画效果装装逼。 基础动画我们先简单实现一个线性的动画效果。基本思路是把开始角度和结束角度的差值分为N段，利用window.requestAnimationFrame依次执行动画。 比如从30°到90°，我给它分为6段，每次画10°。要注意canvas画这种动画过程一般是要重复地清空画布并重绘的，所以第一次我画的弧线范围就是30°~40°，第二次我画的弧线范围就是30°~50°，以此类推…… 基本的代码结构如下，具体代码请参考vue-awesome-progress v1.1.0版本，如果顺手帮忙点个star也是极好的。 12345678910111213141516animateDrawArc(canvas, ctx, startDeg, endDeg, nextDeg, step) { window.requestAnimationFrame(() =&gt; { // 清空画布 ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight); // 求下一个目标角度 nextDeg = this.getTargetDeg(nextDeg || startDeg, endDeg, step); // 画圆环 // 画文字 // 画进度弧线 // 画进度圆点 if (nextDeg !== endDeg) { // 满足条件继续调用动画，否则结束动画 this.animateDrawArc(canvas, ctx, startDeg, endDeg, nextDeg, step) } }} 缓动效果线性动画显得有点单调，可操作性不大，因此我考虑引入贝塞尔缓动函数easing，并且支持传入动画执行时间周期duration，增强了可定制性，使用体验更好。这里不列出实现代码了，请前往vue-awesome-progress查看。 12345678910111213141516171819202122&lt;vue-awesome-progress label=\"188人\" :duration=\"10\" easing=\"0,0,1,1\" /&gt;&lt;vue-awesome-progress label=\"36℃\" circle-color=\"#FF4949\" :line-color-stops=\"colorStops\" :angle-range=\"[60, 180]\" :duration=\"5\"/&gt;// 省略部分...&lt;vue-awesome-progress label=\"188人\" easing=\"1,0.28,0.17,0.53\" :duration=\"10\" /&gt;&lt;vue-awesome-progress label=\"36℃\" circle-color=\"#FF4949\" :line-color-stops=\"colorStops\" :angle-range=\"[60, 180]\" :duration=\"5\" easing=\"0.17,0.67,0.83,0.67\"/&gt; 可以看到，当传入不同的动画周期duration和缓动参数easing时，动画效果各异，完全取决于使用者自己。 其他效果当然根据组件支持的属性，我们也可以定制出其他效果，比如不显示文字，不显示圆点，弧线线宽与圆环线宽一样，不使用渐变色，不需要动画，等等。我们后续也会考虑支持更多能力，比如控制进度，数字动态增长等！具体使用方法，请参考vue-awesome-progress。 更新日志2020年04月10日更新 支持进度控制，只需要修改组件的属性值percentage即可。 2019年11月10日更新 由于我从业务场景出发做了这个组件，没有考虑到大部分场景都是传百分比控制进度的，因此在v1.4.0版本做了如下修正： 废弃angle-range，改用percentage控制进度，同时提供start-deg属性控制起始角度； with-gradient改为use-gradient 通过show-text控制是否显示进度文字 支持通过format函数自定义显示文字的规则 结语写完这个组件有让我感觉到，程序员最终不是输给了代码和技术的快速迭代，而是输给了自己的逻辑思维能力和数学功底。就vue-awesome-progress这个组件而言，根据这个思路，我们也能迅速开发出适用于React，Angular以及其他框架生态下的组件。工作三年有余，接触了不少框架和技术，经历了MVVM，Hybrid，小程序，跨平台，大前端，serverless的大火，也时常感慨“学不动了”，在这个快速演进的代码世界里常常感到失落。好在自己还没有丢掉分析问题的能力，而不仅仅是调用各种API和插件，这可能是程序员最宝贵的财富吧。前路坎坷，我辈当不忘初心，愿你出走半生，归来仍是少年！ 首发链接","link":"/用初中数学知识撸一个canvas环形进度条.html"},{"title":"耐人寻味的CSS属性font-family","text":"font-family是一个网站用户体验的第一入口，非常有必要花功夫来研究一下。我们首先需要了解衬线字体和无衬线字体，接着了解中英文的常用字体及其适用性。 衬线字体衬线（serif）的笔画有粗有细的变化，在每一笔画上都自有风格，笔画末端会有修饰，强调艺术感，适合用于博客，旅游，文化，艺术类网站。 无衬线字体无衬线（sans-serif）的字体工整方正，给人正式的感觉，适合政务类，企业类网站使用。 中文字体Windows simsun，宋体，也是windows下大部分浏览器的默认字体，font-size较大时清晰度不佳。 Microsoft Yahei，无衬线字体，微软雅黑，是微软委托中国方正设计的一款中文字体。 Mac OS STHeiti，华文黑体，OS X 10.6之前的简体中文系统界面默认字体，也是目前Chrome游览器下的默认字体。 STXihei，华文细黑，比STHeiti文字更细。 Heiti SC，黑体-简，从 OS X 10.6 开始，黑体-简代替华文黑体用作简体中文系统界面默认字体，显示效果不错，但是喇叭口设计遭人诟病。 Hiragino Sans GB，冬青黑体，清新的专业印刷字体，小字号时足够清晰，拥有很多人的追捧。 PingFang SC，苹方，在Mac OS X EL Capitan上，苹果为中国用户打造，去掉了为人诟病的喇叭口。 Linux WenQuanYi Micro Hei，文泉驿微米黑，Linux最佳简体中文字体。 英文字体Windows Arial，无衬线西文字体，显示效果一般。 Tahoma，无衬线字体，显示效果比Arial要好。 Verdana，无衬线字体，优点在于它在小字上仍结构清晰端整、阅读辨识容易。 Mac OS Times New Roman，衬线字体，Mac平台Safari下默认的字体。 Helvetica、Helvetica Neue，被广泛使用。 San Francisco，与苹方一样，mac os最新的西文字体。 font-family设置原则 西文优先：西文字体中大多不包含中文，西文优先，中文紧随其后，这样就不会影响到中文字体的选择。 从新到旧：优先体验最好的字体，向下兼容。 兼容多种操作系统：考虑windows, mac os, android, linux等系统。 补充字体族：最后根据衬线serif或无衬线sans-serif来补充字体族，当所有设置的字体都找不到时，让操作系统有选择字体的方向。 font-family推荐1font-family: \"Helvetica Neue\", Helvetica, \"PingFang SC\", Tahoma, \"Hiragino Sans GB\", \"Heiti SC\", Arial, \"Microsoft YaHei\", \"WenQuanYi Micro Hei\", sans-serif; 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/耐人寻味的CSS属性font-family.html"},{"title":"耐人寻味的CSS属性white-space","text":"《耐人寻味的CSS属性white-space》，本文说的white-space是一个控制换行和空白处理的CSS属性。我曾经被这个属性烦死，一直没记住，今天决定还是写下来好好琢磨下。 属性值normal默认值，正常换行，空白和换行符会被浏览器忽略。啥意思呢？ 正常换行的意思是，单词间会正常换行，如果下一个单词太长，不足以在当前行剩余部分完整展示，则会在下一行显示。哪些情况算一个单词呢？ 一个中文字 一个英文单词 1234// 这是两个单词Tusi Blog// 这只算一个单词TusiBlog 连续的数字或符号也只算一个单词 12// 这只算一个单词，如果超长也不会换行，会挤出横向滚动条10000000000000000000000+2000000000000000000*200000000000000 空白和换行符会被浏览器忽略。就是你输入连续的空格，只会表现出一个空格的效果；如果敲了回车，也不会换行。 1234&lt;!-- 代码 --&gt;&lt;div&gt;00000000 00000000000000000&gt;&lt;/div&gt;&lt;!-- 实际效果 --&gt;00000000 00000000000000000 pre 行为方式类似HTML中的pre标签。pre标签一般用来包裹源代码。 不会自动换行（想想，你写代码时，不回车会换行吗？），除非在文本中遇到换行符（敲了回车）或使用了br标签。 空白会被浏览器保留。意思就是连续的空格会被保留，不会合并成一个。 nowrap 不换行，内容再多也不换行。 忽略换行符，也就是说回车也不会换行，直到遇到br标签为止。 pre-wrap 正常换行 连续的空白符会被保留 换行符（回车）也是有效的 pre-line 正常换行 连续空白符会被合并成一个 换行符（回车）也有效 inherit继承父元素的white-space属性值 总结可以从几个方面来对比下这几种属性值的差异。 是否正常换行 是否合并连续空白符 换行符是否有效 normal 是 是 否 pre 否 否 是 nowrap 否 是 否 pre-wrap 是 否 是 pre-line 是 是 是 妈呀，还是挺难记的，多多复习！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/耐人寻味的CSS属性white-space.html"},{"title":"自动化部署的一小步，前端搬砖的一大步","text":"在nodejs日渐普及的大背景下，前端工程化的发展可谓日新月异。构建打包这种日常任务脚本化已经是常态了，webpack和gulp已经家喻户晓自然不必多说，而持续集成/持续交付/持续部署也越来越得到各个前端Team的重视，业界也有了很多成熟的概念或者方案，如Hudson, Jenkins, Travis CI, Circle CI, DevOps, git hook。 然而对于小白来讲，如果直接上手这些内容，很容易混淆概念，陷入迷茫。如果为了用Jenkins而用Jenkins，那不是我的做事风格，我必须搞清楚这项技术能给我带来什么。所以我干脆回归问题本质，从最简单的工作流入手，先解决手动部署的效率问题。 前面说这么多废话纯属凑字数，对了，本文讲的内容比较简单，不适合工作流已经很完善的同学 自动构建构建不是本文的重点，也不是一篇短文能够讲清楚的，这里就一笔带过了。 构建工具使用主流的构建工具如webpack, gulp, rollup等。 构建目标通过脚本化的形式组织代码检查，编译，压缩，混淆，资源处理，devServer等工作流事务。 手动部署踩过的坑本人曾经也尝试过两种手动部署的方法。 搬砖模式，将构建完毕的文件夹通过xftp传输到服务器/usr/share/nginx/html目录下。 将构建完毕的文件夹用git分支管理起来，推送到远程仓库，然后在linux服务器上拉取这部分代码。 第一种方法显然已经属于刀耕火种模式了，不过我竟然用了很久。唉，没办法，业务缠身的我只能挤出时间来优化工作流。 第二种方法我自己私下也用过，后来一想，好像可以用git hook来改造优化下，也是实现自动部署的好方法。有兴趣的同学可以试试git hook。 自动部署写脚本先写个自动构建部署的脚本，主要是包含了切git分支，拉取最新代码，构建打包，传输文件到服务器这些步骤。 scp 命令用于 Linux 之间复制文件和目录 12345#!/bin/bashgit checkout developgit pullnpm run build:testscp -r ./dist/. username@162.81.49.85:/usr/share/nginx/html/projectname/ ps：ip已经被我胡乱改了一把，别试着攻击我了。 然而我发现在使用部署脚本的过程中，每次操作都要输入密码，很烦人。 ssh认证虽然很讨厌输密码，但是密码是安全的保证，如果不输入密码，只能通过ssh安全访问了。 首先是在自己工作电脑的~/.ssh目录下创建密钥对。 1ssh-keygen -t rsa 根据个人情况按需修改密钥对的文件名，输入密码时回车即可，代表不需要使用密码 接着要把公钥传输到服务器上 1scp ~/.ssh/id_rsa.pub username@162.81.49.85:/home/username/.ssh/authorized_keys 如果服务器已经存在authorized_keys文件，那么可以直接在服务器上修改authorized_keys文件，在文件末加入你自己的id_rsa.pub内容即可。 然后我们再修改部署脚本，改用ssh认证方式向linux服务器传输文件。 1234#!/bin/bashgit checkout developnpm run build:testscp -i ~/.ssh/id_rsa -r ./dist/. username@162.81.49.85:/usr/share/nginx/html/projectname/ scp的-i参数指定传输时使用的密钥文件，这样就可以通过ssh安全访问，而不用再每次输入密码了。-r参数则是recursive，代表递归复制整个目录。 最后我们可以修改下package.json，通过npm scripts来执行sh 123\"scripts\": { \"deploy:test\": \"deploy-test.sh\"} 配合vscode的npm scripts快捷方式，用起来就很舒服了。 注意，如果linux文件权限不够也可能报错的，别忘了给authorized_keys文件赋予权限，拥有者可读可写即可。 1chmod 600 authorized_keys 好了，按下那个deploy:test，静静等待一会吧。此时别忘了扭扭脖子，按按腰啊，程序员还是要注意身体，对自己好一点。 随着bash窗口的自动关闭，部署工作也画上了句号。 last but not least这里还要考虑的一个问题是，部署过程中会不会造成用户访问问题？ 答案是会影响用户访问。比如部署脚本执行过程中，已经替换了index.html，正在部署静态资源，此时用户正好进入网站，新的index.html却访问不到新的静态资源，网页白屏报错。 解决方法是先上静态资源，再上页面。因为静态资源经webpack构建后都带上了hash值，先上静态资源不会影响原有的版本，所以我们还需要再优化下部署脚本，分解下传输过程。 很头疼的是scp命令竟然不能忽略文件，这就有点麻烦了。 如果打包后的dist根目录文件不算很多，可以考虑手动列举的方式来排列传输顺序。举个例子： 123456789#!/bin/bashgit checkout developgit pullnpm run build:testscp -i ~/.ssh/id_rsa -r ./dist/static username@162.81.49.85:/usr/share/nginx/html/projectname/scp -i ~/.ssh/id_rsa ./dist/favicon.ico username@162.81.49.85:/usr/share/nginx/html/projectname/favicon.icoscp -i ~/.ssh/id_rsa ./dist/element-icons.ttf username@162.81.49.85:/usr/share/nginx/html/projectname/element-icons.ttfscp -i ~/.ssh/id_rsa ./dist/element-icons.woff username@162.81.49.85:/usr/share/nginx/html/projectname/element-icons.woffscp -i ~/.ssh/id_rsa ./dist/index.html username@162.81.49.85:/usr/share/nginx/html/projectname/index.html 如果觉得这样很傻X，那么可以考虑下rsync了，rsync是可以通过--exclude忽略文件的，这样的话理论上只需要写两条传输命令即可，也不用考虑后续构建可能会新增的内容。不过在windows和linux之间用rsync还是蛮复杂的，留给各位大佬自己探索啦。 首发链接 我是Tusi，一个创业公司前端小leader，每天依然为写不完的业务代码烦恼，在打磨产品道路上沉淀技术，探索成长路线。如果你与我一样，正在思考自己的技术成长与价值，欢迎加我微信交流探讨，微信号laobaife。我会在公众号前端司南和小程序Tusi博客同步博客内容，快来撩我！","link":"/自动化部署的一小步，前端搬砖的一大步.html"},{"title":"自定义滑块Range Slider","text":"原生的组件虽然长得丑，但是提供给我们的能力是很多的。原生的事件以及属性，这些是某些UI框架不能给我们的。所以，基于原生的一些组件来做一些定制化修改是有必要的。首先，我们来看一个常用的滑块组件。 场景我在一个视频类demo中，使用到了滑块组件（也就是range类型的input组件）。 1&lt;input type=\"range\" value=\"{{currentTime}}\" min=\"0\" max=\"{{duration}}\" step=\"1\" (input)=\"progressChange($event)\"&gt; 未做定制的效果如下： 用到input的有两处，一个是视频的进度条，一个是音量条。不能说这个样式很丑，但是还有美化的空间。那么我们如何来修改input默认的样式呢？ 自定义样式input组件主要由两部分组成，轨道和滑块，它们都是伪元素。我们只要针对这两个伪元素来做试探性修改css就可以看到效果了。 123456789// 轨道的伪元素，分别对应chrome，firefox，IE浏览器。// ::-webkit-slider-runnable-track// ::-moz-range-track// ::-ms-track// 滑块的伪元素，分别对应chrome，firefox，IE浏览器。// ::-webkit-slider-thumb// ::-moz-range-thumb// ::-ms-thumb 去除浏览器的默认样式每个浏览器对range类的input有不一样的默认样式，我们首先来去掉这种默认样式。 1234567891011input[type=range] { // 去除浏览器默认的样式 -webkit-appearance: none; -moz-appearance: none; width: 300px; border-radius: 10px; &amp;:focus { // 去除落焦时的外边框效果 outline: none; }} 修改轨道css样式的修改方式如下所示，这里只给出chrome的修改内容给大家参考，具体想要的样式效果当然由自己而定。 12345input[type=range]::-webkit-slider-runnable-track { height: 6px; border-radius: 10px; /*将轨道设为圆角的*/ background: #ee2828;} 修改滑块css废话不多说，上代码。 12345678910input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; -moz-appearance: none; width: 10px; height: 10px; border-radius: 50%; position: relative; top: -2px; background: #fff;} 修改完毕，我们来看一下效果图。感觉还不错吧，加以修改，相信能做出更美的效果。 放一个demo链接，大家自行查阅。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/自定义滑块Range Slider.html"},{"title":"解决Chrome的表单自动填充问题","text":"一般的浏览器都会默认开启一个表单自动填充的功能。这给很多用户带来了方便。但是对于项目开发者来说，有时候这就是噩梦。对安全性有考虑的项目，应该都会考虑到禁用这种自动填充的功能。否则，一个用户登录后，浏览器记住了用户名和密码。当另一个人使用这台电脑时，他肯定不用输入什么，就可以登入别人的账号，这可是很危险的事情。 问题背景当我使用原始的表单成功登录一次后时，再次打开浏览器，什么都没有输入，就出现了这样的现象。 浏览器帮忙记住了用户名和密码。有的人会说，这个OK啊，让用户把浏览器的填充表单的功能禁止掉不就行了？ what？你指望让用户来完成本应该由你的程序完成的事情？领盒饭走人吧！ so，怎么解决这个问题呢？ 解决过程首先想到的是通过autocomplete=”off”属性来禁止自动填充，然而发现好像没有起到作用。 接下来我查到的信息是，浏览器会寻找表单中的输入框，自动填充。 12&lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;password&quot;&gt; 灵机一动，我想到在我的真实表单输入框前面放一个隐藏的输入框，如果这个隐藏的输入框代替真实的输入框被浏览器填充，那么问题不久解决了吗。于是，代码变成这样的。 12345678910111213141516171819&lt;el-form :model=&quot;loginForm&quot; :rules=&quot;loginRules&quot; ref=&quot;loginForm&quot; class=&quot;login-form&quot; autocomplete=&quot;off&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;account&quot; style=&quot;display:none;&quot; autocomplete=&quot;off&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; style=&quot;display:none;&quot; autocomplete=&quot;off&quot;/&gt; &lt;div class=&quot;formGroup&quot;&gt; &lt;label class=&quot;login-label&quot;&gt;用户名&lt;/label&gt; &lt;el-form-item prop=&quot;account&quot;&gt; &lt;el-input class=&quot;login-input&quot; type=&quot;text&quot; v-model=&quot;loginForm.account&quot; auto-complete=&quot;off&quot; placeholder=&quot;请输入用户名&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/div&gt; &lt;div class=&quot;formGroup&quot;&gt; &lt;label class=&quot;login-label&quot;&gt;密码&lt;/label&gt; &lt;el-form-item prop=&quot;password&quot;&gt; &lt;el-input class=&quot;login-input&quot; type=&quot;password&quot; v-model=&quot;loginForm.password&quot; auto-complete=&quot;off&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/div&gt; &lt;div class=&quot;formGroup&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;login-btn&quot; id=&quot;btnLogin&quot; @click=&quot;login&quot; v-loading=&quot;logining&quot;&gt;登录&lt;/button&gt; &lt;/div&gt;&lt;/el-form&gt; 再次尝试，发现打开登录页后，浏览器没有填充我的el-input了，顿时感觉轻松了下来。然而，当我点击密码框的时候，出现了密码列表。。。坑爹啊！ 还能怎么办，接着寻找解决方案吧！接下来找了很多方法，尝试后都不是有效的。 于是我尝试先去掉自动填充后的屎黄色。。。 这个填充色是由浏览器伪类input:-webkit-autofill来实现的 于是我加了这些代码 123input:-webkit-autofill { background-color: #fff;} 但是仍然没有去掉浏览器自带的填充背景色。我就想是不是没有加!important。最后加上了也没有用。看来并不能覆盖掉自带的这个样式属性啊。 在网上搜索后，发现了一个神解决方法，使用盒子阴影来盖住屎黄色，真的可以做到。为这位网友的机智点赞！ 1234input:-webkit-autofill { box-shadow: 0 0 0px 1000px white inset; -webkit-box-shadow: 0 0 0px 1000px white inset;} 虽然解决了这个屎黄色背景的问题，但是没有从根本上解决我的需求。接下来的寻找答案的过程中，发现了一个奇妙的解决方案。 1&lt;el-input class=&quot;login-input&quot; type=&quot;password&quot; v-model=&quot;loginForm.password&quot; auto-complete=&quot;new-password&quot; placeholder=&quot;请输入密码&quot;&gt;&lt;/el-input&gt; 就是这么简单，去掉了自动填充的烦人功能。说是autocomplete除了on，off以外的值就可以做到。但是我发现除了new-password，没有其他的值可以有效，Amazing！ 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/解决Chrome的表单自动填充问题.html"},{"title":"解决npm install卡住不动的小尴尬","text":"遇到的问题1npm install -g @angular/cli 安装angular cli工具时，发现进度条一直卡住不动，相信很多朋友也遇到过。原因应该是国内的网络连接npm速度较慢，甚至很多东西都无法下载安装。那么如何解决这个问题呢？ 方案一：安装cnpm镜像这个是比较常用的方法，我首先也是使用了这个方法。cnpm的安装方法，参考http://npm.taobao.org/ 1npm install -g cnpm --registry=https://registry.npm.taobao.org cmd输入以上命令就可以了，然后输入 1cnpm install -g @angular/cli 后面的操作跟不使用镜像的操作是差不多的。但是笔者在后续使用过程中遇到了一些问题，运行ng eject后发生了一些错误，所以放弃了这个方案，采用了方案二。 方案二：使用代理registry在网上查阅了一些资料后，决定使用代理的方式，方法也很简单，就是 1npm config set registry https://registry.npm.taobao.org 然后后续的install等命令还是通过npm运作，而不是cnpm。 有点小强迫症的我还是喜欢npm install 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/解决npm install卡住不动的小尴尬.html"},{"title":"解决办公IP变化后git无法推送远程仓库的问题","text":"最近公司乔迁新址，在提交代码时遇到了无法git push的问题。报错如下： 12345The RSA host key for github.com has changed,and the key for the corresponding IP address 42.243.156.48is unknown. This could either mean thatDNS SPOOFING is happening or the IP address for the hostand its host key have changed at the same time. 经检查，ssh密钥对是没有问题的，问题出在了known_hosts文件，办公ip变化了，而known_hosts中保留的是原来的ip，导致不识别当前ip而验证失败。 解决方法也很简单，首先找到.ssh目录，我的是 1C:\\Users\\Jiang.Wenbin\\.ssh 我们删除掉known_hosts文件，然后打开git bash，视个人情况选择性输入如下命令： 123456// 连接githubssh -T git@github.com// 连接giteessh -T git@gitee.com// 连接coding.netssh -T git@git.coding.net 在弹出询问后输入yes即可。 这里在连接github时比较特殊，遇到了一个报错 1git@github.com: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password). 其实是我开启了网络代理或者fanqiang工具引起的，关闭后正常了。 再次git push代码就没问题了。 首发链接","link":"/解决办公IP变化后git无法推送远程仓库的问题.html"},{"title":"解读闭包，这次从ECMAScript词法环境，执行上下文说起","text":"对于x年经验的前端仔来说，项目也做了好些个了，各个场景也接触过一些。但是假设真的要跟面试官敞开来撕原理，还是有点慌的。看到很多大神都在手撕各种框架原理还是有点羡慕他们的技术实力，羡慕不如行动，先踏踏实实啃基础。嗯…今天来聊聊闭包！ 讲闭包的文章可能大家都看了几十篇了吧，而且也能发现，一些文章（我没说全部）行文都是一个套路，基本上都在关注两个点，什么是闭包，闭包举例，很有搬运工的嫌疑。我看了这些文章之后，一个很大的感受是：如果让我给别人讲解闭包这个知识点，我能说得清楚吗？我的依据是什么？可信度有多大？我觉得我是怀疑我自己的，否定三连估计是妥了。 不同的阶段做不同的事，当有一些基础后，我们还是可以适当地研究下原理，不要浮在问题表面！那么技术水平一般的我们，应该怎么办，怎么从这些杂乱的文章中突围？我觉得一个办法是从一些比较权威的文档上去找线索，比如ES规范，MDN，维基百科等。 关于闭包（closure），总是有着不同的解释。 第一种说法是，闭包是由函数以及声明该函数的词法环境组合而成的。这个说法来源于MDN-闭包。 另外一种说法是，闭包是指有权访问另外一个函数作用域中的变量的函数。 从我的理解来看，我认为第一个说法是正确的，闭包不是一个函数，而是函数和词法环境组成的。那么第二种说法对不对呢？我觉得它说对了一半，在闭包场景下，确实存在一个函数有权访问另外一个函数作用域中的变量，但闭包不是函数。 这就完了吗？显然不是！解读闭包，这次我们刨根究底（吹下牛逼）！ 本文会直接从ECMAScript5规范入手解读JS引擎的部分内部实现逻辑，基于这些认知再来重新审视闭包。 回到主题，上文提到的词法环境（Lexical Environment）到底是什么？ 词法环境我们可以看看ES5规范第十章（可执行代码和执行上下文）中的第二节词法环境是怎么说的。 A Lexical Environment is a specification type used to define the association of Identifiers to specific variables and functions based upon the lexical nesting structure of ECMAScript code. 词法环境是一种规范类型（specification type），它定义了标识符和ECMAScript代码中的特定变量及函数之间的联系。 问题来了，规范类型（specification type）又是什么？specification type是Type的一种。从ES5规范中可以看到Type分为language types和specification types两大类。 language types是语言类型，我们熟知的类型，也就是使用ECMAScript的程序员们可以操作的数据类型，包括Undefined, Null, Number, String, Boolean和Object。 而规范类型（specification type）是一种更抽象的元值（meta-values），用于在算法中描述ECMAScript的语言结构和语言类型的具体语义。 A specification type corresponds to meta-values that are used within algorithms to describe the semantics of ECMAScript language constructs and ECMAScript language types. 至于元值是什么，我觉得可以理解为元数据，而元数据是什么意思，可以简单看看这篇知乎什么是元数据？为何需要元数据？ 总的来说，元数据是用来描述数据的数据。这一点就可以类比于，高级语言总要用一个更底层的语言和数据结构来描述和表达。这也就是JS引擎干的事情。 大致理解了规范类型是什么后，我们不免要问下：规范类型（specification type）包含什么？ The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record. 看到这里我好似明白了些什么，原来词法环境（Lexical Environment）和环境记录（Environment Record）都是一种规范类型（specification type），果然是更底层的概念。 先抛开List, Completion, Property Descriptor, Property Identifier等规范类型不说，我们接着看词法环境（Lexical Environment）这种规范类型。 下面这句解释了词法环境到底包含了什么内容： A Lexical Environment consists of an Environment Record and a possibly null reference to an outer Lexical Environment. 词法环境包含了一个环境记录（Environment Record）和一个指向外部词法环境的引用，而这个引用的值可能为null。 一个词法环境的结构如下： 123Lexical Environment + Outer Reference + Environment Record Outer Reference指向外部词法环境，这也说明了词法环境是一个链表结构。简单画个结构图帮助理解下！ Usually a Lexical Environment is associated with some specific syntactic structure of ECMAScript code such as a FunctionDeclaration, a WithStatement, or a Catch clause of a TryStatement and a new Lexical Environment is created each time such code is evaluated. 通常，词法环境与ECMAScript代码的某些特定语法结构（如FunctionDeclaration，WithStatement或TryStatement的Catch子句）相关联，并且每次评估此类代码时都会创建一个新的词法环境。 PS：evaluated是evaluate的过去分词，从字面上解释就是评估，而评估代码我觉得不是很好理解。我个人的理解是，评估代码代表着JS引擎在解释执行javascript代码。 我们知道，执行函数会创建新的词法环境。 我们也认同，with语句会“延长”作用域（实际上是调用了NewObjectEnvironment，创建了一个新的词法环境，词法环境的环境记录是一个对象环境记录）。 以上这些是我们比较好理解的。那么catch子句对词法环境做了什么？虽然try-catch平时用得还比较多，但是关于词法环境的细节很多人都不会注意到，包括我！ 我们知道，catch子句会有一个错误对象e 12345678910function test(value) { var a = value; try { console.log(b); // 直接引用一个不存在的变量，会报ReferenceError } catch(e) { console.log(e, arguments, this) }}test(1); 在catch子句中打印arguments，只是为了证明catch子句不是一个函数。因为如果catch是一个函数，显然这里打印的arguments就不应该是test函数的arguments。既然catch不是一个函数，那么凭什么可以有一个仅限在catch子句中被访问的错误对象e？ 答案就是catch子句使用NewDeclarativeEnvironment创建了一个新的词法环境（catch子句中词法环境的外部词法环境引用指向函数test的词法环境），然后通过CreateMutableBinding和SetMutableBinding将标识符e与新的词法环境的环境记录关联上。 有人会说，for循环中的initialization部分也可以通过var定义变量，和catch子句有什么本质区别吗？要注意的是，在ES6之前是没有块级作用域的。在for循环中通过var定义的变量原则上归属于所在函数的词法环境。如果for语句不是用在函数中，那么其中通过var定义的变量就是属于全局环境（The Global Environment）。 with语句和catch子句中建立了新的词法环境这一结论，证据来源于上文中一句话“a new Lexical Environment is created each time such code is evaluated.”具体细节也可以看看12.10 The with Statement和12.14 The try Statement。 Environment Record了解了词法环境（Lexical Environment），接下来就说说词法环境中的环境记录(Environment Record)吧。环境记录与我们使用的变量，函数息息相关，可以说环境记录是它们的底层实现。 规范描述环境记录的内容太长，这儿就不全部复制了，请直接打开ES5规范第10.2.1节阅读。 There are two kinds of Environment Record values used in this specification: declarative environment records and object environment records. // 省略一大段 从规范中我们可以看到环境记录(Environment Record)分为两种： declarative environment records 声明式环境记录 object environment records 对象环境记录 ECMAScript规范约束了声明式环境记录和对象环境记录都必须实现环境记录类的一些公共的抽象方法，即便他们在具体实现算法上可能不同。 这些公共的抽象方法有： HasBinding(N) CreateMutableBinding(N, D) SetMutableBinding(N,V, S) GetBindingValue(N,S) DeleteBinding(N) ImplicitThisValue() 声明式环境记录还应该实现两个特有的方法： CreateImmutableBinding(N) InitializeImmutableBinding(N,V) 关于不可变绑定（ImmutableBinding），在规范中有这么一段比较细致的场景描述： If strict is true, then Call env’s CreateImmutableBinding concrete method passing the String “arguments” as the argument.Call env’s InitializeImmutableBinding concrete method passing “arguments” and argsObj as arguments.Else,Call env’s CreateMutableBinding concrete method passing the String “arguments” as the argument.Call env’s SetMutableBinding concrete method passing “arguments”, argsObj, and false as arguments. 也就是说，只有严格模式下，才会对函数的arguments对象使用不可变绑定。应用了不可变绑定（ImmutableBinding）的变量意味着不能再被重新赋值，举个例子： 非严格模式下可以改变arguments的指向： 123456function test(a, b) { arguments = [3, 4]; console.log(arguments, a, b)}test(1, 2)// [3, 4] 1 2 而在严格模式下，改变arguments的指向会直接报错： 1234567\"use strict\";function test(a, b) { arguments = [3, 4]; console.log(arguments, a, b)}test(1, 2)// Uncaught SyntaxError: Unexpected eval or arguments in strict mode 要注意，我这里说的是改变arguments的指向，而不是修改arguments。arguments[2] = 3这种操作在严格模式下是不会报错的。 所以不可变绑定（ImmutableBinding）约束的是引用不可变，而不是约束引用指向的对象不可变。 declarative environment records在我们使用变量声明，函数声明，catch子句时，就会在JS引擎中建立对应的声明式环境记录，它们直接将identifier bindings与ECMAScript的language values关联到一起。 object environment records对象环境记录（object environment records），包含Program, WithStatement，以及后面说到的全局环境的环境记录。它们将identifier bindings与某些对象的属性关联到一起。 看到这里，我自己就想问下：identifier bindings是啥？ 看了ES5规范中提到的环境记录(Environment Record)的抽象方法后，我有了一个大致的答案。 先简单看一下javascript变量取值和赋值的过程： 12var a = 1;console.log(a); 我们在给变量a初始化并赋值1的这样一个步骤，其实体现在JS引擎中，是执行了CreateMutableBinding（创建可变绑定）和SetMutableBinding（设置可变绑定的值）。 而在对变量a取值时，体现在JS引擎中，是执行了GetBindingValue（获取绑定的值），这些执行过程中会有一些断言和判断，也会牵涉到严格模式的判断，具体见10.2.1.1 Declarative Environment Records。 这里也省略了一些步骤，比如说GetIdentifierReference, GetValue(V), PutValue(V) 等。 按我的理解，identifier bindings就是JS引擎中维护的一组绑定关系，可以与javascript中的标识符关联起来。 The Global Environment全局环境（The Global Environment）是一个特殊的词法环境，在ECMAScript代码执行之前就被创建。全局环境中的环境记录(Environment Record)是一个对象环境记录（object environment record），它被绑定到一个全局对象（Global Object）上，体现在浏览器环境中，与Global Object关联的就是window对象。 全局环境是一个顶层的词法环境，因此全局环境不再有外部词法环境，或者说它的外部词法环境的引用是null。 在15.1 The Global Object一节也解释了Global Object的一些细节，比如为什么不能new Window()，为什么在不同的宿主环境中全局对象会有很大区别…… 执行上下文看了这些我们还是没有一个全盘的把握去解读闭包，不如接着看看执行上下文。在我之前的理解中，上下文应该是一个环境，包含了代码可访问的变量。当然，这显然还不够全面。那么上下文到底是什么？ When control is transferred to ECMAScript executable code, control is entering an execution context. Active execution contexts logically form a stack. The top execution context on this logical stack is the running execution context. 当程序控制转移到ECMAScript可执行代码（executable code）时，就进入了一个执行上下文（execution context），执行上下文是一个逻辑上的堆栈结构（Stack）。堆栈中最顶层的执行上下文就是正在运行的执行上下文。 很多人对可执行代码可能又有疑惑了，javascript不都是可执行代码吗？不是的，比如注释（Comment），空白符（White Space）就不是可执行代码。 An execution context contains whatever state is necessary to track the execution progress of its associated code. 执行上下文包含了一些状态（state），这些状态用于跟踪与之关联的代码的执行进程。每个执行上下文都有这些状态组件（Execution Context State Components）。 LexicalEnvironment：词法环境 VariableEnvironment：变量环境 ThisBinding：与执行上下文直接关联的this关键字 执行上下文的创建我们知道，解释执行global code或使用eval function，调用函数都会创建一个新的执行上下文，执行上下文是堆栈结构。 When control enters an execution context, the execution context’s ThisBinding is set, its VariableEnvironment and initial LexicalEnvironment are defined, and declaration binding instantiation (10.5) is performed. The exact manner in which these actions occur depend on the type of code being entered. 当控制程序进入执行上下文时，会发生下面这3个动作： this关键字的值被设置。 同时VariableEnvironment（不变的）和initial LexicalEnvironment（可能会变，所以这里说的是initial）被定义。 然后执行声明式绑定初始化操作。 以上这些动作的执行细节取决于代码类型（分为global code, eval code, function code三类）。 PS：通常情况下，VariableEnvironment和LexicalEnvironment在初始化时是一致的，VariableEnvironment不会再发生变化，而LexicalEnvironment在代码执行的过程中可能会变化。 那么进入global code，eval code，function code时，执行上下文会发生什么不同的变化呢？感兴趣的可以仔细阅读下10.4 Establishing an Execution Context。 词法环境的链表结构回顾一下上文，上文中提到，词法环境是一个链表结构。 众所周知，在理解闭包的时候，很多人都会提到作用域链（Scope Chain）这么一个概念，同时会引出VO（变量对象）和AO（活动对象）这些概念。然而我在阅读ECMAScript规范时，通篇没有找到这些关键词。我就在想，词法环境的链表结构是不是他们说的作用域链？VO，AO是不是已经过时的概念？但是这些概念又好像成了“权威”，一搜相关的文章，都在说VO, AO，我真的也要这样去理解吗？ 在ECMAScript中，找到8.6.2 Object Internal Properties and Methods一节中的Table 9 Internal Properties Only Defined for Some Objects，的确存在[[Scope]]这么一个内部属性，按照Scope单词的意思，[[Scope]]不就是函数作用域嘛！ 在这个Table中，我们可以明确看到[[Scope]]的Value Type Domain一列的值是Lexical Environment，这说明[[Scope]]就是一种词法环境。我们接着看看Description： A lexical environment that defines the environment in which a Function object is executed. Of the standard built-in ECMAScript objects, only Function objects implement [[Scope]]. 仔细看下，[[Scope]]是函数对象被执行时所在的环境，而且只有函数实现了[[Scope]]属性，这意味着[[Scope]]是函数特有的属性。 所以，我是不是可以理解为：作用域链（Scope Chain）就是函数执行时能访问的词法环境链。而广义上的词法环境链表不仅包含了作用域链，还包括WithStatement和Catch子句中的词法环境，甚至包含ES6的Block-Level词法环境。这么看来，ECMAScript是非常严谨的！ 而VO，AO这两个相对陈旧的概念，由于没有官方的解释，所以基本上是“一千个读者，一千个哈姆雷特”了，我觉得可能这样理解也行： VO是词法分析（Lexical Parsing）阶段的产物 AO是代码执行（Execution）阶段的产物 ES5及ES6规范中是没有这样的字眼的，所以干脆忘掉VO, AO吧！ 闭包什么是闭包？文章最开始提到了闭包是由函数和词法环境组成。这里再引用一段维基百科的闭包解释佐证下。 在计算机科学中，闭包（英语：Closure），又称词法闭包（Lexical Closure）或函数闭包（function closures），是在支持头等函数的编程语言中实现词法绑定的一种技术。闭包在实现上是一个结构体，它存储了一个函数（通常是其入口地址）和一个关联的环境（相当于一个符号查找表）。环境里是若干对符号和值的对应关系，它既要包括约束变量（该函数内部绑定的符号），也要包括自由变量（在函数外部定义但在函数内被引用），有些函数也可能没有自由变量。闭包跟函数最大的不同在于，当捕捉闭包的时候，它的自由变量会在捕捉时被确定，这样即便脱离了捕捉时的上下文，它也能照常运行。 这是站在计算机科学的角度解释什么是闭包，当然这同样适用于javascript！ 里面提到了一个词“自由变量”，也就是闭包词法环境中我们重点关注的变量。 Chrome如何定义闭包？Chrome浏览器似乎已经成为了前端的标准，那么在Chrome浏览器中，是如何判定闭包的呢？不妨来探索下！ 1234567891011function test() { var a = 1; function increase() { debugger; var b = 2; a++; return a; }; increase();}test(); 我把debugger置于内部函数increase中，调试时我们直接看右侧的高亮部分，可以发现，Scope中存在一个Closure（闭包），Closure的名称是外部函数test的函数名，闭包中的变量a是在函数test中定义的，而变量b是作为本地变量处于Local中。 PS: 关于本地变量，可以参见localEnv。 假设我在外部函数test中再定义一个变量c，但是在内部函数increase中不引用它，会怎么样呢？ 123456789101112function test() { var a = 1; var c = 3; // c不在闭包中 function increase() { debugger; var b = 2; a++; return a; }; increase();}test(); 经验证，内部函数increase执行时，变量c没有在闭包中。 我们还可以验证，如果内部函数increase不引用任何外部函数test中的变量，就不会产生闭包。 所以到这里，我们可以下这样一个结论，闭包产生的必要条件是： 存在函数嵌套； 嵌套的内部函数必须引用在外部函数中定义的变量； 嵌套的内部函数必须被执行。 面试官最喜欢问的闭包在面试过程中，我们通常被问到的闭包场景是：内部函数引用了外部函数的变量，并且作为外部函数的返回值。这是一种特殊的闭包，举个例子看下： 123456789101112131415161718function test() { var a = 1; function increase() { a++; }; function getValue() { return a; } return { increase, getValue }}var adder = test();adder.increase(); // 自增1adder.getValue(); // 2adder.increase();adder.getValue(); // 3 在这个例子中，我们发现，每调用一次adder.increase()方法后，a的值会就会比上一次增加1，也就是说，变量a被保持在内存中没有被释放。 那么这种现象背后到底是怎么回事呢？ 闭包分析既然闭包涉及到内存问题，那么不得不提一嘴V8的GC（垃圾回收）机制。 我们从书本上了解最多的GC策略就是引用计数，但是现代主流VM（包括V8, JVM等）都不采用引用计数的回收策略，而是采用可达性算法。 引用计数让人比较容易理解，所以常见于教材中，但是可能存在对象相互引用而无法释放其内存的问题。而可达性算法是从GC Roots对象（比如全局对象window）开始进行搜索存活（可达）对象，不可达对象会被回收，存活对象会经历一系列的处理。 关于V8 GC的一些算法细节，有一篇文章讲得特别好，作者是洗影，非常建议去看看，已附在文末的参考资料中。 而在我们关注的这种特殊闭包场景下，之所以闭包变量会保持在内存中，是因为闭包的词法环境没有被释放。我们先来分析下执行过程。 12345678910111213141516function test() { var a = 1; function increase() { a++; }; function getValue() { return a; } return { increase, getValue }}var adder = test();adder.increase();adder.getValue(); 初始执行global code，创建全局执行上下文，随之设置this关键词的值为window对象，创建全局环境（Global Environment）。全局对象下有adder, test等变量和函数声明。 开始执行test函数，进入test函数执行上下文。在test函数执行过程中，声明了变量a，函数increase和getValue。最终返回一个对象，该对象的两个属性分别引用了函数increase和getValue。 退出test函数执行上下文，test函数的执行结果赋值给变量adder，当前执行上下文恢复成全局执行上下文。 调用adder的increase方法，进入increase函数的执行上下文，执行代码使变量a自增1。 退出increase函数的执行上下文。 调用adder的getValue方法，其过程与调用increase方法的过程类似。 对整个执行过程有了一定认识后，我们似乎也很难解释为什么闭包中的变量a不会被GC回收。只有一个事实是很清楚的，那就是每次执行increase和getValue方法时，都依赖函数test中定义的变量a，但仅凭这个事实作为理由显然也是不具有说服力。 这里不妨抛出一个问题，代码是如何解析a这个标识符的呢？ 通过阅读规范，我们可以知道，解析标识符是通过GetIdentifierReference(lex, name, strict)，其中lex是词法环境，name是标识符名称，strict是严格模式的布尔型标志。 那么在执行函数increase时，是怎么解析标识符a的呢？我们来分析下！ 首先，让lex的值为函数increase的localEnv（函数的本地环境），通过GetIdentifierReference(lex, name, strict)在localEnv中解析标识符a。 根据GetIdentifierReference的执行逻辑，在localEnv并不能解析到标识符a（因为a不是在函数increase中声明的，这很明显），所以会转到localEnv的外部词法环境继续查找，而这个外部词法环境其实就是increase函数的内部属性[[Scope]]（这一点我是从仔细看了多遍规范定义得出的），也就是test函数的localEnv的“阉割版”。 回到执行函数test那一步，执行完函数test后，函数test中localEnv中的其他变量的binding都能在后续GC的过程中被释放，唯独a的binding不能被释放，因为还有其他词法环境（increase函数的内部属性[[Scope]]）会引用a。 闭包的词法环境和函数test执行时的localEnv是不一样的。函数test执行时，其localEnv会完完整整地重新初始化一遍，而退出函数test的执行上下文后，闭包词法环境只保留了其环境记录中的一部分bindings，这部分bindings会被其他词法环境引用，所以我称之为“阉割版”。 这里可能会有朋友提出一个疑问（我也这样问过我自己），为什么adder.increase()是在全局执行上下文中被调用，它执行时的外部词法环境仍然是test函数的localEnv的“阉割版”？ 这就要回到外部词法环境引用的定义了，外部词法环境引用指向的是逻辑上包围内部词法环境的词法环境！ The outer reference of a (inner) Lexical Environment is a reference to the Lexical Environment that logically surrounds the inner Lexical Environment. 闭包的优缺点网上的文章关于这一块还是讲得挺详细的，本文就不再举例了。总的来说，闭包有这么一些优点： 变量常驻内存，对于实现某些业务很有帮助，比如计数器之类的。 架起了一座桥梁，让函数外部访问函数内部变量成为可能。 私有化，一定程序上解决命名冲突问题，可以实现私有变量。 闭包是双刃剑，也存在这么一个比较明显的缺点： 存在这样的可能，变量常驻在内存中，其占用内存无法被GC回收，导致内存溢出。 小结本文从ECMAScript规范入手，一步一步揭开了闭包的神秘面纱。首先从闭包的定义了解到词法环境，从词法环境又引出环境记录，外部词法环境引用和执行上下文等概念。在对VO, AO等旧概念产生怀疑后，我选择了从规范中寻找线索，最终有了头绪。解读闭包时，我寻找了多方资料，从计算机科学的闭包通用定义入手，将一些关键概念映射到javascript中，结合GC的一些知识点，算是有了答案。 写这篇文章花了不少时间，因为涉及到ECMAScript规范，一些描述必须客观严谨。解读过程必然存在主观成分，如有错误之处，还望指出！ 最后，非常建议大家在有空的时候多多阅读ECMAScript规范。阅读语言规范是一个很好的解惑方式，能让我们更好地理解一门语言的基本原理。就比如假设我们不清楚某个运算符的执行逻辑，那么直接看语言规范是最稳妥的！ 结尾附上一张可以帮助你理解ECMAScript规范的图片。 如果方便的话，帮我点个赞哟，谢谢！欢迎加我微信laobaife交流，技术会友，闲聊亦可。 参考资料 ECMAScript规范 维基百科：一等对象（First-class object） 维基百科：头等函数（first-class function） 维基百科：闭包 解读 V8 GC Log（二）: 堆内外内存的划分与 GC 算法 主流的垃圾回收机制都有哪些? V8 内存浅析 垃圾回收机制中，引用计数法是如何维护所有对象引用的？ A tour of V8: Garbage Collection","link":"/解读闭包，这次从ECMAScript词法环境，执行上下文说起.html"},{"title":"「前端必看」这篇Nginx反向代理技巧，助你准时下班陪女神","text":"最近同事小G总是闷闷不乐，让我感觉慌慌的，难道是我平时压榨小G了？我转念一想，不应该啊，工作量事先都评估好了，没道理天天加班啊。 坐下来聊聊后，小G向我吐槽说，”改bug效率太低了，每天加班改bug，都不能早点下班陪女神！” 我深吸一口气，“卧槽，忘记传授小G秘籍了…” 在一步步提问引导下，我搞清楚了小G的问题所在…… 问题引入相信很多前端朋友在线上debug时都吐槽过npm run dev或npm start太费时的问题吧（这里提到的两条npm脚本代指启动前端dev server）。 由于环境差异，开发环境和生产环境下，我们访问的后端服务域名是不一样的。那么当我们debug生产问题时，难免还是要修改下webpack devServer的proxy配置指向生产环境域名，然后重启devServer，这个过程一般比较缓慢。 有些时候可能测试环境也能复现bug，那么只要接入测试环境也能排查问题原因。但这不是本文关注的重点，本文主要说说如何提高debug效率。 webpack-dev-server反向代理0202年了，如果作为开发者的你还不了解反向代理，那么是很有必要去关注下了。 我们知道，跨域对于前端而言是一个无法逃避的问题。如果不想在开发时麻烦后端同事，前端仔必须通过自己的手段解决跨域问题。当然，你帮后端同事买包辣条，他给你通过CORS解决跨域也是可以的。 还好，webpack-dev-server帮我们解决了这个痛点，它基于Node代理中间件http-proxy-middleware实现。 配置起来也非常简单： 12345678910proxy: { // 需要代理的url规则 \"/api\": { target: \"https://dev.xxx.tech\", // 反向代理的目标服务 changeOrigin: true, // 开启后会虚拟一个请求头Origin pathRewrite: { \"^/api\": \"\" // 重写url，一般都用得到 } }} 这个时候小G打断了我，表示不理解。 反向代理是个什么意思呢？举个例子，我想找马云借钱，马云是肯定不会借给我的。 但是我有一个好朋友老张，我于是找老张借了1W块，但是我没想到这个朋友和马云关系不错，他从马云那里借了1W块，然后转给我。也就是说，我不知道我借到的钱实际来源于哪里，我只知道我从我朋友老张那里借到了钱，老张给我做了一层反向代理。 具体到开发中就是，我前端仔要从https://dev.xxx.tech这个域名调用后端接口，但是我前端开发服务运行在http://localhost:8080，直接调用后端接口会跨域，被浏览器同源策略阻塞，所以这条路是走不通的。 因此我需要从前端服务器做个代理，这样我就可以用http://localhost:8080/api/user/login这种形式调用接口，就好像在调前端自己的接口一样（因为我访问的是前端的url嘛）。 然而实际上是前端服务器做了一层代理，把http://localhost:8080/api/user/login这个接口代理到https://dev.xxx.tech/user/login。这对前端开发者而言是无感的。 简单总结就是：反向代理隐藏了真实的服务端；相反地，正向代理隐藏了真实的客户端，类似kexueshangwang这种。 debug痛点问题来了，假设我们正在feature分支开发需求，这个时候上头通知要即时排查和解决一个生产bug，假设生产环境域名为https://production.xxx.tech。 我们一般会stash代码，然后切fix分支，修改target的值为&quot;https://production.xxx.tech&quot;，然后重新运行npm start重启开发服务器接入生产环境，静静等待，放空自己…… 这个时候我们就会幻想“唉，要是不用等这么久就好了！” 是的，其实很多时候，一个bug并不复杂，可能解决bug只要1分钟，然而我们切换环境重新运行开发服务器就花了1分钟（大多数情况可能超过这个时间）。那么如何解决这个问题？ 代理层解耦是的，有的同学已经想到了，只要把代理服务器抽离出来，问题便可以得到解决，我不再需要把前端编译过程和服务代理目标捆绑在一起。在生产环境，这种Nginx转发对大多数人而言早已是熟门熟路，然而很少有人会尝试在开发环境中也这么做。那么不妨这样试试呢！ 下载Nginx我们照常下载Nginx，选择Windows稳定版即可。 固定前端代理为了避免在debug线上问题时需要切换proxy target而重新运行npm start，我们在前端层把proxy target固定下来。比如我固定访问127.0.0.1:8090（当然，实际上访问哪个端口可以视个人情况调整）。 123456789proxy: { \"/api\": { target: \"127.0.0.1:8090\", // 固定代理目标 changeOrigin: true, pathRewrite: { \"^/api\": \"\" } }} 然后从127.0.0.1:8090肯定是无法访问到后端接口的，请接着往下看！ Nginx代理由于前端的接口访问已经固定为127.0.0.1:8090，那么剩下的工作就交给Nginx吧。我们只要在Nginx中监听本地8090端口，把请求统统转发给目标服务器即可，配置如下： 1234567891011121314server { listen 8090; server_name 127.0.0.1; location / { proxy_pass https://dev.xxx.tech; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; # proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }} 可以看到，我在配置中注释了X-Real-IP，而我们在生产环境下配置Nginx时，一般会保留这几项Host，X-Real-IP，X-Forwarded-For，用以保留请求的服务器域名，原始客户端和代理服务器的IP等信息。 如果不注释X-Real-IP，前端访问入口的真实IP是127.0.0.1或localhost，Nginx不认可这样的本地ip，直接返回404，客户端请求不予代理到其他远程服务器。不扯了，这里具体的原因我也不知，如有大佬知道原因，还请点拨下，太感谢了。 好了，回到正题，有了以上的配置，我们就可以将前端代理层和Nginx代理层解耦，前端固定通过本地127.0.0.1:8090访问后端接口，而具体接口是代理到开发环境、测试环境或是生产环境，由Nginx决定，只需要修改nginx.conf后重启即可。 而Nginx热重启是非常快的，一条命令即可实现，几乎零等待时间。 1234// windows下是这个命令nginx.exe -s reload// linux是这样的nginx -s reload 本地域名听到这里，小G又将了我一军。 还好我早有准备，没有自乱阵脚。 如果真的遇到本地端口被占用的情况，最简单的办法当然是换个端口。 为了杜绝这种情况，我们可以引入本地域名，兼具“装逼”效果。 我们知道，域名是通过解析后才能得到真实的服务IP。而域名解析过程中也有这么一些关键节点，是我们应该知道的。 浏览器缓存 操作系统hosts文件 Local DNS Root DNS gTLD Server 借用网上一张图说明下大致流程（侵删）。 上图没提到hosts文件，但是不影响我们魔改。我们只要在操作系统hosts文件这个节点动下手脚，就可以实现本地域名了。 首先，我们找到C:\\Windows\\System32\\drivers\\etc\\hosts这个文件，打开后在最后新增一条解析记录 1127.0.0.1 www.devtest.com 然后保存这个文件，保存hosts文件时需要administrator权限。 这就相当于告诉本地操作系统，如果用户访问www.devtest.com，我就给他解析到127.0.0.1这个ip 所以，我们在Nginx只要监听127.0.0.1的80端口即可，配置如下。 12345678910111213server { listen 80; server_name 127.0.0.1; location / { proxy_pass https://dev.xxx.tech; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; }} 最后，我们只要在前端工程中把代理目标设置为www.devtest.com即可。 123456789proxy: { \"/api\": { target: \"http://www.devtest.com\", // 固定代理目标 changeOrigin: true, pathRewrite: { \"^/api\": \"\" } }} 这样前端访问的某接口http://localhost:8080/api/user/login就会被代理到http://www.devtest.com/user/login，而www.devtest.com被本地hosts文件解析到127.0.0.1，接着Nginx监听了127.0.0.1的80端口，将请求转发到真实的后端服务，完美！ 对了，www.devtest.com是我特意命名的一个无法访问的域名，所以你千万别把www.taobao.com这种地址解析到本地哦，不然你没法给女神买礼物别怪我。。。 今天分享给大家的干货就这么多，祝愿大家准点下班陪女神！ 看到最后，求个关注点赞，欢迎大家加我微信交流技术，闲聊也可以哦！","link":"/这篇Nginx反向代理技巧，助你准时下班陪女神.html"},{"title":"通过TortoiseGIT怎么把本地项目上传到GitHub？","text":"在本地修改代码，没有一个修改日志记录，确实很不方便。所以想着把本地的代码放在github上面。虽然在公司有大神搭建好的git服务器，按着流程commit, push, merge request走一遍就行了，但是自己是一知半解的。所以自己弄一遍流程是有必要的。 1.明确一下自己的需求暂时不考虑多人协作的情况了，先把自己的代码弄上去再说吧。欲速则不达，一步一步来吧。 2.创建GitHub仓库 点击New repository创建仓库，然后把相关信息填一下就OK了 3.创建本地仓库在自己的项目文件夹，点击右键，选择GIT Create respository here 然后右键选择Settings进行设置。主要是remote里面的设置项。 Remote的名字一般是origin。URL是你的GitHub仓库对应的URL，复制粘贴一下就好了。Putty是你本地的私钥，找到对应的文件。设置完后选择Add New，在弹出的确认框选择‘否’就好。 4.把本地代码提交到GitHub第一步，选择GIT commit提交代码。 填好必要的提交信息，选择需要提交的文件，然后点击commit commit之后记得一定要将代码push到远程服务器端。操作就是GitPush。 然后在GitHub上面就能看到自己提交的代码了，也可以看到提交的记录。 扫一扫下方小程序码或搜索Tusi博客，即刻阅读最新文章！","link":"/通过TortoiseGIT怎么把本地项目上传到GitHub？.html"}],"tags":[{"name":"面试复习手册","slug":"面试复习手册","link":"/tags/面试复习手册/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"navicat for mysql","slug":"navicat-for-mysql","link":"/tags/navicat-for-mysql/"},{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"jquery","slug":"jquery","link":"/tags/jquery/"},{"name":"bootstrap","slug":"bootstrap","link":"/tags/bootstrap/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"移动端调试","slug":"移动端调试","link":"/tags/移动端调试/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"Gerrit","slug":"Gerrit","link":"/tags/Gerrit/"},{"name":"git,remote不同步","slug":"git-remote不同步","link":"/tags/git-remote不同步/"},{"name":"微信公众号","slug":"微信公众号","link":"/tags/微信公众号/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"电脑技能","slug":"电脑技能","link":"/tags/电脑技能/"},{"name":"TortoiseGIT","slug":"TortoiseGIT","link":"/tags/TortoiseGIT/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"VMware","slug":"VMware","link":"/tags/VMware/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"websocket","slug":"websocket","link":"/tags/websocket/"},{"name":"socket.io","slug":"socket-io","link":"/tags/socket-io/"},{"name":"cordova","slug":"cordova","link":"/tags/cordova/"},{"name":"express","slug":"express","link":"/tags/express/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"gulp","slug":"gulp","link":"/tags/gulp/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Next主题","slug":"Next主题","link":"/tags/Next主题/"},{"name":"valine","slug":"valine","link":"/tags/valine/"},{"name":"百度统计","slug":"百度统计","link":"/tags/百度统计/"},{"name":"CNZZ统计","slug":"CNZZ统计","link":"/tags/CNZZ统计/"},{"name":"livere","slug":"livere","link":"/tags/livere/"},{"name":"gitment","slug":"gitment","link":"/tags/gitment/"},{"name":"微信小程序","slug":"微信小程序","link":"/tags/微信小程序/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"ionic","slug":"ionic","link":"/tags/ionic/"},{"name":"jdk","slug":"jdk","link":"/tags/jdk/"},{"name":"数据类型","slug":"数据类型","link":"/tags/数据类型/"},{"name":"构造函数","slug":"构造函数","link":"/tags/构造函数/"},{"name":"ng-zorro","slug":"ng-zorro","link":"/tags/ng-zorro/"},{"name":"sea.js","slug":"sea-js","link":"/tags/sea-js/"},{"name":"require.js","slug":"require-js","link":"/tags/require-js/"},{"name":"js模块化","slug":"js模块化","link":"/tags/js模块化/"},{"name":"Promise","slug":"Promise","link":"/tags/Promise/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue作用域插槽","slug":"vue作用域插槽","link":"/tags/vue作用域插槽/"},{"name":"vue升级","slug":"vue升级","link":"/tags/vue升级/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"http-server","slug":"http-server","link":"/tags/http-server/"},{"name":"iconfont","slug":"iconfont","link":"/tags/iconfont/"},{"name":"svg","slug":"svg","link":"/tags/svg/"},{"name":"demo","slug":"demo","link":"/tags/demo/"},{"name":"webpack4","slug":"webpack4","link":"/tags/webpack4/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"原型","slug":"原型","link":"/tags/原型/"},{"name":"继承","slug":"继承","link":"/tags/继承/"},{"name":"地图曲线","slug":"地图曲线","link":"/tags/地图曲线/"},{"name":"域名解析","slug":"域名解析","link":"/tags/域名解析/"},{"name":"发布订阅","slug":"发布订阅","link":"/tags/发布订阅/"},{"name":"观察者","slug":"观察者","link":"/tags/观察者/"},{"name":"git分支管理","slug":"git分支管理","link":"/tags/git分支管理/"},{"name":"前后端分离","slug":"前后端分离","link":"/tags/前后端分离/"},{"name":"自媒体","slug":"自媒体","link":"/tags/自媒体/"},{"name":"babel","slug":"babel","link":"/tags/babel/"},{"name":"函数","slug":"函数","link":"/tags/函数/"},{"name":"柯里化","slug":"柯里化","link":"/tags/柯里化/"},{"name":"手写代码","slug":"手写代码","link":"/tags/手写代码/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/正则表达式/"},{"name":"axios","slug":"axios","link":"/tags/axios/"},{"name":"架构","slug":"架构","link":"/tags/架构/"},{"name":"gitlab","slug":"gitlab","link":"/tags/gitlab/"},{"name":"html5","slug":"html5","link":"/tags/html5/"},{"name":"自动化部署","slug":"自动化部署","link":"/tags/自动化部署/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"前端","slug":"前端","link":"/tags/前端/"},{"name":"面试题","slug":"面试题","link":"/tags/面试题/"},{"name":"前端基础","slug":"前端基础","link":"/tags/前端基础/"},{"name":"meta","slug":"meta","link":"/tags/meta/"},{"name":"发布npm包","slug":"发布npm包","link":"/tags/发布npm包/"},{"name":"umd规范","slug":"umd规范","link":"/tags/umd规范/"},{"name":"呼吸灯","slug":"呼吸灯","link":"/tags/呼吸灯/"},{"name":"CommonJS","slug":"CommonJS","link":"/tags/CommonJS/"},{"name":"amd规范","slug":"amd规范","link":"/tags/amd规范/"},{"name":"回文数","slug":"回文数","link":"/tags/回文数/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"ocx","slug":"ocx","link":"/tags/ocx/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"记事本","slug":"记事本","link":"/tags/记事本/"},{"name":"自定义tabbar","slug":"自定义tabbar","link":"/tags/自定义tabbar/"},{"name":"Promise/A+","slug":"Promise-A","link":"/tags/Promise-A/"},{"name":"css单位","slug":"css单位","link":"/tags/css单位/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"progress","slug":"progress","link":"/tags/progress/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"滑块美化","slug":"滑块美化","link":"/tags/滑块美化/"},{"name":"Chrome自动填充","slug":"Chrome自动填充","link":"/tags/Chrome自动填充/"},{"name":"npm速度慢","slug":"npm速度慢","link":"/tags/npm速度慢/"},{"name":"git push报错","slug":"git-push报错","link":"/tags/git-push报错/"},{"name":"闭包","slug":"闭包","link":"/tags/闭包/"},{"name":"词法环境","slug":"词法环境","link":"/tags/词法环境/"},{"name":"执行上下文","slug":"执行上下文","link":"/tags/执行上下文/"},{"name":"ECMAScript5","slug":"ECMAScript5","link":"/tags/ECMAScript5/"},{"name":"反向代理","slug":"反向代理","link":"/tags/反向代理/"},{"name":"本地域名","slug":"本地域名","link":"/tags/本地域名/"}],"categories":[{"name":"面试","slug":"面试","link":"/categories/面试/"},{"name":"msyql","slug":"msyql","link":"/categories/msyql/"},{"name":"angular","slug":"angular","link":"/categories/angular/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"web前端","slug":"web前端","link":"/categories/web前端/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"源码分析","slug":"源码分析","link":"/categories/源码分析/"},{"name":"微信公众号","slug":"微信公众号","link":"/categories/微信公众号/"},{"name":"电脑技能","slug":"电脑技能","link":"/categories/电脑技能/"},{"name":"编码规范","slug":"编码规范","link":"/categories/编码规范/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"hybrid","slug":"hybrid","link":"/categories/hybrid/"},{"name":"java","slug":"java","link":"/categories/java/"},{"name":"gulp","slug":"gulp","link":"/categories/gulp/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"小程序","slug":"小程序","link":"/categories/小程序/"},{"name":"Promise","slug":"Promise","link":"/categories/Promise/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"demo","slug":"demo","link":"/categories/demo/"},{"name":"webpack","slug":"webpack","link":"/categories/webpack/"},{"name":"mysql","slug":"mysql","link":"/categories/mysql/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"运维","slug":"运维","link":"/categories/运维/"},{"name":"写作","slug":"写作","link":"/categories/写作/"},{"name":"babel","slug":"babel","link":"/categories/babel/"},{"name":"架构设计","slug":"架构设计","link":"/categories/架构设计/"},{"name":"nodejs","slug":"小程序/nodejs","link":"/categories/小程序/nodejs/"},{"name":"sass","slug":"sass","link":"/categories/sass/"},{"name":"html5","slug":"html5","link":"/categories/html5/"},{"name":"部署运维","slug":"部署运维","link":"/categories/部署运维/"},{"name":"html","slug":"html","link":"/categories/html/"},{"name":"npm","slug":"npm","link":"/categories/npm/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"记事本","slug":"记事本","link":"/categories/记事本/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/微信小程序/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"canvas","slug":"canvas","link":"/categories/canvas/"},{"name":"Nginx","slug":"Nginx","link":"/categories/Nginx/"}]}